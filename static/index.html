<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>miRvana</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/dist/tippy.css" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <script src="d3.v7.8.5.min.js"></script>
    <script src="//code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="//cdn.opencpu.org/opencpu-0.4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simple-statistics/7.0.0/simple-statistics.min.js"></script>
    <script src='https://cdn.jsdelivr.net/gh/kdpsingh/rjs@master/r.js'></script>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pretty-checkbox@3.0/dist/pretty-checkbox.min.css"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pretty-checkbox@3.0/dist/pretty-checkbox.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.25.6/d3-legend.js"
        integrity="sha512-5mCB0Kvv97yTzqo0174qxPjMisck/WlK51+mw/RV7UfYbtHI8LuLR82BzZuxHUKSfbh75u9cZHgUcqrZDaBJuA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js"
        integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49"
        crossorigin="anonymous"></script>

    <link rel="stylesheet" href="https://cdn.datatables.net/2.0.7/css/dataTables.dataTables.css" />
    <script src="https://cdn.datatables.net/2.0.7/js/dataTables.js"></script>
    <link href="https://cdn.datatables.net/select/2.1.0/css/select.dataTables.css" rel="stylesheet">

    <script src="https://cdn.datatables.net/select/2.1.0/js/dataTables.select.js"></script>
    <script src="css/bootstrap.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.30.3/cytoscape.min.js"
        integrity="sha512-oHBLiJyO02B4XgizsMos74uf/p8b1fUqLV5Pc8HaFF6rR0123STTQN3qOh29hYvdId5g24Wfno5gpfsP8enzfQ=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>



    <style>
        body {
            background-color: var(--body-background-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            /* Full height of the viewport */
            overflow: hidden;
            font-size: 90%;
            /* Base font size for scaling */
        }

        .navbar {
            flex: 0 0 auto;
            padding: 0.3em;
            display: flex;
            align-items: center;
        }

        .navbar .navbar-brand,
        .navbar .btn {
            font-size: 0.85em;
            margin-right: 0.8em;
        }

        #color_modal {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 50px;
            height: 30px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }

        #color_modal::-webkit-color-swatch {
            border-radius: 5px;
            border: none;
        }

        #color_modal::-moz-color-swatch {
            border-radius: 5px;
            border: none;
        }

        /* Additional styles to adjust layout */
        .color-input-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
        }

        .input-wrapper {
            margin-left: 10px;
            /* Adjust the margin to fine-tune the distance */
        }

        .value-span {
            flex: 1;
            text-align: center;
            /* Center the text */
        }

        .color-input-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0px 24px;
            gap: 0px;
            /* Adjust gap to bring elements closer */
        }

        .input-wrapper {
            display: inline-block;
            margin-right: 70px;
        }

        .value-span {
            margin-right: 10px;
            /* Optional: Adjust right margin to bring it closer to the input */
        }

        .category-container {
            margin-bottom: 10px;
            /* Add some space between category containers */
        }

        #csvTableData2_wrapper {
            overflow-x: hidden;
            /* Hide the x scrollbar */
        }


        .value-span {
            display: inline-block;
            text-align: left;
            /* Center the unique value */
            margin-left: 40px;
            /* Add some space between the value and the color input */
        }

        .highlight {
            background-color: rgba(var(--dt-row-hover), 0.052) !important;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            width: 28px;

        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .axis-label {
            cursor: pointer;
            /* Cursor style when hovering over the axis label */
        }

        .dragging {
            cursor: move;
            /* Cursor style during dragging */
        }


        #thresholdSlider {
            width: 5%;
        }

        :root {
            --text-color: white;
            --background-color: rgb(33, 33, 33);
            --axis-line-color: white;
            --body-background-color: #F1F1F1;
            --nav-background-color: rgb(33 33 33) !important;
        }

        .light-theme {
            --text-color: black;
            --background-color: white;
            --axis-line-color: black;
            --body-background-color: #F1F1F1;
            --nav-background-color: rgb(180 180 180) !important;
        }

        body.bg-light {
            background-color: var(--nav-background-color)
        }

        .flex-container {
            display: flex;
            flex-direction: column;
            /* Stack children vertically */
            height: 100%;
            /* Full height of parent */
            border: 2px solid #ddd;

            background-color: var(--background-color);
            color: var(--text-color);
        }

        .axis path,
        .axis line {
            stroke: var(--axis-line-color);
        }

        .axis text {
            fill: var(--text-color);
        }

        svg text {
            fill: var(--text-color);
        }

        svg line,
        svg path {
            stroke: var(--axis-line-color);
        }

        .text-element {
            color: var(--text-color);
            fill: var(--text-color);
        }

        .text {
            color: var(--text-color);
            fill: var(--text-color);
        }

        .axis {
            color: var(--axis-color);

        }

        #main_div {
            flex: 1;
            display: flex;
            flex-direction: row;
            width: 100vw;
            /* Full viewport width */
            height: 100vh;
            overflow-y: hidden;
            padding: 0.2em;
            /* Inner padding inside #main_div */
            height: 100vh;
            /* Restrict to full viewport height */
            gap: 0.21em;
            /* Space between the divs (columns) */

            box-sizing: border-box;
            /* Ensure padding and gap don't cause overflow */

        }


        #style_scatter {
            display: flex;
            flex-direction: column;
            /* Stack the children vertically */
            height: 100%;
            /* Full height of the parent flex-container */
        }

        #IQR {
            flex: 0 0 15%;
            /* Set the height of the IQR section, e.g., 25% of its parent */
            display: flex;
            /* Set display to flex to align the SVG */
        }

        #IQR svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #IQR .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        #logFCHistogram {
            flex: 0 0 15%;
            /* Set the height of the IQR section, e.g., 25% of its parent */
            display: flex;
            /* Set display to flex to align the SVG */
        }

        #logFCHistogram svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #logFCHistogram .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        #boxPlot {
            flex: 0 0 50%;
            /* Set the height of the boxPlot section, e.g., 25% of its parent */
            display: flex;
            /* Set display to flex to align the SVG */
        }

        #boxPlot svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #boxPlot .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }


        #scatterPlot {
            flex: 0 0 50%;
            /* Set the height of the scatterPlot to 40% of its parent */
            display: flex;
            /* Set display to flex to align the SVG */
        }

        #scatterPlot svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #scatterPlot .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        #parallel {
            flex: 1;
            /* Allow parallel to take available space */
            display: flex;
            /* Align items */
            overflow: hidden;
        }

        #parallel svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #parallel .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        #parallelLegend {
            flex: 0 0 auto;
            /* Maintain its height but allow it to shrink */
            display: flex;
            /* Align items */
            align-items: flex-end;
            /* Align items to the bottom */
        }

        #parallelLegend svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #parallelLegend .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        #pca {
            flex: 0 0 35%;
            /* Set the height of the parallel section */
            display: flex;
            /* Set display to flex to align the SVG */
            align-items: flex-end;
            /* Align items to the bottom */
            margin-top: 0;
            /* Push the parallel section to the bottom */
        }

        #pca svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #pca .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        #heatmap {
            flex: 0 0 30%;
            /* Set the height of the parallel section */
            display: flex;
            /* Set display to flex to align the SVG */
            align-items: flex-end;
            /* Align items to the bottom */
            margin-top: 0;
            /* Push the parallel section to the bottom */
        }

        #heatmap svg {
            width: 100%;
            /* Full width */
            height: 100%;
            /* Full height */
        }

        #heatmap .svg-container {
            flex: 1;
            /* Allow SVG to grow */
        }

        .svg-container {
            flex-grow: 1;
            /* Allow the SVGs to grow and fill available space equally */
            display: flex;
            justify-content: center;
            /* Center the content inside */
            align-items: center;
            /* Center the content vertically */
        }

        #counters {
            flex: 0 0 10%;
            /* Set the height of the parallel section */
            display: flex;
            /* Set display to flex to align the SVG */
            align-items: flex-end;
            /* Align items to the bottom */
            margin-top: 0;
            /* Push the parallel section to the bottom */
        }

        #counters .flex {
            width: 50%;
            /* Full width */
            height: 50%;
            /* Full height */
            flex: 1;
        }

        input[type="checkbox"] {
            /* Align checkboxes */
            margin: 0;
            /* Remove default margin */
            vertical-align: middle;
            /* Align with text */
        }

        label {
            margin-left: 5px;
            /* Space between checkbox and label */
            line-height: 1.5;
            /* Ensure good spacing */
        }


        input.range1 {
            --c: grey;
            /* active color */
            --l: 6px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 6px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range1:focus-visible,
        input.range1:hover {
            --p: 25%;
        }

        /* chromium */
        input.range1[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, gold 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        /* Second range slider with a different color scheme */
        input.range2 {
            --c: grey;
            /* active color */
            --l: 6px;
            /* line thickness */
            --h: 30px;
            /* thumb height */
            --w: 6px;
            /* thumb width */

            width: 400px;
            height: var(--h);
            /* needed for Firefox */
            --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: none;
            cursor: pointer;
            overflow: hidden;
        }

        input.range2:focus-visible,
        input.range2:hover {
            --p: 25%;
        }

        /* chromium */
        input.range2[type="range" i]::-webkit-slider-thumb {
            height: var(--h);
            width: var(--w);
            background: var(--_c);
            border-image: linear-gradient(90deg, var(--_c) 50%, #2e8b57 0) 0 1/calc(50% - var(--l)/2) 100vw/0 100vw;
            -webkit-appearance: none;
            appearance: none;
            transition: .3s;
        }

        @supports not (color: color-mix(in srgb, red, red)) {
            input {
                --_c: var(--c);
            }
        }

        @keyframes pulseAnimation {
            0% {
                fill: green;
                r: 2;
            }

            50% {
                fill: lime;
                /* Color during the pulse */
                r: 6
            }

            100% {
                fill: green;
                r: 2
            }
        }

        .pulse {
            animation: pulseAnimation 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseAnimation1 {
            0% {

                r: 2;
            }

            50% {

                r: 4
            }

            100% {

                r: 2
            }
        }

        .pulse1 {
            animation: pulseAnimation1 1s infinite;
            /* You can adjust the duration as needed */
        }

        @keyframes pulseRedAnimation {
            0% {
                stroke: aqua;
                /* Initial color */
                stroke-width: 2;
                /* Initial stroke width */
            }

            50% {
                stroke: rgb(198, 255, 255);
                /* Color during the pulse */
                stroke-width: 3;
                /* Increased stroke width during the pulse */
            }

            100% {
                stroke: aqua;
                /* Back to initial color */
                stroke-width: 2;
                /* Back to initial stroke width */
            }
        }

        .pulse-red {
            animation: pulseRedAnimation 1s infinite;
            /* Adjust duration as needed */
        }

        .loader {
            color: goldenrod;
            font-size: 45px;
            text-indent: -9999em;
            overflow: hidden;
            width: 1em;
            height: 1em;
            border-radius: 50%;
            position: relative;
            transform: translateZ(0);
            animation: mltShdSpin 1.7s infinite ease, round 1.7s infinite ease;
        }

        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');

        .loading-text {
            font-family: 'Open Sans', sans-serif;
            color: goldenrod;
            font-size: 1.5em;
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 2px;
            /* Add a bit of space between the dots */
        }

        .dot {
            opacity: 0;
            transform: scale(0.5);
            /* Start smaller */
            animation: dot-pulse 1.5s infinite cubic-bezier(0.5, 0, 0.5, 1);
        }

        .dot:nth-child(1) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(2) {
            animation-delay: 0.4s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.6s;
        }


        @keyframes mltShdSpin {
            0% {
                box-shadow: 0 -0.83em 0 -0.4em,
                    0 -0.83em 0 -0.42em, 0 -0.83em 0 -0.44em,
                    0 -0.83em 0 -0.46em, 0 -0.83em 0 -0.477em;
            }

            5%,
            95% {
                box-shadow: 0 -0.83em 0 -0.4em,
                    0 -0.83em 0 -0.42em, 0 -0.83em 0 -0.44em,
                    0 -0.83em 0 -0.46em, 0 -0.83em 0 -0.477em;
            }

            10%,
            59% {
                box-shadow: 0 -0.83em 0 -0.4em,
                    -0.087em -0.825em 0 -0.42em, -0.173em -0.812em 0 -0.44em,
                    -0.256em -0.789em 0 -0.46em, -0.297em -0.775em 0 -0.477em;
            }

            20% {
                box-shadow: 0 -0.83em 0 -0.4em, -0.338em -0.758em 0 -0.42em,
                    -0.555em -0.617em 0 -0.44em, -0.671em -0.488em 0 -0.46em,
                    -0.749em -0.34em 0 -0.477em;
            }

            38% {
                box-shadow: 0 -0.83em 0 -0.4em, -0.377em -0.74em 0 -0.42em,
                    -0.645em -0.522em 0 -0.44em, -0.775em -0.297em 0 -0.46em,
                    -0.82em -0.09em 0 -0.477em;
            }

            100% {
                box-shadow: 0 -0.83em 0 -0.4em, 0 -0.83em 0 -0.42em,
                    0 -0.83em 0 -0.44em, 0 -0.83em 0 -0.46em, 0 -0.83em 0 -0.477em;
            }
        }

        @keyframes round {
            0% {
                transform: rotate(0deg)
            }

            100% {
                transform: rotate(360deg)
            }
        }

        @keyframes dot-pulse {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }

            50% {
                opacity: 1;
                transform: scale(1);
                /* Increase size for pulsing effect */
            }

            100% {
                opacity: 0;
                transform: scale(0.5);
                /* Return to initial size */
            }
        }


        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent black background */
            z-index: 9999;
            /* Ensure the overlay appears above other elements */
            display: block;
            /* Initially hidden */
        }

        /* You can customize the loading indicator style here */
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            /* Add more styles as needed */
        }

        #radioBoxContainer::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 0.375em rgba(0, 0, 0, 0.3);
            /* 6px converted to em */
            border-radius: 0.625em;
            /* 10px converted to em */
            background-color: #F5F5F5;
        }

        #radioBoxContainer::-webkit-scrollbar {
            width: 0.5em;
            /* 8px converted to em */
            background-color: #F5F5F5;
        }

        #radioBoxContainer::-webkit-scrollbar-thumb {
            border-radius: 0.625em;
            /* 10px converted to em */
            -webkit-box-shadow: inset 0 0 0.375em rgba(0, 0, 0, 0.3);
            /* 6px converted to em */
            background-color: #6c757d;
        }

        #checkboxContainer::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 0.375em rgba(0, 0, 0, 0.3);
            /* 6px converted to em */
            border-radius: 0.625em;
            /* 10px converted to em */
            background-color: #F5F5F5;
        }

        #checkboxContainer::-webkit-scrollbar {
            width: 0.5em;
            /* 8px converted to em */
            background-color: #F5F5F5;
        }

        #checkboxContainer::-webkit-scrollbar-thumb {
            border-radius: 0.625em;
            /* 10px converted to em */
            -webkit-box-shadow: inset 0 0 0.375em rgba(0, 0, 0, 0.3);
            /* 6px converted to em */
            background-color: #6c757d;
        }


        .category-label-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0px 24px;
            /* Adjust padding to control spacing */
            gap: 0px;
            position: relative;
            /* Ensure relative positioning for absolute button placement */
        }

        .resort-button {
            margin-right: 16px;
            /* Move the button 16px to the left */
        }

        .dropdown-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            /* Space between each category block */
        }

        .radio-label {
            flex-shrink: 0;
            margin-right: 20px;
            /* Space between the label and the dropdowns */
        }

        .dropdowns-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .dropdowns-container select {
            margin: 0 5px;
        }

        .vs-text {
            margin: 0 10px;
        }

        /* Additional styles for dropdowns if needed */
        select[name="dropdown1"],
        select[name="dropdown2"] {
            min-width: 150px;
            /* Ensure dropdowns have a minimum width */
        }

        #controlPanel {
            display: flex;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .search-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
            position: relative;
        }

        #searchInput {
            width: 150px;
        }

        #searchButton {
            margin-left: 10px;
        }

        #searchResultsDropdown {
            position: absolute;
            background-color: #fff;
            border: 1px solid #ccc;
            max-height: 200px;
            display: none;

            overflow-y: auto;
            z-index: 2;
        }

        .result-item {
            cursor: pointer;
            /* Change cursor to pointer */
            background-color: white;
            transition: background-color 0.3s ease;
            /* Smooth transition effect */
            /* padding: 5px; Optional: Add padding for better appearance */
            display: block;
            /* Ensures the element behaves like a block-level element */
            text-decoration: none;
            /* Remove underline for links if any */
            color: black;
            /* Set text color */
            margin-bottom: 5px;
            /* Add margin for spacing between items */
        }

        .result-item:hover {
            background-color: grey;
            /* Change background color on hover */
        }

        #tooltip {
            position: absolute;
            text-align: center;
            width: 120px;
            /* Adjust width as needed */
            padding: 10px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.8);
            /* Semi-transparent background */
            color: #000000;
            /* White text color */
            border-radius: 5px;
            /* Rounded corners */
            pointer-events: none;
            /* Prevent mouse events */
            opacity: 0;
            /* Initially hidden */
            transition: opacity 0.3s;
            /* Smooth transition */
        }

        .tab {
            overflow: hidden;
            background-color: #f1f1f1;
        }

        .tab button {
            background-color: inherit;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
            color: #000;
            /* Default text color */
        }

        .tab button:hover {
            background-color: #ddd;
            /* Light gray background on hover */
            color: #000;
            /* Text color remains black on hover */
        }

        .tab button.active {
            background-color: #ccc;
            /* Active tab background color */
            color: #000;
            /* Active tab text color */
        }

        .tabcontent {
            display: none;
        }

        /* Responsive styling */
        @media (max-width: 768px) {
            body {
                font-size: 85%;
            }

            .navbar .navbar-brand,
            .navbar .btn {
                font-size: 0.8em;
            }

            .flex-container {
                margin: 0.3em;
            }
        }

        #buttonBoxContainer {
            display: inline-flex;
            /* Aligns elements horizontally */
            align-items: center;
            /* Centers items vertically */
        }

        #toggleHeatmapButton {
            font-size: 0.8em;
            padding: 0.1em 0.2em;
            width: 33%;
            max-width: 20em;
            margin-left: 5px;
        }

        #selectButton {
            font-size: 0.8em;
            padding: 0.1em 0.2em;
            width: 33%;
            max-width: 20em;
            margin-left: 5px;
        }

        #switchBoxRidgeButton {
            font-size: 0.8em;
            padding: 0.1em 0.2em;
            margin-left: auto;
            margin-right: 7px;
            /* Space between the dropdown and the new button */
        }

        #counter,
        #counter1 {
            color: var(--text-color);
            border: 0.01px solid #ddd;
            border-bottom: none;
            border-right: none;
            border-left: none;
            box-sizing: border-box;
            text-align: left;
            justify-content: space-evenly;
            overflow: hidden;
            /* Prevent overflow */
            white-space: nowrap;
            /* Prevent line breaks */
        }

        /* Initial styles for the brand */
        .navbar-brand {
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.6s ease-in-out;
            /* Smoother transition */
            white-space: nowrap;
            overflow: hidden;
        }

        /* Smooth hover effect for expanding the text */
        .navbar-brand:hover {
            font-size: 2.5rem;
            /* Smooth size increase */
            letter-spacing: 0.02em;
            /* Slight letter-spacing adjustment */
            transform: scale(1.05);
            /* Slight scaling for a subtle effect */
        }

        /* Expanded text on hover */
        .navbar-brand:hover::after {
            content: ' - miRNA Visual Analytics';
            white-space: nowrap;
            font-size: 0.8rem;
            opacity: 1;
            /* Set to 1 to show text on hover */
            transition: opacity 0.6s ease-in-out;
            /* Smooth transition for opacity and spacing */
        }

        /* Hide additional text when not hovering */
        .navbar-brand::after {
            content: '';
            /* Initially empty */
            opacity: 0;
            /* Initially hidden */
            margin-left: 0;
            /* Reset margin */
            transition: opacity 0.6s ease-in-out;
            /* Smooth transition for hiding text and resetting margin */
        }

        /* Smooth hover effect for buttons and spacing
        #nav:hover button,
        #nav:hover span {
            transition: all 0.2s ease-in-out;
        }

        button {
            transition: all 0.2s ease-in-out;
        }

        button:hover {
            transform: scale(1.15);
        } */

        /* Keyframes for fading in the additional text */
        @keyframes fadeIn {
            0% {
                opacity: 0;
                transform: translateX(0px);
            }

            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        #heatmapContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 50%;
            max-width: 150%;
            max-height: 150%;
            overflow: auto;
            text-align: center;

            /* Make it resizable */
            resize: both;
            /* "both" allows resizing horizontally and vertically */
            overflow: auto;
            /* Ensure scrollbars appear if needed */
        }


        #heatmapCon {
            width: 100%;
            /* Set a max width for larger screens */
            height: 100%;
            /* Set a fixed height for the container */
            overflow-y: auto;
            /* Enable vertical scrolling */
            overflow-x: hidden;
            /* Prevent horizontal scrolling */
        }


        /* Custom scrollbar styles for WebKit browsers (Chrome, Safari) */
        #heatmapCon::-webkit-scrollbar {
            width: 8px;
            /* Width of the scrollbar */
        }

        #heatmapCon::-webkit-scrollbar-track {
            background: #f1f1f1;
            /* Background color of the track */
            border-radius: 10px;
            /* Rounded corners for the track */
        }

        #heatmapCon::-webkit-scrollbar-thumb {
            background: #000000;
            /* Color of the scrollbar thumb */
            border-radius: 10px;
            /* Rounded corners for the thumb */
        }

        #heatmapCon::-webkit-scrollbar-thumb:hover {
            background: #000000;
            /* Change color on hover */
        }

        /* Optional: Style for the scrollbar corner (if visible) */
        #heatmapCon::-webkit-scrollbar-corner {
            background: transparent;
            /* Make corner transparent */
        }



        #heatmapCon svg {
            width: 100%;
            /* Make the SVG take the full width of the container */
            height: auto;
            /* Maintain aspect ratio */
            display: block;
            /* Prevent inline spacing issues */
        }

        /* Style for fading out elements */
        .fade-out {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        /* Style for fading in the heatmap */
        .fade-in {
            display: block;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        #d3tooltip {
            position: absolute;
            width: 200px;
            height: auto;
            padding: 10px;
            background-color: #fafafa;
            -webkit-border-radius: 10px;
            -moz-border-radius: 10px;
            border-radius: 10px;
            -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
            -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
            box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
            pointer-events: none;
            opacity: 0;
        }

        #d3tooltip.hidden {
            display: none;
        }

        #d3tooltip p {
            margin: 0;
            font-family: sans-serif;
            font-size: 12px;
            line-height: 20px;
        }

        rect.selection {
            stroke: #333;
            stroke-dasharray: 4px;
            stroke-opacity: 0.5;
            fill: transparent;
        }

        rect.cell-border {
            stroke: #eee;
            stroke-width: 0.3px;
        }

        rect.cell-selected {
            stroke: rgb(51, 102, 153);
            stroke-width: 0.5px;
        }

        rect.cell-hover {
            stroke: rgb(0, 0, 0);
            stroke-width: 1px;
        }

        text.mono {
            font-size: 9pt;
            font-family: Consolas, courier;
            fill: #aaa;
        }

        .rlink,
        .clink {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        text.text-highlight {
            font-size: 12pt;
            font-weight: 300;
            fill: var(--text-color);
        }

        .brush .selection {
            fill: #777;
            /* Dark gray fill color for selection */
            fill-opacity: 0.3;
            /* Semi-transparent */
            stroke: #fff;
            /* White stroke for selection border */
            stroke-width: 1;
            /* Set a solid stroke width */
            stroke-dasharray: none;
            /* Ensure stroke is solid */
            shape-rendering: crispEdges;
            /* Ensure sharp edges */
        }

        .brush-scatter .selection {
            fill: #777;
            /* Dark gray fill color for selection */
            fill-opacity: 0.3;
            /* Semi-transparent */
            stroke: #fff;
            /* White stroke for selection border */
            stroke-width: 1;
            /* Set a solid stroke width */
            stroke-dasharray: none;
            /* Ensure stroke is solid */
            shape-rendering: crispEdges;
            /* Ensure sharp edges */
        }

        .brush-left .selection {
            fill: #777;
            /* Dark gray fill color for selection */
            fill-opacity: 0.3;
            /* Semi-transparent */
            stroke: #fff;
            /* White stroke for selection border */
            stroke-width: 1;
            /* Set a solid stroke width */
            stroke-dasharray: none;
            /* Ensure stroke is solid */
            shape-rendering: crispEdges;
            /* Ensure sharp edges */
        }

        .brush-right .selection {
            fill: #777;
            /* Dark gray fill color for selection */
            fill-opacity: 0.3;
            /* Semi-transparent */
            stroke: #fff;
            /* White stroke for selection border */
            stroke-width: 1;
            /* Set a solid stroke width */
            stroke-dasharray: none;
            /* Ensure stroke is solid */
            shape-rendering: crispEdges;
            /* Ensure sharp edges */
        }

        /* Add a resizer handle style */
        .resizer {
            cursor: ew-resize;
            width: 2px;
            /* Width of the resizer handle */
            background: #ddd;
            /* Color of the handle */
            height: 100%;
            /* Full height of the container */
            position: absolute;
            right: 0;
            /* Position it on the right edge of the left panel */
            top: 0;
            z-index: 10;
            /* Ensure it sits above other elements */
        }

        #leftPanel {
            display: flex;
            flex-direction: column;
            width: 25%;
            min-width: 100px;
            max-width: 20%;
            height: 100vh;
            position: relative;
            transition: width 0.3s ease, visibility 0.3s ease, opacity 0.3s ease;
            /* Add transition for visibility and opacity */
            /* Add transition for width */
        }

        #collapseButton {
            position: absolute;
            top: 1%;
            right: -25px;
            /* Place the button at the right border */
            transform: translateY(-50%);
            background-color: var(--body-background-color);
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color);
            z-index: 100;
            opacity: 0.1;
            /* Set opacity to 0.1 by default */
            transition: opacity 0.3s ease;
            /* Smooth transition for opacity change */
        }

        /* Change opacity to 1 on hover */
        #collapseButton:hover {
            opacity: 1;
        }

        #showLeftPanelBtn {
            display: none;
            position: absolute;
            top: 1%;
            background-color: var(--body-background-color);
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color);
            z-index: 100;
            opacity: 0.1;
            /* Set opacity to 0.1 by default */
            width: 25px;
            /* Set initial small width */
            transition: opacity 0.3s ease, width 0.3s ease;
            /* Smooth transitions for opacity and width */
        }

        /* Change opacity to 1 and increase width on hover */
        #showLeftPanelBtn:hover {
            opacity: 1;
            width: 40px;
            /* Increase width on hover */
        }

        #middleLeftPanel {
            flex: 1;
            /* Take remaining space */
            display: flex;
            height: 100%;
            /* Ensure full height */
        }

        #middleRightPanel {
            display: flex;
            flex-direction: column;
            width: 29%;
            min-width: 100px;
            /* Optional: Limit max width when resizing */
            max-height: 100vh;
            /* Optional: Set a max height relative to the viewport */
            position: relative;
        }


        #rightPanel {
            width: 26%;
            /* Fixed percentage width */
            display: flex;
            height: 100%;
            /* Ensure full height */
        }

        #rightPanel2 {
            width: 26%;
            /* Fixed percentage width */
            display: flex;
            height: 100%;
            /* Ensure full height */
        }

        .hidden {
            display: none;
        }

        .highlighted {
            background-color: #f0f0f0;
            /* Change to the desired highlight color */
        }

        .tabs-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            /* Take remaining height */
            max-height: 100%;
            overflow: hidden;
            max-width: 100%;
        }

        .tabs {
            flex: 0 0 auto;
            /* The tabs stay at the top */
            display: flex;
            justify-content: center;
        }

        .tab-button {
            background-color: #f1f1f1;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }

        .tab-button:hover {
            background-color: #ddd;
        }

        .tabcontent {
            flex: 1;
            /* Table container fills the remaining space */
            display: none;
            overflow: hidden;
        }

        .tabcontent.active {
            display: flex;
            flex-direction: column;
        }


        /* Apply overflow-y: auto only for the metrics table content */
        #metricsTableTab>div {
            flex: 1;
            overflow-y: auto;
            /* Enable vertical scrolling */
        }

        /* Apply overflow-y: auto only for the metrics table content */
        #edgeListTableTab>div {
            flex: 1;
            overflow-y: auto;
            /* Enable vertical scrolling */

        }


        table {
            width: 100%;
            max-height: 100%;
            /* Ensure table respects available height */
            overflow: auto;
        }

        /* Styling for the Run Functional Analysis button */
        .run-button {
            margin-left: auto;
            /* Push this button to the right */
            background-color: #4CAF50;
            /* Green background */
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .run-button:hover {
            background-color: #45a049;
        }

        /* Custom scrollbar styles for WebKit browsers (Chrome, Safari) */
        #UpDiffTable::-webkit-scrollbar,
        #DownDiffTable::-webkit-scrollbar {
            width: 8px;
            /* Width of the scrollbar */
        }

        #UpDiffTable::-webkit-scrollbar-track,
        #DownDiffTable::-webkit-scrollbar-track {
            background: #f1f1f1;
            /* Background color of the track */
            border-radius: 10px;
            /* Rounded corners for the track */
        }

        #UpDiffTable::-webkit-scrollbar-thumb,
        #DownDiffTable::-webkit-scrollbar-thumb {
            background: #000000;
            /* Color of the scrollbar thumb */
            border-radius: 10px;
            /* Rounded corners for the thumb */
        }

        #UpDiffTable::-webkit-scrollbar-thumb:hover,
        #DownDiffTable::-webkit-scrollbar-thumb:hover {
            background: #000000;
            /* Change color on hover */
        }

        /* Optional: Style for the scrollbar corner (if visible) */
        #UpDiffTable::-webkit-scrollbar-corner,
        #DownDiffTable::-webkit-scrollbar-corner {
            background: transparent;
            /* Make corner transparent */
        }










        /* Custom scrollbar styles for WebKit browsers (Chrome, Safari) */
        *::-webkit-scrollbar {
            width: 8px;
            /* For vertical scrollbar */
            height: 8px;
            /* For horizontal scrollbar */
        }

        *::-webkit-scrollbar-track {
            background: #f1f1f1;
            /* Background color of the track */
            border-radius: 10px;
            /* Rounded corners for the track */
        }

        *::-webkit-scrollbar-thumb {
            background: #000000;
            /* Color of the scrollbar thumb */
            border-radius: 10px;
            /* Rounded corners for the thumb */
        }

        *::-webkit-scrollbar-thumb:hover {
            background: #000000;
            /* Change color on hover */
        }

        /* Optional: Style for the scrollbar corner (if visible) */
        *::-webkit-scrollbar-corner {
            background: transparent;
            /* Make corner transparent */
        }

        /* Set smaller font size for the Up-regulated miRNAs table */
        #differentialUpExpressedTable,
        #differentialDownExpressedTable {
            font-size: 12px;
            /* Adjust the size as needed */
        }

        .dt-layout-row,
        .dt-layout-row * {
            font-size: 12px !important;
        }

        /* Custom selection color for downregulated table */
        #differentialUpExpressedTable tbody tr.selected {
            background-color: rgb(193, 74, 130);
            /* Set the desired RGB color */
            color: white;
            /* Adjust the text color for better contrast */
        }

        /* If you want to specifically target the shadow effect too */
        #differentialUpExpressedTable tbody>tr.selected>.sorting_1,
        #differentialUpExpressedTable tbody>tr.selected>.sorting_2,
        #differentialUpExpressedTable tbody>tr.selected>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(193, 74, 130, 0.9);
            /* Adjust the shadow effect */
        }

        /* Specific CSS for selected rows in the downregulated miRNA table */
        #differentialUpExpressedTable tbody tr.selected {
            background-color: rgb(193, 74, 130) !important;
            /* Set the background color to rgb(193, 74, 130) */
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* You can also add some extra styling for text or borders if desired */
        #differentialUpExpressedTable tbody tr.selected td {
            color: white !important;
            /* Optionally change text color */
            border: 1px solid rgb(193, 74, 130) !important;
            /* Optionally change border color */
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* If you want to change the highlight for odd/even rows, you can modify the existing styles */
        #differentialUpExpressedTable tbody>tr:nth-child(odd).selected {
            background-color: rgb(193, 74, 130) !important;
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* Custom selection color for downregulated table */
        #differentialDownExpressedTable tbody tr.selected {
            background-color: rgb(26, 116, 213);
            /* Set the desired RGB color */
            color: white;
            /* Adjust the text color for better contrast */
        }

        /* If you want to specifically target the shadow effect too */
        #differentialDownExpressedTable tbody>tr.selected>.sorting_1,
        #differentialDownExpressedTable tbody>tr.selected>.sorting_2,
        #differentialDownExpressedTable tbody>tr.selected>.sorting_3 {
            box-shadow: inset 0 0 0 9999px rgba(26, 116, 213, 0.9);
            /* Adjust the shadow effect */
        }

        /* Specific CSS for selected rows in the downregulated miRNA table */
        #differentialDownExpressedTable tbody tr.selected {
            background-color: rgb(26, 116, 213) !important;
            /* Set the background color to rgb(193, 74, 130) */
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* You can also add some extra styling for text or borders if desired */
        #differentialDownExpressedTable tbody tr.selected td {
            color: white !important;
            /* Optionally change text color */
            border: 1px solid rgb(26, 116, 213) !important;
            /* Optionally change border color */
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* If you want to change the highlight for odd/even rows, you can modify the existing styles */
        #differentialDownExpressedTable tbody>tr:nth-child(odd).selected {
            background-color: rgb(26, 116, 213) !important;
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* Custom selection color for downregulated table */
        #metricsTable tbody tr.selected {
            background-color: rgb(31, 31, 31);
            /* Set the desired RGB color */
            color: white;
            /* Adjust the text color for better contrast */
        }

        /* If you want to specifically target the shadow effect too */
        #metricsTable tbody>tr.selected>.sorting_1,
        #metricsTable tbody>tr.selected>.sorting_2,
        #metricsTable tbody>tr.selected>.sorting_3,
        #metricsTable tbody>tr.selected>.sorting_4,
        #metricsTable tbody>tr.selected>.sorting_5,
        #metricsTable tbody>tr.selected>.sorting_6 {
            box-shadow: inset 0 0 0 9999px rgba(31, 31, 31, 0.9);
            /* Adjust the shadow effect */
        }

        /* Specific CSS for selected rows in the downregulated miRNA table */
        #metricsTable tbody tr.selected {
            background-color: rgb(31, 31, 31) !important;
            /* Set the background color to rgb(193, 74, 130) */
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* You can also add some extra styling for text or borders if desired */
        #metricsTable tbody tr.selected td {
            color: white !important;
            /* Optionally change text color */
            border: 1px solid rgb(31, 31, 31) !important;
            /* Optionally change border color */
            box-shadow: none !important;
            /* Remove blue box-shadow */
            background-color: rgb(31, 31, 31) !important;

        }

        /* If you want to change the highlight for odd/even rows, you can modify the existing styles */
        #metricsTable tbody>tr:nth-child(odd).selected {
            background-color: rgb(31, 31, 31) !important;
            box-shadow: none !important;
            /* Remove blue box-shadow */
        }

        /* Default violet styling for the highlighted checkboxes */
        .pretty.upHighlighted .state {
            border-color: #C14A82;
            /* Violet border */
            background-color: #C14A82;
            /* Violet background when checked */
            color: #fff;
            /* White text inside */
        }

        /* Ensure the state looks consistent when checked */
        .pretty.upHighlighted input[type="checkbox"]:checked+.state {
            border-color: #C14A82;
            background-color: #C14A82;
            color: #fff;
        }

        /* Default violet styling for the highlighted checkboxes */
        .pretty.downHighlighted .state {
            border-color: #1A74D5;
            /* Violet border */
            background-color: #1A74D5;
            /* Violet background when checked */
            color: #fff;
            /* White text inside */
        }

        /* Ensure the state looks consistent when checked */
        .pretty.downHighlighted input[type="checkbox"]:checked+.state {
            border-color: #1A74D5;
            background-color: #1A74D5;
            color: #fff;
        }

        /* Default violet styling for the highlighted checkboxes */
        .pretty.netHighlighted .state {
            border-color: var(--text-color) !important;
            /* Black border */
            background-color: var(--text-color) !important;
            /* Black background */
            color: #ffffff;
            /* White text */
        }

        /* Highlighted checkbox appearance when checked */
        .pretty.netHighlighted input[type="checkbox"]:checked+.state {
            border-color: var(--text-color) !important;
            background-color: var(--text-color) !important;
            color: #ffffff !important;
        }
    </style>
</head>

<body>
    <div id="overlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none; overflow-y: auto;">

        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 400px; text-align: center;">

            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">What would you like to do?</h2>

            <p style="margin-bottom: 30px; font-size: 16px; color: #555;">Choose one of the following options to
                proceed:</p>

            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="loadDatasetBtn"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Load
                    Dataset</button>
                <button id="tryExampleBtn"
                    style="padding: 10px 20px; background-color: #2196F3; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Try
                    Example</button>
            </div>
            <!-- Adjusted the help button styling and position -->
            <div style="margin-top: 20px;">
                <button id="helpBtn"
                    style="padding: 10px 20px; background-color: #FF9800; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Help</button>
            </div>
        </div>
    </div>

    <div id="helpOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none;overflow-y: auto;">

        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 500px; text-align: center;">

            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">Help - How to Use GEVIS</h2>

            <p style="margin-bottom: 30px; font-size: 16px; color: #555;">
                miRVAna allows you to conduct differential gene expression analysis through a user-friendly interface.
                Heres how to use the application:
            </p>

            <ul style="text-align: left; margin: 0 auto; padding: 0; max-width: 400px; font-size: 16px; color: #555;">
                <li><strong>Load Dataset:</strong> Upload your gene expression matrix and metadata files in CSV format,
                    or try the example dataset provided.</li>
                <li><strong>Select Analysis Type:</strong> Choose between statistical methods like t-test, Limma, or
                    DESeq2 for your analysis.</li>
                <li><strong>Interactive Visualization:</strong> Explore the results through various plots such as
                    scatterplots and volcano plots.</li>
                <li><strong>Enrichment & Survival Analysis:</strong> Utilize the built-in tools for enrichment and
                    survival analysis based on your results.</li>
                <li><strong>Export Results:</strong> Export your significant genes and analysis results for further
                    processing or reporting.</li>
            </ul>

            <p style="margin-top: 20px; font-size: 16px; color: #555;">
                For more information, visit the official <a href="https://github.com/francesco-fortunato/GEVIS"
                    target="_blank" style="color: #2196F3; text-decoration: none;">GitHub repository</a>.
            </p>

            <button id="closeHelpOverlayBtn"
                style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; margin-top: 20px;">Close</button>
        </div>
    </div>

    <div id="loadDatasetOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1001; display: none; overflow-y: auto;">

        <div id="containeDatasetOverlay"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 600px;">

            <h2 style="margin-bottom: 20px;">Load Raw RNA-Seq CSV Files</h2>
            <ul style="margin-bottom: 30px; font-size: 16px; color: #333;">
                <li>
                    <strong>File 1:</strong> Expression Data
                    <button class="tippyBtn"
                        data-tippy-content="This file should contain gene expression values for each sample, with genes as rows and samples as columns.<br><br><strong>Example:</strong><br><br>ID_REF,Sample 1,Sample 2,Sample 3<br>Gene A,230,300,240<br>Gene B,518,551,569"
                        style="background-color: transparent; border: none; cursor: pointer; margin-left: 5px;">
                        <span
                            style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background-color: #2196F3; color: white; text-align: center; line-height: 20px; font-weight: bold;">?</span>
                    </button>
                </li>
                <div style="margin-bottom: 20px;">
                    <input type="file" id="fileInput1" accept=".csv"
                        style="display: block; margin-bottom: 10px; width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                </div>
                <li>
                    <strong>File 2:</strong> Metadata
                    <button class="tippyBtn"
                        data-tippy-content="This file should contain sample information such as conditions, replicates, and other relevant metadata.<br><br><strong>Example:</strong><br><br>Metadata,Sample 1,Sample 2,Sample 3<br>Type,Cancer,Healthy,Cancer<br>Gender,Male,Female,Male"
                        style="background-color: transparent; border: none; cursor: pointer; margin-left: 5px;">
                        <span
                            style="display: inline-block; width: 20px; height: 20px; border-radius: 50%; background-color: #2196F3; color: white; text-align: center; line-height: 20px; font-weight: bold;">?</span>
                    </button>
                </li>
                <div>
                    <input type="file" id="fileInput2" accept=".csv"
                        style="display: block; width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">
                </div>

            </ul>

            <div id="notification" style="margin-top: 10px; font-size: 16px; text-align: center; color: #555;">
                Please upload two CSV files.
            </div>

            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="loadCsvBtn"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: not-allowed; opacity: 0.6;"
                    disabled>Load
                    Dataset</button>
                <button id="backBtn"
                    style="padding: 10px 20px; background-color: #F44336; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Back</button>
            </div>

        </div>
    </div>

    <!-- Try Example Overlay -->
    <div id="tryExampleOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1002; display: none; overflow-y: auto;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 600px; text-align: center;">
            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">Try Example Data</h2>
            <p style="margin-bottom: 30px; font-size: 16px; color: #555;">Select an example dataset to use:</p>

            <div style="text-align: left; margin-bottom: 30px;">
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example1" style="margin-right: 10px;">
                    <strong>Example 1:</strong> Gene expression signature of cigarette smoking and lung
                    adenocarcinoma development. Based on GEO Series GSE10072.
                </label>
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example2" style="margin-right: 10px;">
                    <strong>Example 2:</strong> Gene expression profiles of pre-treatment bone marrow aspirates from
                    multiple myeloma patients. This dataset includes attributes (event, time to follow-up) for
                    comprehensive survival analysis. Suggested differential expression analysis: [Subgrp7=HY] vs.
                    [Subgrp7=MS]. Based on GEO Series GSE4581.
                </label>
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example3" style="margin-right: 10px;">
                    <strong>Example 3:</strong> MicroRNA expression profiles in 63 patients with intrahepatic
                    cholangiocarcinoma (ICC) and 9 normal intrahepatic bile ducts. The study identified a miRNA
                    signature for predicting prognosis in ICC. Based on GEO Series GSE53870.
                </label>
                <label style="display: block; margin-bottom: 15px; font-size: 16px;">
                    <input type="radio" name="exampleOption" value="example4" style="margin-right: 10px;">
                    <strong>Example 4:</strong> Gene expression profiling of raw RNA-Seq data from airway smooth muscle
                    cells treated with dexamethasone, investigating transcriptomic changes. This dataset is suitable for
                    DESeq2 analysis. Based on GEO series GSE52778.
                </label>
            </div>

            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="chooseExampleBtn"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Choose
                    Example</button>
                <button id="closeExampleOverlayBtn"
                    style="padding: 10px 20px; background-color: #F44336; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">Back</button>
            </div>
        </div>
    </div>


    <div id="displayCsvOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1002; display: none; overflow-y: auto;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 90%; max-width: 1200px;">

            <h2 style="margin-bottom: 20px; font-size: 24px; color: #333; text-align: center;">CSV Data (First 5
                Columns)</h2>

            <div style="display: flex; gap: 20px; margin-bottom: 20px; overflow-x: auto;">
                <div style="flex: 1; min-width: 0; overflow-x: auto;">
                    <table id="csvTableData1" class="display"
                        style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                        <!-- Table content will be dynamically injected -->
                    </table>
                </div>
                <div style="flex: 1; min-width: 0; overflow-x: auto;">
                    <table id="csvTableData2" class="display"
                        style="width: 100%; border-collapse: collapse; border: 1px solid #ddd; border-radius: 4px; overflow: hidden;">
                        <!-- Table content will be dynamically injected -->
                    </table>
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                <p style="margin: 0; font-size: 16px; color: #555;">Total Columns File 1: <span
                        id="totalColumns1"></span></p>
                <p style="margin: 0; font-size: 16px; color: #555;">Total Columns File 2: <span
                        id="totalColumns2"></span></p>
            </div>

            <button id="quantileNormalizeBtn"
                style="display: block; margin: 20px auto; padding: 10px 20px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);">
                Perform Quantile Normalization
            </button>

            <button id="selectMetadataBtn"
                style="display: block; margin: 0 auto; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;">
                Continue</button>

            <!-- Message container -->
            <div id="messageContainer" style="margin-top: 20px; font-size: 16px; text-align: center;"></div>

        </div>
    </div>

    <div id="geneOverlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; overflow-y: auto;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 800px;">

            <!-- Tabs -->
            <div class="tab">
                <button class="tablinks active" id="diffExpressedTab">Differential Expressed Genes</button>
                <button class="tablinks" id="selectedGenesTab">Selected Genes</button>
                <button class="tablinks" id="selectedGSMTab">Selected GSM Genes</button>
            </div>

            <!-- Scrollable container for tables -->
            <div style="overflow-x: auto; max-width: 100%; margin-top: 20px;">
                <!-- Table for Differential Expressed Genes -->
                <div id="diffExpressedGenes" class="tabcontent" style="display: block;">
                    <h2 style="margin: 0 0 20px; text-align: center;">Differential Expressed Genes</h2>

                    <!-- Checkbox for PCA information -->
                    <!-- <div style="text-align: center; margin-bottom: 10px;">
                        <input type="checkbox" id="includePCA" />
                        <label for="includePCA" style="color: black;">Include PCA Information</label>
                    </div> -->

                    <table id="diffExpressedTable" class="display" style="width: 100%;"></table>
                </div>

                <!-- Table for Selected Genes -->
                <div id="selectedGenes" class="tabcontent" style="display: none;">
                    <h2 style="margin: 0 0 20px; text-align: center;">Selected Genes</h2>

                    <!-- Checkbox for PCA information -->
                    <!-- <div style="text-align: center; margin-bottom: 10px;">
                        <input type="checkbox" id="includePCA2" />
                        <label for="includePCA2" style="color: black;">Include PCA Information</label>
                    </div> -->

                    <table id="selectedGenesTable" class="display" style="width: 100%;"></table>
                </div>

                <!-- Table for Selected GSM Genes -->
                <div id="selectedGSM" class="tabcontent" style="display: none;">
                    <h2 style="margin: 0 0 20px; text-align: center;">Selected Samples with Selected Genes</h2>
                    <table id="selectedGSMTable" class="display" style="width: 100%;"></table>
                </div>
            </div>

            <!-- Buttons for download and close -->
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="confirmDownloadButton"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">Download
                    CSV</button>
                <button id="closeOverlayButton"
                    style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>

    <div id="survivalOverlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; overflow-y: auto;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 800px;">
            <span class="close1"
                style="position: absolute; top: 10px; right: 20px; font-size: 24px; font-weight: bold; cursor: pointer;">&times;</span>

            <h2 style="margin-bottom: 20px; text-align: center; color: #333;">Select Clinical Data for Survival
                Analysis
            </h2>

            <form id="dropdownForm" style="margin-bottom: 20px;">
                <!-- Dropdown options go here -->
            </form>

            <form id="dropdownForm1" style="margin-bottom: 20px;">
                <!-- Additional dropdown options go here -->
            </form>

            <button id="submission" type="button"
                style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;"
                disabled>Submit</button>

            <div id="survival" style="margin-top: 20px;">
                <!-- Survival analysis content goes here -->
            </div>
        </div>
    </div>


    <div id="heatmapOptionsOverlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; overflow-y: auto;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 80%; max-width: 800px;">
            <span class="close1" id="closeHeat"
                style="position: absolute; top: 10px; right: 20px; font-size: 24px; font-weight: bold; cursor: pointer;">&times;</span>

            <h2 style="margin-bottom: 20px; text-align: center; color: #333;">Select Clustering Options for Heatmap
            </h2>

            <form id="heatmapOptionsForm" style="margin-bottom: 20px;">
                <label for="clusteringDistance" style="display: block; margin-bottom: 10px;">Clustering
                    Distance:</label>
                <select id="clusteringDistance" name="clusteringDistanceRows"
                    style="width: 100%; padding: 10px; border-radius: 4px; border: 1px solid #ccc; margin-bottom: 20px; font-size: 14px;">
                    <option value="binary">Binary</option>
                    <option value="canberra">Canberra</option>
                    <option value="correlation" selected>Correlation</option>
                    <option value="euclidean">Euclidean</option>
                    <option value="maximum">Maximum</option>
                    <option value="manhattan">Manhattan</option>
                    <option value="minkowski">Minkowski</option>
                </select>
                <div id="distanceDescription" style="margin-bottom: 20px;">Description for selected distance metric.
                </div>

                <label for="clusteringMethod" style="display: block; margin-bottom: 10px;">Clustering Method:</label>
                <select id="clusteringMethod" name="clusteringMethod"
                    style="width: 100%; padding: 10px; border-radius: 4px; border: 1px solid #ccc; margin-bottom: 20px; font-size: 14px;">
                    <option value="average" selected>Average</option>
                    <option value="centroid">Centroid (UPGMC)</option>
                    <option value="complete">Complete</option>
                    <option value="mcquitty">McQuitty (WPGMA)</option>
                    <option value="median">Median (WPGMC)</option>
                    <option value="single">Single</option>
                    <option value="ward.D">Ward.D</option>
                    <option value="ward.D2">Ward.D2</option>
                </select>
                <div id="methodDescription" style="margin-bottom: 20px;">Description for selected clustering method.
                </div>

                <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                    <div>
                        <label for="clusterCols">Number of Column Clusters:</label>
                        <input type="number" id="clusterCols" name="clusterCols" min="1" value="2" style="width: 80px;">
                    </div>
                    <div>
                        <label for="clusterRows">Number of Row Clusters:</label>
                        <input type="number" id="clusterRows" name="clusterRows" min="1" value="2" style="width: 80px;">
                    </div>
                </div>

                <div style="display: flex; justify-content: center; gap: 20px; margin-top: 10px;">
                    <div>
                        <!-- Row Names Checkbox -->
                        <input type="checkbox" id="includeRowNames" name="includeRowNames" checked>
                        <label for="includeRowNames">Include Row Names</label>
                    </div>
                    <div>
                        <!-- Column Names Checkbox -->
                        <input type="checkbox" id="includeColNames" name="includeColNames" checked>
                        <label for="includeColNames">Include Column Names</label>
                    </div>
                </div>

                <div style="display: flex; justify-content: center; gap: 20px; margin-top: 10px;">
                    <div>
                        <input type="radio" id="useAllDegs" name="geneSelection" value="all" checked>
                        <label for="useAllDegs">Use All DEGs</label>
                    </div>
                    <div>
                        <input type="radio" id="useSelectedDegs" name="geneSelection" value="selected">
                        <label for="useSelectedDegs">Use Selected Genes</label>
                    </div>

                </div>


            </form>
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">

                <button id="heatmapSubmission" type="button"
                    style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Submit</button>
            </div>
        </div>
    </div>


    <div id="heatmapOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none; overflow-y: auto; user-select: none; pointer-events: auto;">

        <div id="heatmapContainer"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 50%; max-height: 100%; overflow: auto; text-align: center;">

            <h2 style="margin-bottom: 20px; font-size: 20px; color: #333;">Heatmap Visualization</h2>
            <div id="tooltipHeatmap"
                style="position: absolute; visibility: hidden; background: lightgray; border: 1px solid #ccc; padding: 5px; border-radius: 3px;">
            </div>

            <!-- This div will contain the heatmap SVG -->
            <div id="heatmapSvgContainer" style="width: 100%; height: 100%;">
                <!-- The SVG will be inserted here via JavaScript -->
            </div>

            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="downloadPngBtn"
                    style="padding: 10px 20px; background-color: #008CBA; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Download as PNG
                </button>
                <button id="closeHeatmapOverlayBtn"
                    style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
            </div>




        </div>
    </div>

    <div id="functionalAnalysisOverlay"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 50; display: none; overflow-y: auto;">

        <div id="functionalAnalysisContainer"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 30px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 50%; max-height: 100%; overflow: auto; text-align: center;">

            <!-- This div will contain the heatmap SVG -->
            <div id="functionalAnalysisSvgContainer" style="width: 100%; height: 100%;">
                <!-- The SVG will be inserted here via JavaScript -->
            </div>

            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <!-- <button id="downloadPngBtn"
                    style="padding: 10px 20px; background-color: #008CBA; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Download as PNG
                </button> -->
                <button id="closeFunctionalAnalysisOverlayBtn"
                    style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
            </div>

        </div>
    </div>

    <nav class="navbar navbar-expand-lg navbar-light bg-light" id="nav">
        <a class="navbar-brand" href="#" id="brandText" style="color:white; font-size: 1.5rem;">
            miRVAna
        </a>
        <button class="btn btn-secondary" id="importDatasetButton">Import Dataset</button>
        <span style="margin-left: 10px;"></span>
        <button class="btn btn-secondary" id="heatmapButton">Generate Heatmap</button>
        <span style="margin-left: 10px;"></span>
        <button class="btn btn-secondary" id="openModalBtn">Enrichment Analysis</button>
        <span style="margin-left: 10px;"></span>
        <button class="btn btn-secondary" id="openModalBtn1">Survival Analysis</button>
        <button class="btn btn-secondary" id="exportGenesButton" style="margin-left: 10px;">Export DEGs</button>
        <button class="btn btn-secondary" id="changeStyle" style="margin-left: 10px;"><i
                class="fa-solid fa-moon"></i></button>
    </nav>

    <div id="loadingOverlay" style="display: flex; justify-content: center; align-items: center;">
        <div
            style="display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%;">
            <span class="loader"></span>
            <span class="loading-text" style="margin-top: 1em; margin-left: 0.5em;">Loading <span
                    class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>
        </div>
    </div>

    <div id="main_div"> <!-- Main container for the overall layout -->
        <!-- Add this button for showing the panel again after collapse -->
        <button id="showLeftPanelBtn"
            style="display: none; position: relative; left: 0px; color: var(--text-color); border: none; cursor: pointer;">
            &#x2192 <!-- Left arrow symbol (can use icon as well) -->
        </button>

        <div class="flex-container" id="leftPanel"> <!-- Container for the IQR and FC sections arranged in a row -->
            <!-- Add this button inside the #leftPanel -->
            <button id="collapseButton">&#x2190;</button> <!-- Left arrow button to collapse -->

            <div id="style_scatter">

                <div
                    style="display: flex; flex: 0 0 6%; gap: 1em; justify-content: center; align-items: center; width: 100%;">
                    <span id="currentAnalysis"
                        style="font-weight: bold; color: var(--text-color); text-align: center;">Analysis
                        N/A</span>
                    <span id="currentMethod"
                        style="font-weight: bold; color: var(--text-color); text-align: center;">Method
                        N/A</span>
                    <span id="geneRegulationInfo"
                        style="font-weight: bold; color: var(--text-color); text-align: center;">Gene
                        Regulation
                        Info N/A</span>
                </div>


                <div id="counters" style="display: flex; justify-content: center; align-items: center; width: 100%;">
                    <div class="flex"
                        style="display: flex; justify-content: center; align-items: center; height: 100%; width: 100%;">
                        <div id="counter"
                            style="border: 0.01px solid #ddd; border-right: none; border-left: none; width: 65%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly; align-content: space-evenly;">
                        </div> <!-- Counter display -->
                        <div id="counter1"
                            style="border: 0.01px solid #ddd; border-right: none; width: 50%; height: 100%; box-sizing: border-box; text-align: left; justify-content: space-evenly; align-content: space-evenly;">
                        </div> <!-- Second counter display -->
                    </div>
                </div>


                <div class="svg-container" id="IQR"></div> <!-- SVG container for the IQR plot -->

                <div id="controlIQRThreshold" style="flex: 0 0 1%;"> <!-- Controls for IQR threshold -->
                    <input type="range" id="thresholdSlider" class="range2" min="0.1" max="0.99" step="0.01" value="0.3"
                        style="width: 200px;">
                    <span id="thresholdValue"
                        style="color: var(--text-color); vertical-align: middle; display: inline-block; margin-top: -24px;">30%</span>
                </div> <!-- End of IQR threshold controls -->

                <div class="svg-container" id="logFCHistogram"></div>
                <!-- SVG container for the log fold change histogram -->

                <div id="controlLogThreshold"
                    style="border-bottom: 1px solid #ddd; flex: 0 0 1%;  display: flex; align-items: center;">
                    <!-- Controls for log fold change threshold -->
                    <input type="range" id="log_thresholdSlider" class="range1" min="1.1" max="9.9" step="0.01"
                        value="2" style="width: 200px;">
                    <input type="text" id="log_thresholdSliderValue" value="2" readonly
                        style="width: 35px; color: var(--text-color); background-color: transparent; border: none; vertical-align: middle; display: inline-block; text-align: center; margin-top: -5px; margin-left: -5px;">

                    <button id="toggleHeatmapButton" class="btn btn-secondary"
                        style="margin-left:auto; margin-right:7px; display:none;">Save parameters</button>

                </div> <!-- End of log fold change threshold controls -->

                <div id="upregulatedtabletitle"
                    style="text-align: center; font-weight: bold; color: var(--text-color); margin-bottom: 10px;">
                    Up-regulated miRNAs
                </div>
                <div id="UpDiffTable" style="max-height: 20%; overflow-y: auto; overflow-x:hidden; width: 100%;">
                    <!-- Scrollable container for the up-regulated table -->
                    <table id="differentialUpExpressedTable" class="display"
                        style="width: 100%; height:auto; overflow-y: auto; overflow-x:hidden;"></table>
                </div>

                <div id="downregulatedtabletitle"
                    style="text-align: center; font-weight: bold; color: var(--text-color); margin-bottom: 10px;">
                    Down-regulated miRNAs
                </div>
                <div id="DownDiffTable" style="max-height: 20%; overflow-y: auto; overflow-x:hidden; width: 100%;">
                    <!-- Scrollable container for the down-regulated table -->
                    <table id="differentialDownExpressedTable" class="display"
                        style="width: 100%; height:auto; overflow-y: auto; overflow-x:hidden;"></table>
                </div> <!-- End of scrollable container for tables -->
            </div> <!-- End of style_scatter -->
        </div>

        <div class="flex-container" id="middleLeftPanel"> <!-- Container for scatter plot and Parallel Coordinates -->
            <div id="heatmapCon" class="svg-container " style="display:block;"></div>
        </div>

        <div class="flex-container" id="middleRightPanel"> <!-- Container for scatter plot and Parallel Coordinates -->

            <div id="controlPanel" style="flex: 0 0 4%; flex-wrap: wrap; ">
                <!-- Container for zoom, switch plot, p-value threshold, search, toggle brush -->
                <button id="resetButton" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:10px">
                    <i class="fas fa-sync-alt"></i> Reset Zoom
                </button>
                <button id="switchButton" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:15px">
                    <i class="fas fa-random"></i> Switch Plot
                </button>

                <label for="thresholdSelect">
                    <span
                        style="margin: 0; padding: 0; color: var(--text-color); margin-left:7px; margin-top: 10px; margin-bottom: 7px; display: inline-block;">
                        Set adj. p-value threshold:
                    </span>
                </label>

                <select id="thresholdSelect" class="btn btn-secondary dropdown-toggle"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:10px;">
                    <option value="0.05" selected>0.05</option>
                    <option value="0.01">0.01</option>
                </select>

                <div class="search-container">
                    <div id="searchInputContainer" style="position: relative;">
                        <input type="text" id="searchInput" class="form-control" placeholder="Search"
                            style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:15px">
                        <div id="searchResults" class="dropdown-content"
                            style="display: none; position: absolute; top: 100%; left: 0; right: 0; z-index: 1000000; background-color: white;">
                        </div>
                    </div>
                </div>

                <button id="deselectGenesButton" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:15px;">
                    <i class="fas fa-eraser"></i> Deselect Genes</button>

                <div style="margin-left:auto; margin-right:15px;">
                    <button id="toggleZoomButton" class="btn btn-secondary"
                        style="padding: 0.25rem 0.5rem; font-size: 0.80rem;">
                        <i class="fa fa-brush"></i> Toggle Zoom/Brush Mode </button>
                </div>

            </div> <!-- End of control panel -->
            <div id="scatterPlot" style="border-bottom: 1px solid #ddd;"></div> <!-- Placeholder for scatter plot -->

            <div class="svg-container" id="boxPlot"></div> <!-- SVG container for the box plot -->
        </div> <!-- End of second flex-container -->

        <div class="flex-container" id="rightPanel"> <!-- Container for PCA and heatmap -->
            <div id="controlnetwrokpca"
                style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom:5px;">
                <button id="getInteractions" onclick="miRNA_target()" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:15px; display: inline-block; width: 40%; flex-grow: 0;"
                    disabled>Get miRNA-mRNA interaction</button>
                <button id="switchNetPCA" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem; margin-left:15px; display: inline-block; width: 40%; flex-grow: 0;"
                    onclick="toggleView(data_copy, dataC_copy, dataN_copy)">Switch Network/PCA</button>
            </div>
            <!-- Network Graph Section -->
            <div id="networkSvgContainer" style="flex:  0 0 55%; border: 1px solid #ccc;">
                <!-- The SVG will be inserted here via JavaScript -->
            </div>

            <div id="filterOptions"
                style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 20px;">
                <!-- Dropdown for layout selection -->
                <label for="layoutSelector">Layout:</label>
                <select id="layoutSelector">
                    <option value="cose" selected>Cose</option>
                    <option value="grid">Grid</option>
                    <option value="circle">Circle</option>
                    <option value="concentric">Concentric</option>
                    <option value="random">Random</option>
                    <option value="breadthfirst">Breadthfirst</option>
                </select>

                <label>
                    <input type="radio" name="strength" value="strong_weak" style="margin-right: 5px;">
                    Strong and Weak
                </label>
                <label>
                    <input type="radio" name="strength" value="strong" style="margin-right: 5px;" checked>
                    Strong
                </label>
                <label>
                    <input type="radio" name="strength" value="weak" style="margin-right: 5px;">
                    Weak
                </label>
                <label for="minInteractions" style="margin-left: 20px;">Minimum Interactions:</label>
                <select id="minInteractions" style="margin-left: 5px;">
                    <option value="1" selected>1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                </select>

            </div>

            <div class="tabs-container">
                <!-- Tabs for switching between tables -->
                <div class="tabs">
                    <button class="tab-button" onclick="showTab('edgeListTableTab')">Edge List Table</button>
                    <button class="tab-button" onclick="showTab('metricsTableTab')">Metrics Table</button>
                    <button class="run-button" onclick="runFunctionalAnalysis()">Run Functional Analysis</button>

                </div>

                <!-- Content for Metrics Table -->
                <div id="metricsTableTab" class="tabcontent">
                    <div>
                        <table id="metricsTable" class="display" style="width: 100%;"></table>
                    </div>
                </div>

                <!-- Content for Edge List Table -->
                <div id="edgeListTableTab" class="tabcontent active ">
                    <div>
                        <table id="edgeListTable" class="display" style="width: 100%;"></table>
                    </div>
                </div>
            </div>

        </div> <!-- End of main flex-container -->

        <!-- PCA and Heatmap Content -->
        <div id="rightPanel2" class="flex-container" style="display: none;">
            <div id="buttonSwitchContainer"
                style="display: flex; justify-content: center; align-items: center; gap: 20px; margin-bottom: 10px;">
                <button id="switchToNetwork" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.80rem;"
                    onclick="toggleView(data_copy, dataC_copy, dataN_copy)">Switch
                    Network/PCA</button>
            </div>

            <div style="display: flex; flex: 0 0 4%;">
                <div id="checkboxContainer"
                    style="overflow-y:hidden; color: var(--text-color); margin-left: 0%; visibility: hidden; display: flex;">
                    <!-- Checkboxes will be dynamically added here -->
                </div>
                <div id="radioBoxContainer"
                    style="overflow-y:hidden; color: var(--text-color); width: 45%; margin-left: 10%; visibility: hidden; display: flex;">
                    <!-- Radio buttons will be dynamically added here -->
                </div>
            </div>

            <div style="height: 3%;">
                <div id="parallelLegend" class="svg-container" style="color: var(--text-color); height: 100%;"></div>
                <!-- SVG container for the parallel legend -->
            </div>
            <div id="parallel" style="flex: 0 0 20%;"></div> <!-- Placeholder for the parallel plot -->

            <div id="pca"></div> <!-- Placeholder for PCA plot -->

            <div style="display: flex; align-items: center;"> <!-- Container for axis selection -->
                <label for="x-axis-select" style="color: var(--text-color); margin-right: 10px;">Select X-axis:</label>
                <select id="x-axis-select" class="btn btn-secondary dropdown-toggle"
                    style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">
                    <option value="pc1">PC1</option>
                    <option value="pc2">PC2</option>
                    <option value="pc3">PC3</option>
                    <option value="pc4">PC4</option>
                    <option value="pc5">PC5</option>
                    <option value="pc6">PC6</option>
                </select>

                <label for="y-axis-select" style="color: var(--text-color); margin: 0 10px;">Select Y-axis:</label>
                <select id="y-axis-select" class="btn btn-secondary dropdown-toggle"
                    style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">
                    <option value="pc2">PC2</option>
                    <option value="pc1">PC1</option>
                    <option value="pc3">PC3</option>
                    <option value="pc4">PC4</option>
                    <option value="pc5">PC5</option>
                    <option value="pc6">PC6</option>
                </select>

                <button id="update-plot" class="btn btn-secondary"
                    style="padding: 0.25rem 0.5rem; font-size: 0.875rem; margin-left: 10px;">Update Plot</button>

                <div style="display: flex; align-items: center; margin-left: 20px;">
                    <!-- Controls for adjusting the placeholder value -->
                    <button id="decrease" class="btn btn-secondary"
                        style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">-</button>
                    <span id="value-placeholder" style="margin: 0 10px; color: var(--text-color);">6</span>
                    <!-- Placeholder value -->
                    <button id="increase" class="btn btn-secondary"
                        style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">+</button>
                </div>
            </div>

            <div id="heatmap"></div> <!-- Placeholder for the heatmap -->

        </div>

    </div> <!-- End of main_div -->

    <div id="d3tooltip">
        <p><span id="value"></p>
    </div>

    <div id="testTypeModal"
        style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1000; display: none; overflow-y: auto;">
        <div
            style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1009; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">
            <h3>Select Test Type</h3>
            <p>Do you want to perform a paired or unpaired test?</p>
            <div style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <button id="pairedTestBtn"
                    style="padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; cursor: pointer;">Paired</button>
                <button id="unpairedTestBtn"
                    style="padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; cursor: pointer;">Unpaired</button>
            </div>
        </div>
    </div>

    <script>

        try {
            ocpu.seturl("http://localhost:8004/ocpu/lib/GEVIS/R");
            //ocpu.seturl(window.location.origin + "/ocpu/lib/GEVIS/R");
        } catch (error) {
            console.log(error)
            // If an error occurs (e.g., ocpu is not defined), reload the page
            window.location.reload();
        }

        document.body.classList.toggle("light-theme");

        let chosen_statistic = ''

        let table1;
        let table2;
        let rowLabel
        let rTree
        let chosen_meta1
        let chosen_meta2
        let selectedRowName

        // This is for storing COLORS CHOSEN BY USER
        let colorScaleValues = {};
        let displayed_rows = 6;
        let case_number
        let normal_number
        let genes
        let variation_data;
        let variation_data_copy;
        let initial_num_genes;
        let data_upd
        let prc_IQR = 0.3;
        let thr_prc;
        let filteredData;

        let matrix;
        let data_original = [];
        let dataC_original = [];
        let dataN_original = [];
        let data_log
        let dataC_log
        let dataN_log
        let data_copy = [];
        let dataC_copy = [];
        let dataN_copy = [];
        let data_copy1 = [];
        let dataC_copy1 = [];
        let dataN_copy1 = [];
        let thr_fc = 2;
        let logFC_data;
        let log_thr_fc = Math.log2(thr_fc);
        let parsedLogFC;
        let parsedLogFC_origin;
        let parsedLogFC_origin1;
        let newdataJSON
        let newdataCJSON
        let first_filter_number_genes;
        let p_val_adj;
        let explainedVariance;
        let availablePCs
        let threshold = 0.05;
        let averageExpressions10C;
        let averageExpressions10N;
        let averageExpressionsC;
        let averageExpressionsN;
        let selectedGeneData = [];
        let greencircles = []
        let old_p_adj
        let transposedData = [];
        let ordering
        let metadata;
        let combinedData = []
        let combinedData1 = []
        let gsmList = []
        let data1;
        var json = []
        //info box plot
        let sumstat1
        var scatter;
        let sumstat
        var geneNameUP
        var geneNameDown
        let first_box = true
        /////////
        var currentCircleFill
        var first_dims = ['Age at Diagnosis']

        let example = false

        let meta_for_heatmap
        // Remove entries corresponding to ind from dataN
        let dataC_copy_pval

        // Remove entries corresponding to ind from dataN
        let dataN_copy_pval


        let data_copy_pval

        let deseq_p_adj = []

        // Remove entries corresponding to ind from logFC
        var parsedLogFC_pval
        var color_by = 'case'
        let pca_data = []
        let heatmap_data = []
        let square;

        let selectedVariable = "case"
        // Flag to track the current plot
        let currentPlot = 'volcano';

        let only_miRNAs = true;
        let zoomEnabled = true; // Flag to control zoom functionality

        let ridge = true

        let testType = 'unpaired' // Default test type

        let getInteractions = document.getElementById("getInteractions")
        let selectedmiRNAs = []
        // Get the button that opens the modal
        var btn = document.getElementById("openModalBtn");

        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];

        // Function to show the selected tab and hide the others
        function showTab(tabId) {
            const tabs = document.querySelectorAll('.tabcontent');
            tabs.forEach(tab => {
                tab.style.display = 'none';  // Hide all tabs
            });

            // Show the selected tab
            const selectedTab = document.getElementById(tabId);
            if (selectedTab) {
                selectedTab.style.display = 'flex';
            }
        }

        // const resizer = document.querySelector('.resizer');
        // const leftPanel = document.querySelector('#leftPanel');
        // const mainDiv = document.querySelector('#main_div'); // Container for the full layout

        // let isResizing = false;

        // // Mouse down event to start resizing
        // resizer.addEventListener('mousedown', (event) => {
        //     isResizing = true;
        //     document.body.style.cursor = 'ew-resize'; // Change cursor style
        //     event.preventDefault(); // Prevent selection while resizing
        // });

        // // Mouse move event to resize
        // window.addEventListener('mousemove', (event) => {
        //     if (!isResizing) return;

        //     // Calculate new width of the left panel
        //     const newWidth = event.clientX - mainDiv.getBoundingClientRect().left;

        //     // Set the new width with a minimum width
        //     if (newWidth > 100) {
        //         leftPanel.style.flex = `0 0 ${newWidth}px`;
        //     }
        // });

        // // Mouse up event to stop resizing
        // window.addEventListener('mouseup', () => {
        //     isResizing = false;
        //     document.body.style.cursor = ''; // Reset cursor style
        // });


        showOverlay()
        document.getElementById("toggleHeatmapButton").addEventListener("click", function () {
            const IQR = document.getElementById("IQR");
            const thresholdControls = document.getElementById("controlIQRThreshold");
            const logFCHistogram = document.getElementById("logFCHistogram");
            const logThresholdControls = document.getElementById("controlLogThreshold");
            const heatmapDiv = document.getElementById("heatmapCon");

            // Add fade-out class to elements to be hidden
            IQR.classList.add("fade-out");
            thresholdControls.classList.add("fade-out");
            logFCHistogram.classList.add("fade-out");
            logThresholdControls.classList.add("fade-out");

            // Method 1: Check for child nodes
            console.log(heatmapDiv.innerHTML.trim() === "")
            if (heatmapDiv.innerHTML.trim() === "") {
                dendo_heatmap()
            }

            // Wait for fade-out animation to complete before hiding them and showing the heatmap
            setTimeout(() => {
                IQR.style.display = "none";
                thresholdControls.style.display = "none";
                logFCHistogram.style.display = "none";
                logThresholdControls.style.display = "none";

                // Show the heatmap with fade-in effect
                heatmapDiv.classList.remove("hidden");
                heatmapDiv.classList.add("fade-in");
            }, 200); // Match this to the CSS transition time
        });

        // document.getElementById("networkButton").addEventListener("click", function () {
        //     document.getElementById("loadingOverlay").style.display = "block"
        //     miRNA_target();

        // });

        function applyThemeToSVG() {
            const axisColor = getComputedStyle(document.documentElement).getPropertyValue('--axis-color').trim();
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            console.log(getComputedStyle(document.documentElement).getPropertyValue('--background-color'))

            // Update axis paths
            const paths = document.querySelectorAll('path.domain');
            paths.forEach(path => {
                path.style.stroke = null; // Clear any inline style
                path.setAttribute('stroke', axisColor);
            });

            // Update all lines and text within SVG
            const lines = document.querySelectorAll('.tick line');
            lines.forEach(line => {
                line.style.stroke = null; // Clear any inline style
                line.setAttribute('stroke', axisColor);
            });

            // Ensure the threshold line remains dark red
            const thresholdLines = document.querySelectorAll('line[stroke="darkred"]');
            thresholdLines.forEach(line => {
                line.style.stroke = "darkred"; // Explicitly set stroke color for threshold lines
            });

            // Update all text elements within SVG
            const texts = document.querySelectorAll('text');
            texts.forEach(text => {
                text.style.fill = null; // Clear any inline style
                text.setAttribute('fill', textColor);
            });

            const labels = document.querySelectorAll('label');
            labels.forEach(label => {
                label.style.color = ""; // Clear any inline style
                label.style.color = textColor + " !important";
            });

            // // Update the stroke of the rect element in the legend
            // const rects = document.querySelectorAll('g.legend rect');
            // rects.forEach(rect => {
            //     if (document.body.classList.contains("light-theme")) {
            //         rect.setAttribute('stroke', "black"); // Set new stroke color for the rect
            //         console.log('New stroke after change:', rect.getAttribute('stroke')); // Debugging line
            //         rect.style.stroke = "black"; // Use inline style to ensure it takes precedence

            //     }
            //     else {
            //         rect.setAttribute('stroke', "white"); // Set new stroke color for the rect
            //         console.log('New stroke after change:', rect.getAttribute('stroke')); // Debugging line
            //         rect.style.stroke = "white"; // Use inline style to ensure it takes precedence
            //     }
            //     // Change color of the thresholdValue span and log_thresholdSliderValue input based on the theme
            //     const thresholdValue = document.getElementById("thresholdValue");
            //     const logThresholdSliderValue = document.getElementById("log_thresholdSliderValue");

            //     if (document.body.classList.contains("light-theme")) {
            //         // Set colors for light theme
            //         thresholdValue.style.color = "black"; // Change text color to black
            //         logThresholdSliderValue.style.color = "black"; // Change input text color to black
            //         logThresholdSliderValue.style.backgroundColor = "transparent"; // Keep input background transparent
            //     } else {
            //         // Set colors for dark theme
            //         thresholdValue.style.color = "white"; // Change text color to white
            //         logThresholdSliderValue.style.color = "white"; // Change input text color to white
            //         logThresholdSliderValue.style.backgroundColor = "transparent"; // Keep input background transparent
            //     }
            // });
        }

        // document.getElementById("selectButton").style.cursor = "not-allowed"
        // document.getElementById("selectButton").style.opacity = 0.6
        // document.getElementById("selectButton").disabled = true

        // d3.select("#switchBoxRidgeButton").on("click", function () {
        //     ridge = !ridge
        //     if (ridge) {
        //         document.getElementById("selectButton").style.cursor = "not-allowed"
        //         document.getElementById("selectButton").style.opacity = 0.6
        //         document.getElementById("selectButton").disabled = true
        //         updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //     } else {
        //         document.getElementById("selectButton").style.cursor = "pointer"
        //         document.getElementById("selectButton").style.opacity = 1
        //         document.getElementById("selectButton").disabled = false
        //         combinedData = []
        //         updateBoxPlot(document.getElementById("selectButton").value, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //     }
        // });


        document.getElementById("changeStyle").addEventListener("click", function () {
            document.body.classList.toggle("light-theme");
            applyThemeToSVG()
            // Get the icon element
            const icon = this.querySelector("i");

            // Check current icon and toggle it
            if (icon.classList.contains("fa-moon")) {
                icon.classList.remove("fa-moon");
                icon.classList.add("fa-sun");
            } else {
                icon.classList.remove("fa-sun");
                icon.classList.add("fa-moon");
            }

        });

        const collapseButton = document.getElementById('collapseButton');
        const expandButton = document.getElementById('showLeftPanelBtn');
        const leftPanel = document.getElementById('leftPanel');

        // Set a collapsed state flag
        let isCollapsed = false;

        // Add event listener for the collapse button
        collapseButton.addEventListener('click', () => {
            if (isCollapsed) {
                // Expand the panel
                leftPanel.style.display = 'flex';  // Make sure it's displayed as flex
                leftPanel.style.width = '25%';  // Expanded state
                leftPanel.style.visibility = 'visible';  // Ensure it's visible
                leftPanel.style.opacity = '1';  // Make it fully opaque
                collapseButton.innerHTML = '&#x2190;';  // Show left arrow
                expandButton.style.display = 'none';  // Hide the expand button when expanding
            } else {
                // Collapsing the panel
                leftPanel.style.width = '0%';  // Collapsed state
                leftPanel.style.opacity = '0';  // Make it fully transparent
                leftPanel.style.visibility = 'hidden';  // Hide visibility when collapsed

                // Wait for the transition to complete before hiding the panel completely
                setTimeout(() => {
                    leftPanel.style.display = 'none';  // Hide the panel completely
                    expandButton.style.display = 'block';  // Show the expand button
                }, 300);  // Wait 300ms, the duration of the transition
            }

            // Toggle the collapsed state
            isCollapsed = !isCollapsed;
        });

        // Add event listener for the expand button
        expandButton.addEventListener('click', () => {
            // Trigger expansion by simulating a click on the collapse button
            collapseButton.click();
        });

        // Function to display loading message inside the modal
        function showLoadingMessage() {
            var dotplotContainer = document.getElementById("dotplot");
            var dotplotContainer1 = document.getElementById("dotplot1");
            var slider = document.getElementById("slider_dot_polot");
            var selector = document.getElementById("select_dot");

            var slider1 = document.getElementById("slider_dot_polot1");
            var selector1 = document.getElementById("select_dot1");
            selector.innerHTML = "";
            slider.innerHTML = "";
            selector1.innerHTML = "";
            slider1.innerHTML = "";
            dotplotContainer1.innerHTML = "";
            dotplotContainer.innerHTML = "<h3 style='color: white'>Loading data from EnrichR.. </h3>";
        }

        function toggleView(data_copy, dataC_copy, dataN_copy) {
            const networkContainer = document.getElementById('rightPanel');
            const rightPanel = document.getElementById('rightPanel2');
            console.log(networkContainer.style.display)
            if (networkContainer.style.display == 'none') {
                networkContainer.style.display = 'flex'; // Show Network Analysis
                rightPanel.style.display = 'none'; // Hide PCA and Heatmap
            } else {
                networkContainer.style.display = 'none'; // Hide Network Analysis
                rightPanel.style.display = 'flex'; // Show PCA and Heatmap


                // Function to handle checkbox change event
                function handleCheckboxChange(event) {
                    var isChecked = event.target.checked;
                    var category = event.target.value;

                    if (isChecked) {
                        // Add category to first_dims array
                        first_dims.unshift(category);
                    } else {
                        // Remove category from first_dims array
                        var index = first_dims.indexOf(category);
                        if (index !== -1) {
                            first_dims.splice(index, 1);
                        }
                    }

                    // Log the updated first_dims array
                    console.log("Updated first_dims:", first_dims);

                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                }


                var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);

                // Get the container element
                var checkboxContainer = document.getElementById("checkboxContainer");

                // Initialize a variable to count the number of checkboxes added to the current row
                var checkboxesInRow = 0;

                // Iterate through metadataCategories to create checkboxes
                metadataCategories.forEach(function (category) {
                    // Create a checkbox element
                    var checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.value = category;
                    checkbox.id = "checkbox_" + category; // Set a unique ID for each checkbox

                    // Set the checked attribute based on condition
                    if (category === selectedRowName) {
                        checkbox.checked = true;
                    }

                    // Create a label for the checkbox
                    var label = document.createElement("label");
                    label.htmlFor = checkbox.id;
                    label.appendChild(document.createTextNode(category));

                    // Add event listener to the checkbox to handle change event
                    checkbox.addEventListener("change", handleCheckboxChange);

                    // Append the checkbox and label to the container element
                    checkboxContainer.appendChild(checkbox);
                    checkboxContainer.appendChild(label);

                    // Increment the count of checkboxes in the row
                    checkboxesInRow++;

                    // Add a line break after every two checkboxes
                    if (checkboxesInRow % 2 === 0) {
                        checkboxContainer.appendChild(document.createElement("br"));
                    }
                });

                // Initialize a variable to count the number of radio buttons added to the current row
                var radioButtonsInRow = 0;
                // Get the container element
                var radioBoxContainer = document.getElementById("radioBoxContainer");

                // Function to handle radio button change event
                function handleRadioButtonChange(event) {
                    // Update selectedVariable with the value of the selected radio button
                    selectedVariable = event.target.value;

                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);
                }


                // Iterate through metadataCategories to create radio buttons
                // Count the unique values in the metadata category
                function countUniqueValues(cat, j) {
                    var uniqueValues = new Set(); // Use a Set to store unique values
                    // Iterate through metadata categories to create y scales
                    metadataCategories.forEach((category, i) => {
                        if (j === i) {
                            var values = Object.values(metadata[i]); // Extract values for the current category
                            values.shift(); // Remove the first value (Sample_source_name_ch1)
                            var uniqueValues = [...new Set(values)]; // Filter out duplicate
                            console.log("Values for", category, ":", uniqueValues);
                            return uniqueValues.length; // Return the size of the Set, which is the count of unique values
                        }
                    });
                }

                // Iterate through metadataCategories to create radio buttons
                metadataCategories.forEach(function (category, i) {
                    // Check if the category has more than 9 unique values
                    var values = Object.values(metadata[i]); // Extract values for the current category
                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                    var uniqueValues = [...new Set(values)]; // Filter out duplicate
                    console.log("Values for", category, ":", uniqueValues);
                    console.log(uniqueValues.length);
                    if (uniqueValues.length >= 9) return

                    // Create a radio button element
                    var radioButton = document.createElement("input");
                    radioButton.type = "radio";
                    radioButton.name = "radioButtonGroup"; // Set the same name for all radio buttons in the group
                    radioButton.value = category;
                    radioButton.id = "radioButton_" + category; // Set a unique ID for each radio button

                    // Set the checked attribute based on condition
                    if (category === selectedRowName) {
                        radioButton.checked = true;
                    }

                    // Create a label for the radio button
                    var label = document.createElement("label");
                    label.htmlFor = radioButton.id;
                    label.appendChild(document.createTextNode(category));

                    // Add event listener to the radio button to handle change event
                    radioButton.addEventListener("change", handleRadioButtonChange);

                    // Append the radio button and label to the container element
                    radioBoxContainer.appendChild(radioButton);
                    radioBoxContainer.appendChild(label);

                    // Increment the count of radio buttons in the row
                    radioButtonsInRow++;

                    // Add a line break after every two radio buttons
                    if (radioButtonsInRow % 2 === 0) {
                        radioBoxContainer.appendChild(document.createElement("br"));
                    }
                });

                document.getElementById("checkboxContainer").style.visibility = "visible";
                document.getElementById("radioBoxContainer").style.visibility = "visible";

            }

            var pc1Values = [];
            var pc2Values = [];
            var groupValues = [];
            if (data_copy_pval === undefined) {
                alert("No deg found!")
            }
            console.log(data_copy_pval)
            console.log(dataC_copy_pval)
            console.log(dataN_copy_pval)
            const geneNames = data_copy_pval.map(entry => entry.gene);
            const uniqueGeneNames = new Set(geneNames);

            if (geneNames.length !== uniqueGeneNames.size) {
                console.error("Duplicate gene names detected in the input data.");
            }
            console.log(data_copy_pval)

            // downloadDataAsTxt(data_copy_pval, 'filtered_data.txt');

            dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy1, dataN_copy1, [selectedRowName])

            var req = ocpu.call("pca", {
                data: data_copy_pval,
                dataN: dataN_copy_pval,
                dataC: dataC_copy_pval
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";
                console.log(session);
                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => response.json())
                    .then(data => {
                        json = data
                        console.log(filteredDataURL)
                        console.log(json)

                        var pc1Key = "PC1";
                        var pc2Key = "PC2";
                        var groupKey = "Group";

                        // Arrays to store PC1 and PC2 values


                        // Iterate over each object in the JSON array
                        json.scores_df.forEach(function (obj) {
                            // Push PC1, PC2, and Group values to the arrays
                            pc1Values.push(obj[pc1Key]);
                            pc2Values.push(obj[pc2Key]);
                            groupValues.push(obj[groupKey]);
                        });
                        // console.log(pc1Values)

                        // Extract metadata categories from the values of the first column
                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                        console.log("Metadata categories:", metadataCategories);

                        explainedVariance = json.explained_variance; // Access explained variance
                        console.log("Explained variance", explainedVariance)

                        // Initialize pca_data array
                        pca_data = [];

                        // Iterate over each object in the JSON array
                        json.scores_df.forEach(function (obj) {
                            // Retrieve additional data from metadata based on _row
                            var gsm = obj._row;
                            var group = obj.Group;
                            // Create an object with the required fields
                            var newObj = {
                                GSM: gsm,
                                group: group,
                            };

                            // Check for the existence of each principal component before adding to newObj
                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                            // Add metadata values for each category to the newObj
                            metadataCategories.forEach((category, index) => {
                                newObj[category] = metadata[index][gsm];
                            });

                            // Push the new object to the pca_data array
                            pca_data.push(newObj);
                        });

                        heatmap_data = []
                        json.scores_var.forEach(function (obj) {
                            // Push PC1, PC2, and Group values to the arrays
                            var gene = obj._row

                            var newObj = {
                                gene: gene,
                            };
                            // Check for the existence of each principal component before adding to newObj
                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                            heatmap_data.push(newObj);
                        })

                        // Assuming you want to work with the first object in the array
                        let obj = json.scores_df[0]; // Get the first object

                        // Initialize an array to hold available principal components
                        availablePCs = [];

                        // Check for the existence of each principal component
                        if (obj.PC1 !== undefined) availablePCs.push('pc1');
                        if (obj.PC2 !== undefined) availablePCs.push('pc2');
                        if (obj.PC3 !== undefined) availablePCs.push('pc3');
                        if (obj.PC4 !== undefined) availablePCs.push('pc4');
                        if (obj.PC5 !== undefined) availablePCs.push('pc5');
                        if (obj.PC6 !== undefined) availablePCs.push('pc6');

                        // Function to update the dropdowns based on available PCs
                        function updateDropdowns() {
                            const xAxisSelect = document.getElementById("x-axis-select");
                            const yAxisSelect = document.getElementById("y-axis-select");

                            // Clear existing options
                            xAxisSelect.innerHTML = '';
                            yAxisSelect.innerHTML = '';

                            // Add available options to the X-axis dropdown
                            availablePCs.forEach(function (pc) {
                                const option = document.createElement("option");
                                option.value = pc;
                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                xAxisSelect.appendChild(option);
                            });

                            // Add available options to the Y-axis dropdown
                            availablePCs.forEach(function (pc) {
                                const option = document.createElement("option");
                                option.value = pc;
                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                yAxisSelect.appendChild(option);
                            });

                            // Set the default selected value for the Y-axis to PC2, if available
                            if (availablePCs.includes("pc2")) {
                                yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                            }

                        }

                        // Call the function to update dropdowns
                        updateDropdowns();

                        // Display the newData array
                        console.log("PCA, first try ", pca_data);
                        if (obj.PC2 !== undefined) {
                            pca(pca_data);
                        } else {
                            document.getElementById("loadingOverlay").style.display = "none";
                            document.getElementById("pca").innerText = "PCA not computed since only one gene was found.";
                            document.getElementById("pca").style.color = "white";
                            document.getElementById("pca").style.justifyContent = "center";
                            document.getElementById("pca").style.alignItems = "center"
                        }
                        displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                        document.getElementById("value-placeholder").textContent = displayed_rows;
                        if (obj.PC2 !== undefined) heatmap(heatmap_data);
                    })





            })
        }

        function updatePCAandPC() {
            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering);

            var pc1Values = [];
            var pc2Values = [];
            var groupValues = [];
            console.log("PCA DATA COPY PVAL:", data_copy_pval)
            // downloadDataAsTxt(data_copy_pval, 'filtered_data.txt');

            var req = ocpu.call("pca", {
                data: data_copy_pval,
                dataN: dataN_copy_pval,
                dataC: dataC_copy_pval
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";
                //console.log(session);
                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => response.json())
                    .then(data => {
                        json = data
                        console.log(filteredDataURL)
                        console.log(json)

                        var pc1Key = "PC1";
                        var pc2Key = "PC2";
                        var groupKey = "Group";

                        // Iterate over each object in the JSON array
                        json.scores_df.forEach(function (obj) {
                            // Push PC1, PC2, and Group values to the arrays
                            pc1Values.push(obj[pc1Key]);
                            pc2Values.push(obj[pc2Key]);
                            groupValues.push(obj[groupKey]);
                        });
                        // console.log(pc1Values)

                        // Extract metadata categories from the values of the first column
                        var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
                        console.log("Metadata categories:", metadataCategories);

                        explainedVariance = json.explained_variance; // Access explained variance
                        console.log("Explained variance", explainedVariance)

                        // Initialize pca_data array
                        pca_data = [];

                        // Iterate over each object in the JSON array
                        json.scores_df.forEach(function (obj) {
                            // Retrieve additional data from metadata based on _row
                            var gsm = obj._row;
                            var group = obj.Group;
                            // Create an object with the required fields
                            var newObj = {
                                GSM: gsm,
                                group: group,
                            };

                            // Check for the existence of each principal component before adding to newObj
                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                            // Add metadata values for each category to the newObj
                            metadataCategories.forEach((category, index) => {
                                newObj[category] = metadata[index][gsm];
                            });

                            // Push the new object to the pca_data array
                            pca_data.push(newObj);
                        });

                        heatmap_data = []
                        json.scores_var.forEach(function (obj) {
                            // Push PC1, PC2, and Group values to the arrays
                            var gene = obj._row

                            var newObj = {
                                gene: gene,
                            };
                            // Check for the existence of each principal component before adding to newObj
                            if (obj.PC1 !== undefined) newObj.pc1 = obj.PC1;
                            if (obj.PC2 !== undefined) newObj.pc2 = obj.PC2;
                            if (obj.PC3 !== undefined) newObj.pc3 = obj.PC3;
                            if (obj.PC4 !== undefined) newObj.pc4 = obj.PC4;
                            if (obj.PC5 !== undefined) newObj.pc5 = obj.PC5;
                            if (obj.PC6 !== undefined) newObj.pc6 = obj.PC6;

                            heatmap_data.push(newObj);
                        })

                        // Assuming you want to work with the first object in the array
                        let obj = json.scores_df[0]; // Get the first object

                        // Initialize an array to hold available principal components
                        availablePCs = [];

                        // Check for the existence of each principal component
                        if (obj.PC1 !== undefined) availablePCs.push('pc1');
                        if (obj.PC2 !== undefined) availablePCs.push('pc2');
                        if (obj.PC3 !== undefined) availablePCs.push('pc3');
                        if (obj.PC4 !== undefined) availablePCs.push('pc4');
                        if (obj.PC5 !== undefined) availablePCs.push('pc5');
                        if (obj.PC6 !== undefined) availablePCs.push('pc6');

                        // Function to update the dropdowns based on available PCs
                        function updateDropdowns() {
                            const xAxisSelect = document.getElementById("x-axis-select");
                            const yAxisSelect = document.getElementById("y-axis-select");

                            // Clear existing options
                            xAxisSelect.innerHTML = '';
                            yAxisSelect.innerHTML = '';

                            // Add available options to the X-axis dropdown
                            availablePCs.forEach(function (pc) {
                                const option = document.createElement("option");
                                option.value = pc;
                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                xAxisSelect.appendChild(option);
                            });

                            // Add available options to the Y-axis dropdown
                            availablePCs.forEach(function (pc) {
                                const option = document.createElement("option");
                                option.value = pc;
                                option.textContent = pc.toUpperCase(); // Set text to uppercase
                                yAxisSelect.appendChild(option);
                            });

                            // Set the default selected value for the Y-axis to PC2, if available
                            if (availablePCs.includes("pc2")) {
                                yAxisSelect.value = "pc2"; // Set PC2 as the selected value
                            }

                        }

                        // Call the function to update dropdowns
                        updateDropdowns();

                        // Display the newData array
                        console.log("PCA, first try ", pca_data);
                        if (obj.PC2 !== undefined) {
                            pca(pca_data);
                        } else {
                            document.getElementById("loadingOverlay").style.display = "none";
                            document.getElementById("pca").innerText = "PCA not computed since only one gene was found.";
                            document.getElementById("pca").style.color = "white";
                            document.getElementById("pca").style.justifyContent = "center";
                            document.getElementById("pca").style.alignItems = "center"
                        };
                        displayed_rows = Math.min(displayed_rows, heatmap_data.length);
                        document.getElementById("value-placeholder").textContent = displayed_rows;
                        if (obj.PC2 !== undefined) heatmap(heatmap_data);
                    })
            })

        }

        // Function to create the dot plot inside the modal
        function createDotPlotInsideModal() {
            // Display loading message inside the modal
            showLoadingMessage();

            // Call your function to create the dot plot here
            DEG(data_copy_pval, parsedLogFC_pval, old_p_adj);
        }


        document.getElementById("openModalBtn").addEventListener("click", function () {
            const data = { data_copy_pval, parsedLogFC_pval, old_p_adj }; // Assuming you have these arrays defined elsewhere

            // Send data to server using fetch
            fetch('/enrichment', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: data })
            })
                .then(response => response.json())
                .then(response => {
                    // Redirect to /enrichment with unique identifier (sessionId)
                    window.open(`/enrichment?sessionId=${response.sessionId}`, '_blank');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to store enrichment data');
                });
        });


        ///////////////////////////////////////////////////////////////////////////////////////////

        // Get the modal element
        var modal1 = document.getElementById("survivalOverlay");

        // Get the button that opens the modal
        var btn1 = document.getElementById("openModalBtn1");

        // Get the button that opens the modal
        var btn2 = document.getElementById("submission");

        // Get the <span> element that closes the modal
        var span1 = document.getElementsByClassName("close1")[0];

        let second_time = false;

        // Function to display loading message inside the modal
        function showLoadingMessageSurv() {
            var survivalContainer = document.getElementById("survival");
            console.log(selectedGeneData)
        }

        // Function to create the dot plot inside the modal
        function createSurvivalPlotInsideModal() {
            // Display loading message inside the modal
            showLoadingMessageSurv();
        }


        document.getElementById("openModalBtn1").addEventListener("click", function () {
            modal1.style.display = "block";

            console.log(metadata);

            // Clear previous form contents
            const form = document.getElementById("dropdownForm");
            const form1 = document.getElementById("dropdownForm1");
            form.innerHTML = '';
            form1.innerHTML = '';

            // First dropdown label and menu
            const label = document.createElement('label');
            label.textContent = "Select the Event: Event Status: Death (0 = Alive, 1 = Deceased) ";
            label.style.display = 'block';
            label.style.color = '#333';  // Use a more subtle color than black
            label.style.marginBottom = '8px';  // Add spacing between the label and dropdown
            label.style.fontSize = '16px';  // Increase font size for better readability
            label.setAttribute('for', 'metadataDropdown1');
            form.appendChild(label);

            const select = document.createElement('select');
            select.id = 'metadataDropdown1';
            select.name = 'metadataSelection1';
            select.style.width = '100%';  // Make the dropdown take up the full width
            select.style.padding = '10px';  // Add padding for better appearance
            select.style.borderRadius = '4px';  // Rounded corners
            select.style.border = '1px solid #ccc';  // Light gray border
            select.style.marginBottom = '20px';  // Add space between this dropdown and the next element
            select.style.fontSize = '14px';  // Improve font size

            metadata.forEach((item) => {
                const option = document.createElement('option');
                option.value = item.Sample_geo_accession;
                option.textContent = item.Sample_geo_accession;
                select.appendChild(option);
            });

            form.appendChild(select);

            // Second dropdown label and menu
            const label1 = document.createElement('label');
            label1.textContent = "Select Time to Follow Up: (days)";
            label1.style.display = 'block';
            label1.style.color = '#333';
            label1.style.marginBottom = '8px';
            label1.style.fontSize = '16px';
            label1.setAttribute('for', 'metadataDropdown2');
            form1.appendChild(label1);

            const select1 = document.createElement('select');
            select1.id = 'metadataDropdown2';
            select1.name = 'metadataSelection2';
            select1.style.width = '100%';
            select1.style.padding = '10px';
            select1.style.borderRadius = '4px';
            select1.style.border = '1px solid #ccc';
            select1.style.marginBottom = '20px';
            select1.style.fontSize = '14px';

            metadata.forEach((item) => {
                const option = document.createElement('option');
                option.value = item.Sample_geo_accession;
                option.textContent = item.Sample_geo_accession;
                select1.appendChild(option);
            });

            form1.appendChild(select1);

            btn2.addEventListener('click', filterMetadata);
        });

        function filterMetadata() {
            const selectedEvent = document.getElementById('metadataDropdown1').value;
            const selectedTime = document.getElementById('metadataDropdown2').value;

            console.log("Metadata", metadata)

            // Filter the metadata based on the selections
            const filteredMetadata = metadata.filter(item => {
                // Get the first key dynamically
                const firstKey = Object.keys(item)[0];

                // Check if the first key's value matches the selected event or time
                return item[firstKey] === selectedEvent || item[firstKey] === selectedTime;
            });


            console.log('Filtered Metadata:', filteredMetadata);

            // Function to clean filteredMetadata by removing keys with empty values
            const cleanFilteredMetadata = (filteredMetadata) => {
                return filteredMetadata.map(item => {
                    // Create a new object to store cleaned entries
                    const cleanedItem = {};

                    for (const [key, value] of Object.entries(item)) {
                        // Check if the value is a valid number (float or integer) or not an empty string
                        const numValue = parseFloat(value); // Convert to float

                        if (value !== "" && !isNaN(numValue)) {
                            cleanedItem[key] = value;
                        }
                    }

                    return cleanedItem;
                });
            };


            // Clean the filteredMetadata
            const cleanedMetadata = cleanFilteredMetadata(filteredMetadata);

            // Log the result
            console.log(cleanedMetadata);

            // Extract gene names from dataC_copy_pval
            const geneNamesInDataC = dataC_copy_pval.map(item => item.gene);

            // Filter old_p_adj to only include genes present in dataC_copy_pval
            const filteredOldPAdj = old_p_adj.filter(item => geneNamesInDataC.includes(item.Gene));

            console.log('Filtered Old P Adj:', filteredOldPAdj);

            // Now you can send only the filtered data
            const data = { filteredMetadata: cleanedMetadata, dataC_copy_pval, old_p_adj: filteredOldPAdj };

            // Send data to server using fetch
            fetch('/survival', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ data: data })
            })
                .then(response => response.json())
                .then(response => {
                    // Redirect to /enrichment with unique identifier (sessionId)
                    window.open(`/survival?sessionId=${response.sessionId}`, '_blank');
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Failed to store survival data');
                });

            // You can further process or display the filteredMetadata here
        }

        //When the user clicks the button, open the modal and create the dot plot inside it
        btn1.onclick = function () {
            modal1.style.display = "block";
            // Display loading message inside the modal
            showLoadingMessageSurv();
            // Call function to create dot plot inside modal
            createSurvivalPlotInsideModal();
            btn2.disabled = false
        }

        // When the user clicks on <span> (x), close the modal
        span1.onclick = function () {
            modal1.style.display = "none";
            // Clear the content of the modal when it is closed
            var survivalContainer = document.getElementById("survival");
            survivalContainer.innerHTML = "";
        }

        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function (event) {
            if (event.target == modal1) {
                modal1.style.display = "none";
                // Clear the content of the modal when it is closed
                var survivalContainer = document.getElementById("survival");
                survivalContainer.innerHTML = "";
            }
        }

        let interval; // Variable to hold the interval ID

        // Function to increase the number of displayed rows
        function increaseRows() {
            if (displayed_rows < heatmap_data.length) {
                if (displayed_rows < 10 && displayed_rows >= 6) {
                    displayed_rows = 10; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                } else if (displayed_rows < 10 && displayed_rows < 6) {
                    displayed_rows++; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
                else if (displayed_rows >= 10) {
                    displayed_rows += 5; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
            }
        }

        // Function to decrease the number of displayed rows
        function decreaseRows() {
            if (displayed_rows > 2) {
                if (displayed_rows < 10 && displayed_rows >= 6) {
                    displayed_rows--; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                } else if (displayed_rows < 10 && displayed_rows <= 6) {
                    displayed_rows--; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
                else if (displayed_rows >= 10) {
                    displayed_rows -= 5; // Increase the index
                    document.getElementById("value-placeholder").textContent = displayed_rows;
                    heatmap(heatmap_data); // Re-render the heatmap with the new gene added
                }
            }
        }

        // Add event listener for the "+" button to increase rows
        document.getElementById("increase").addEventListener("mousedown", function () {
            increaseRows(); // Call the increase function once
            interval = setInterval(increaseRows, 500); // Set interval to continuously increase
        });

        document.getElementById("increase").addEventListener("mouseup", function () {
            clearInterval(interval); // Clear the interval when the mouse is released
        });

        document.getElementById("increase").addEventListener("mouseleave", function () {
            clearInterval(interval); // Clear the interval if the mouse leaves the button
        });

        // Add event listener for the "-" button to decrease rows
        document.getElementById("decrease").addEventListener("mousedown", function () {
            decreaseRows(); // Call the decrease function once
            interval = setInterval(decreaseRows, 500); // Set interval to continuously decrease
        });

        document.getElementById("decrease").addEventListener("mouseup", function () {
            clearInterval(interval); // Clear the interval when the mouse is released
        });

        document.getElementById("decrease").addEventListener("mouseleave", function () {
            clearInterval(interval); // Clear the interval if the mouse leaves the button
        });



        ///////////////////////////////////////////////////////////////////////////////////////////

        // function calculateLogFC(dataC, dataN) {
        //     const logFCData = [];

        //     // Iterate over each gene
        //     Object.keys(dataC).forEach(gene => {
        //         // Get the values for the current gene from dataC and dataN
        //         let valuesC = Object.values(dataC[gene]);
        //         let valuesN = Object.values(dataN[gene]);

        //         // Pop the last value if it's a gene string
        //         let geneValueC;
        //         if (isNaN(valuesC[valuesC.length - 1])) {
        //             geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
        //         }
        //         let geneValueN;
        //         if (isNaN(valuesN[valuesN.length - 1])) {
        //             geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
        //         }

        //         // Calculate the row mean for dataC and dataN
        //         const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
        //         const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

        //         // Calculate the log fold change
        //         const logFC = rowMeanC - rowMeanN;

        //         // Push the gene and its logFC to logFCData
        //         logFCData.push({ "Gene": geneValueC, "logFC": logFC });
        //     });

        //     return logFCData

        // }

        function calculateLogFC(dataC, dataN) {
            const logFCData = [];

            // Iterate over each gene
            Object.keys(dataC).forEach(gene => {
                // Get the values for the current gene from dataC and dataN
                let valuesC = Object.values(dataC[gene]);
                let valuesN = Object.values(dataN[gene]);

                // Pop the last value if it's a gene string (assuming it's not numerical)
                let geneValueC;
                if (isNaN(valuesC[valuesC.length - 1])) {
                    geneValueC = valuesC.pop(); // Remove and store the last value as the gene for dataC
                }
                let geneValueN;
                if (isNaN(valuesN[valuesN.length - 1])) {
                    geneValueN = valuesN.pop(); // Remove and store the last value as the gene for dataN
                }

                // Calculate the row mean (average) for each condition
                const rowMeanC = valuesC.reduce((acc, val) => acc + val, 0) / valuesC.length;
                const rowMeanN = valuesN.reduce((acc, val) => acc + val, 0) / valuesN.length;

                // Calculate log fold change (logFC)
                const logFC = rowMeanC - rowMeanN;

                // Calculate average expression (A-value)
                const avgExpression = (rowMeanC + rowMeanN) / 2;

                // Push the gene, logFC, and A-value to logFCData
                logFCData.push({ "Gene": geneValueC, "logFC": logFC, "A": avgExpression });
            });

            return logFCData;
        }


        function fetchJSON(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    // Rename the key '_row' to 'Gene' in each object of the JSON array
                    return data.map(obj => {
                        const newObj = { ...obj };
                        newObj['gene'] = newObj['_row'];
                        delete newObj['_row']; // Delete the old key
                        return newObj;
                    });
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        function fetchMeta(url) {
            return fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching JSON:', error);
                });
        }

        // Define a function to fetch data from a file with no header
        function fetchData(filename) {
            return fetch(filename)
                .then(response => response.text())
                .then(text => {
                    // Parse the data
                    const rows = text.trim().split('\n');

                    // Extract sample GSM identifiers from the first row (excluding the first element)
                    const sampleGSMs = rows[0].trim().split('\t').slice(1);

                    // Map each row to an object representing gene expression for each sample
                    matrix = rows.slice(1).map(row => {
                        const [gene, ...expressions] = row.trim().split('\t');

                        // Create an object with gene code as the key and an object with sample GSMs and expressions as the value
                        return {
                            gene: gene,
                            expressions: expressions.map(parseFloat)
                        };
                    });

                    // Create a matrix with GSMs as headers
                    const matrixWithHeaders = matrix.reduce((result, entry) => {
                        const geneObj = {
                            Gene: entry.gene, // Optional: Change the key to "Gene" if needed
                            ...Object.fromEntries(sampleGSMs.map((gsm, index) => [gsm, entry.expressions[index]]))
                        };
                        result.push(geneObj);
                        return result;
                    }, []);
                    return matrixWithHeaders; // Return the matrix with headers
                });
        }

        var width = 100,
            height = 100,
            n = 18,
            r = 5,
             = Math.PI,
            p = 1000;
        const margin = { top: 10, right: 20, bottom: 30, left: 130 };

        // var svg = d3.select("#scatterPlot").append("svg")
        //     .attr("width", width)
        //     .attr("height", height)
        //     .style("background", "none")
        //     .attr("transform", `translate(${margin.left},${margin.top})`);

        // var gScatter = svg.selectAll("g")
        //     .data(d3.range(0, 2 * , 2 *  / n))
        //     .enter().append("g")
        //     .attr("transform", function (d) {
        //         var x = width * (0.35 * Math.cos(d) + 0.5),
        //             y = height * (0.35 * Math.sin(d) + 0.5);
        //         return "translate(" + [x, y] + ")rotate(" + d * 180 /  + ")";
        //     });
        // var moonsScatter = gScatter.append("path")
        //     .attr("fill", "#808080");
        // d3.timer(function (t) {
        //     var  = 2 *  * (t % p / p);
        //     moonsScatter.attr("d", function (d) { return moon(( + d) % (2 * )); });
        // });

        // const margin1 = { top: 10, right: 20, bottom: 30, left: 5 };
        // var svg1 = d3.select("#boxPlot").append("svg")
        //     .attr("width", width)
        //     .attr("height", height)
        //     .style("background", "none")
        //     .attr("transform", `translate(${margin1.left},${margin1.top})`);

        // var gBoxPlot = svg1.selectAll("g")
        //     .data(d3.range(0, 2 * , 2 *  / n))
        //     .enter().append("g")
        //     .attr("transform", function (d) {
        //         var x = width * (0.35 * Math.cos(d) + 0.5),
        //             y = height * (0.35 * Math.sin(d) + 0.5);
        //         return "translate(" + [x, y] + ")rotate(" + d * 180 /  + ")";
        //     });
        // var moonsBoxPlot = gBoxPlot.append("path")
        //     .attr("fill", "#808080");
        // d3.timer(function (t) {
        //     var  = 2 *  * (t % p / p);
        //     moonsBoxPlot.attr("d", function (d) { return moon(( + d) % (2 * )); });
        // });

        // function moon() {
        //     var rx0 =  <  ? r : -r,
        //         s0 =  <  ? 0 : 1,
        //         rx1 = r * Math.cos(),
        //         s1 =  <  / 2 || ( <=  &&  < 3 *  / 2) ? 0 : 1;
        //     return "M" + [0, r] +
        //         "A" + [rx0, r, 0, 0, s0, 0, -r] +
        //         "A" + [rx1, r, 0, 0, s1, 0, r];
        // }

        document.getElementById("loadingOverlay").style.display = "none";

        document.getElementById("loadDatasetBtn").addEventListener("click", function () {
            hideOverlay();
            // Add your code to load the dataset here
        });


        // Function to show the overlay and modal
        function showOverlay() {
            document.getElementById("overlay").style.display = "block";
        }

        // Function to hide the overlay and modal
        function hideOverlay() {
            document.getElementById("overlay").style.display = "none";
        }

        // Function to show the CSV file loading overlay
        function showLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "block";
        }

        // Function to hide the CSV file loading overlay
        function hideLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "none";
        }

        // Event listener for the "Back" button
        document.getElementById('backBtn').addEventListener('click', () => {
            hideLoadCsvOverlay()
            showOverlay()
        });

        // Event listener for the "Back" button
        document.getElementById('closeExampleOverlayBtn').addEventListener('click', () => {
            document.getElementById('tryExampleOverlay').style.display = 'none';
            showOverlay()
        });

        // Show help overlay
        document.getElementById('helpBtn').addEventListener('click', function () {
            document.getElementById('helpOverlay').style.display = 'block';
        });

        // Close help overlay
        document.getElementById('closeHelpOverlayBtn').addEventListener('click', function () {
            document.getElementById('helpOverlay').style.display = 'none';
        });

        // Optional: Close overlay when clicking outside of it
        document.getElementById('helpOverlay').addEventListener('click', function (event) {
            if (event.target === this) {
                this.style.display = 'none';
            }
        });



        // File paths
        const filePath1 = 'examples/matrix_lung.csv';
        const filePath2 = 'examples/metadata_lung.csv';

        // Fetch file data and create File objects
        function preloadFile(filePath, inputElement) {
            fetch(filePath)
                .then(response => response.blob())
                .then(blob => {
                    // Create a File object from the blob
                    const file = new File([blob], filePath, { type: blob.type });

                    // Create a DataTransfer to hold the File object
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);

                    // Assign the File object to the file input
                    inputElement.files = dataTransfer.files;
                })
                .catch(error => console.error('Error preloading file:', error));
        }

        // Preload the files into the file inputs
        document.addEventListener('DOMContentLoaded', () => {
            const loadCsvBtn = document.getElementById('loadCsvBtn');
            const fileInput1 = document.getElementById('fileInput1');
            const fileInput2 = document.getElementById('fileInput2');
            const notification = document.getElementById('notification');

            // // Initial notification
            // notification.textContent = "Please upload two CSV files.";
            // notification.style.color = '#555'; // Default color


            function checkFileType() {
                console.log(checkFileType)
                const file1 = fileInput1.files[0];
                const file2 = fileInput2.files[0];
                const isFile1Csv = file1 && (file1.name.endsWith('.csv') || file1.name.endsWith('.CSV'));
                const isFile2Csv = file2 && (file2.name.endsWith('.csv') || file2.name.endsWith('.CSV'));
                console.log("File 1 is CSV", isFile1Csv)
                console.log("File 2 is CSV", isFile2Csv)
                if (!file1 || !file2) {
                    notification.textContent = "Please upload two CSV files.";
                    notification.style.color = '#555'; // Default color
                }
                else if (isFile1Csv && isFile2Csv) {
                    loadCsvBtn.style.cursor = 'pointer';
                    loadCsvBtn.style.opacity = '1';
                    loadCsvBtn.disabled = false;
                    notification.textContent = "Both files are valid CSV files.";
                    notification.style.color = 'green';
                } else {
                    loadCsvBtn.style.cursor = 'not-allowed';
                    loadCsvBtn.style.opacity = '0.6';
                    loadCsvBtn.disabled = true;
                    notification.textContent = "Please ensure both files are valid CSV files.";
                    notification.style.color = 'red';

                }
            }

            fileInput1.addEventListener('change', checkFileType);
            fileInput2.addEventListener('change', checkFileType);
            tippy('.tippyBtn', {
                content: (reference) => reference.getAttribute('data-tippy-content'),
                arrow: true,
                animation: 'fade',
                duration: [200, 300],
                theme: 'light', // Optional: change the tooltip theme
                maxWidth: 300, // Optional: set maximum width for the tooltip
                allowHTML: true // Allows HTML content in tooltips

            });

            // preloadFile(filePath1, fileInput1);
            // preloadFile(filePath2, fileInput2);
        });


        document.getElementById("loadCsvBtn").addEventListener("click", async function () {
            document.getElementById("loadingOverlay").style.display = "block";
            const fileInput1 = document.getElementById("fileInput1");
            const fileInput2 = document.getElementById("fileInput2");
            const file1 = fileInput1.files[0];
            const file2 = fileInput2.files[0];

            if (!file1 && !file2) {
                alert("Please select at least one file");
                return;
            }

            // Create a worker dynamically
            const createWorker = () => {
                const csvWorkerScript = `
                    self.onmessage = function (event) {
                        let buffer = event.data;
                        let lines = buffer.split('\\n');
                        let headers = null;
                        let data = [];

                        function detectDelimiter(line) {
                            return line.includes(',') ? ',' : line.includes(';') ? ';' : ',';
                        }

                        for (let line of lines) {
                            if (!headers) {
                                let delimiter = detectDelimiter(line);
                                headers = line.split(delimiter).map(h => h.trim().replace(/-/g, '.'));
                                headers = headers.map(h => (/^\\d/.test(h) ? 'X' + h : h));
                            } else {
                                let values = line.split(',');
                                if (values.length !== headers.length) continue;
                                let obj = {};
                                headers.forEach((h, i) => obj[h] = values[i].trim().replace(/\\r/g, ''));
                                data.push(obj);
                            }

                            if (data.length >= 1000) {
                                self.postMessage(data); // Send data in chunks
                                data = [];
                            }
                        }

                        if (data.length) self.postMessage(data);
                        self.postMessage(null); // Indicate completion
                    };
                `;

                const blob = new Blob([csvWorkerScript], { type: 'application/javascript' });
                return new Worker(URL.createObjectURL(blob));
            };

            async function processFileWithWorker(file) {
                return new Promise((resolve) => {
                    const worker = createWorker();
                    const reader = new FileReader();

                    reader.onload = function (e) {
                        let text = e.target.result;
                        let result = [];

                        worker.onmessage = (e) => {
                            if (e.data === null) {
                                resolve(result); // Resolve when processing is done
                            } else {
                                result = result.concat(e.data); // Append chunked data
                            }
                        };

                        worker.postMessage(text);
                    };

                    reader.readAsText(file);
                });
            }

            try {
                let data1, data2;
                if (file1 && !file2) {
                    data1 = await processFileWithWorker(file1);
                    hideLoadCsvOverlay();
                    showDisplayCsvOverlay(data1);
                } else {
                    // Process both files in parallel
                    [data1, data2] = await Promise.all([
                        processFileWithWorker(file1),
                        processFileWithWorker(file2),
                    ]);
                    meta_for_heatmap = data2;
                    hideLoadCsvOverlay();
                    showDisplayCsvOverlay(data1, data2);
                }
            } catch (error) {
                console.error("Error processing CSV:", error);
                alert("Failed to load CSV.");
            }
        });



        // Event listener for the "Load Dataset" button
        document.getElementById("loadDatasetBtn").addEventListener("click", function () {
            hideOverlay();
            showLoadCsvOverlay();
        });

        // Get references to the buttons and overlays
        var tryExampleBtn = document.getElementById("tryExampleBtn");
        var exampleOverlay = document.getElementById("tryExampleOverlay");

        // Function to show the example overlay
        function showExampleOverlay() {
            hideOverlay();
            exampleOverlay.style.display = "flex"; // Show the overlay
        }

        // Function to hide the example overlay
        function hideExampleOverlay() {
            exampleOverlay.style.display = "none"; // Hide the overlay
        }

        // Add event listener to the "Try Example" button
        tryExampleBtn.addEventListener("click", showExampleOverlay);

        // Add event listener to close the overlay if clicked outside the content
        exampleOverlay.addEventListener("click", function (event) {
            if (event.target === exampleOverlay) {
                hideExampleOverlay();
            }
        });

        document.getElementById('chooseExampleBtn').addEventListener('click', () => {
            const selectedExample = document.querySelector('input[name="exampleOption"]:checked');
            if (!selectedExample) {
                alert('Please select an example to proceed.');
                return;
            }
            example = true;
            document.getElementById("loadingOverlay").style.display = "block";
            const csvWorkerScript = `
            self.onmessage = function (event) {
                const contents = event.data;

                function detectDelimiter(line) {
                    // Check if the line contains a comma or a semicolon
                    if (line.includes(',')) {
                        return ',';
                    } else if (line.includes(';')) {
                        return ';';
                    } else {
                        // Default to comma if neither comma nor semicolon is found
                        return ',';
                    }
                }

                function parseCsv(contents) {
                    var lines = contents.split('\\n');
                    var data = [];

                    // Detect the delimiter
                    var delimiter = detectDelimiter(lines[0]);
                    console.log("Detected delimiter:", delimiter);

                    // Parse headers and apply transformations
                    var headers = lines[0].split(delimiter).map(header => header.trim()); // Trim headers

                    // Transform headers: Ensure each header starts with 'X' and replace '-' with '.'
                    headers = headers.map(header => {
                        // Replace '-' with '.'
                        header = header.replace(/-/g, '.');
                        // Add 'X' at the beginning if the header starts with a number
                        if (/^\\d/.test(header)) {
                            header = 'X' + header;
                        }
                        return header;
                    });

                    for (var i = 1; i < lines.length; i++) {
                        var obj = {};
                        var currentline = lines[i].split(delimiter);
                        if (currentline.length !== headers.length) {
                            continue; // Skip this line if the number of columns doesn't match the number of headers
                        }
                        for (var j = 0; j < headers.length; j++) {
                            obj[headers[j]] = currentline[j].trim(); // Trim data values
                            obj[headers[j]] = obj[headers[j]].replace(/\\r/g, ''); // Remove carriage return characters
                        }
                        data.push(obj);
                    }
                    return data;
                }

                const parsedData = parseCsv(contents);
                self.postMessage(parsedData);
            };
        `;

            // Create a blob from the worker script
            const csvBlob = new Blob([csvWorkerScript], { type: 'application/javascript' });
            const csvWorkerURL = URL.createObjectURL(csvBlob);

            const exampleValue = selectedExample.value;

            let filePath1 = '';
            let filePath2 = '';

            // Set file paths based on selected example
            if (exampleValue === 'example1') {
                filePath1 = 'examples/matrix_lung.csv';
                filePath2 = 'examples/metadata_lung.csv';
            } else if (exampleValue === 'example2') {
                filePath1 = 'examples/matrix_myeloma.csv';
                filePath2 = 'examples/metadata_myeloma.csv';
            } else if (exampleValue === 'example3') {
                filePath1 = 'examples/matrix_CCA.csv';
                filePath2 = 'examples/metadata_CCA.csv';
            } else if (exampleValue === 'example4') {
                filePath1 = 'examples/matrix_HCC.csv';
                filePath2 = 'examples/metadata_HCC.csv';
            }

            // Load the first file
            fetch(filePath1)
                .then(response => response.text())
                .then(contents1 => {
                    // Create a worker for parsing the first CSV file
                    const worker1 = new Worker(csvWorkerURL);
                    worker1.onmessage = function (e) {
                        const data1 = e.data;

                        // Load the second file
                        fetch(filePath2)
                            .then(response => response.text())
                            .then(contents2 => {
                                // Create a worker for parsing the second CSV file
                                const worker2 = new Worker(csvWorkerURL);
                                worker2.onmessage = function (e) {
                                    const data2 = e.data;
                                    meta_for_heatmap = data2;

                                    // Hide the overlay
                                    document.getElementById('tryExampleOverlay').style.display = 'none';

                                    // Display the CSV contents
                                    showDisplayCsvOverlay(data1, data2);
                                };

                                worker2.postMessage(contents2);
                            })
                            .catch(error => {
                                console.error('Error loading the second file:', error);
                            });
                    };

                    worker1.postMessage(contents1);
                })
                .catch(error => {
                    console.error('Error loading the first file:', error);
                });


        });



        //**********************     INIZIO VECCHIA FUNZIONE INIZIALE LOADING DI TUTTI I VARI FILE  ******************************//
        /*
            document.getElementById("tryExampleBtn").addEventListener("click", function () {
                hideOverlay();
                document.getElementById("loadingOverlay").style.display = "block";
    
                Promise.all([fetchJSON('dataC_log.json'), fetchJSON('dataN_log.json'), fetchJSON('data_log.json'), fetchMeta('metadata.json')])
                    .then(([dataC, dataN, data, meta]) => {
                        dataC_original = dataC
                        dataN_original = dataN
                        data_original = data
                        console.log(data)
                        metadata = meta
                        fetch('variation_lung.txt')
                            .then(response => response.text())
                            .then(text => {
                                // Parse the data
                                const rows = text.split('\n');
                                variation_data = rows.slice(1).map(row => {
                                    const [gene, variation] = row.trim().split('\t');
                                    return parseFloat(variation);
                                });
                                console.log(variation_data)
                                const row_length = rows.length - 1
                                initial_num_genes = row_length
                                variation_data_copy = (variation_data);
                                console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)
    
                                thr_prc = ss.quantile(variation_data, prc_IQR);
                                updateHistogram(variation_data);
    
                                const ind = variation_data_copy.reduce((result, entry, index) => {
    
                                    if (entry < thr_prc) {
                                        result.push(index);
                                    }
                                    return result;
                                }, []);
    
                                if (ind.length > 0) {
    
                                    // Remove entries corresponding to ind from dataN
                                    data_copy1 = data_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from dataC
                                    dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from data
                                    dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from genes
                                    //genes = genes.filter((entry, index) => !ind.includes(index));
    
                                    // Remove entries corresponding to ind from logFC
                                    //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
    
                                }
    
                                dataN_copy = dataN_copy1
                                dataC_copy = dataC_copy1
                                data_copy = data_copy1
                                console.log("geni tolti dal primo filtering del IQR", ind.length)
    
                                // Update the gene count display
                                // const geneCountDiv = document.getElementById('geneCount');
                                // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;
    
                                first_filter_number_genes = data_copy.length
                                console.log(dataC_original)
                                parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                                parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                                parsedLogFC = parsedLogFC_origin
    
                                //  console.log("first parsed origin after",parsedLogFC_origin.length)
                                //  console.log("first data orign afterN ",dataN_copy.length)
                                //  console.log("first data orign afterC ",dataC_copy.length)
    
                                averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                                averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);
    
    
                                fetch('genes_and_pval_adj.json')
                                    .then(response => response.json())
                                    .then(data => {
                                        p_val_adj = data
    
                                        // Calculate the quantile
                                        log_thr_fc = Math.log2(1.1);
                                        //console.log(log_thr_fc)
                                        const ind = parsedLogFC_origin.reduce((result, entry, index) => {
    
                                            if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                                result.push(index);
    
                                            }
                                            return result;
                                        }, []);
                                        console.log("geni tolti dal primo filtering del LOGFC", ind.length)
    
                                        // console.log("parsed log before ",parsedLogFC.length)
                                        // console.log("data copy beforeC ",dataC_copy.length)
                                        // console.log("data copy beforeN ",dataN_copy.length)
    
                                        // console.log("parsed log origin ",parsedLogFC_origin.length)
                                        /////////////////////// 
    
                                        //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE
    
                                        //////////////////////
                                        // console.log(parsedLogFC_origin)
                                        // console.log(data_copy)
                                        if (ind.length > 0) {
    
                                            // Remove entries corresponding to ind from dataN
                                            dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));
    
                                            // Remove entries corresponding to ind from dataN
                                            dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));
    
                                            data_copy = data_copy1.filter((entry, index) => !ind.includes(index));
    
                                            parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                                        }
    
                                        //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                                        // console.log(parsedLogFC)
                                        // console.log(data_copy)
    
                                        updateLogFCHistogram(parsedLogFC_origin)
    
                                        var req = ocpu.call("hello", {
                                            data: data_copy
                                        }, function (session) {
                                            var filteredDataURL = session.loc + "/R/.val/json";
                                            //console.log(session);
                                            // Fetch the filtered data from the URL
                                            fetch(filteredDataURL)
                                                .then(response => response.json())
                                                .then(data => {
                                                    old_p_adj = data
                                                    const ind = old_p_adj.reduce((result, entry, index) => {
    
                                                        if (entry.pval_adj > threshold) {
                                                            result.push(index);
                                                        }
                                                        return result;
                                                    }, []);
    
    
                                                    console.log("geni tolti dal primo filtering del pval", ind.length)
    
                                                    if (ind.length > 0) {
    
                                                        //console.log(parsedLogFC.length)
    
                                                        // Remove entries corresponding to ind from dataN
    
                                                        // Remove entries corresponding to ind from dataN
                                                        dataC_copy_pval = dataC_copy.filter((entry, index) => !ind.includes(index));
    
                                                        // Remove entries corresponding to ind from dataN
                                                        dataN_copy_pval = dataN_copy.filter((entry, index) => !ind.includes(index));
    
    
                                                        data_copy_pval = data_copy.filter((entry, index) => !ind.includes(index));
    
                                                        console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                        // Remove entries corresponding to ind from logFC
                                                        parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));
    
                                                        parsedLogFC_pval = parsedLogFC
                                                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
    
                                                        console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)
    
                                                        var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);
    
                                                        var mostUpregulatedGene = sortedLogFC[0];
                                                        var secondMostUpregulatedGene = sortedLogFC[1];
    
                                                        var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                        var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];
    
                                                        var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                                                        //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                                                        var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                                                        //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene
    
    
                                                        genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
    
                                                        selectedGeneData.push(mostUpregulatedGeneName)
                                                        selectedGeneData.push(mostDownregulatedGeneName)
    
    
    
                                                        updateParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)
    
                                                        updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
    
                                                        updateCounter()
    
                                                        scatter.selectAll("circle")
                                                            .filter(circleData => circleData.gene === mostUpregulatedGeneName || circleData.gene === mostDownregulatedGeneName)
                                                            .style("fill", d => {
                                                                // Check if logFC is greater than or equal to the threshold
                                                                return "green";
    
                                                            })
                                                            .classed('pulse', true);
    
    
                                                        document.getElementById("checkbox").style.visibility = "visible";
                                                        document.getElementById("radiobox").style.visibility = "visible";
    
    
                                                    }
                                                    console.log(dataN_copy.length)
                                                    var pc1Values = [];
                                                    var pc2Values = [];
                                                    var groupValues = [];
                                                    var req = ocpu.call("pca", {
                                                        data: data_copy_pval,
                                                        dataN: dataN_copy_pval,
                                                        dataC: dataC_copy_pval
                                                    }, function (session) {
                                                        var filteredDataURL = session.loc + "/R/.val/json";
                                                        //console.log(session);
                                                        // Fetch the filtered data from the URL
                                                        fetch(filteredDataURL)
                                                            .then(response => response.json())
                                                            .then(data => {
                                                                json = data
                                                                console.log(filteredDataURL)
                                                                console.log(json)
    
                                                                var pc1Key = "PC1";
                                                                var pc2Key = "PC2";
                                                                var groupKey = "Group";
    
                                                                // Arrays to store PC1 and PC2 values
    
    
                                                                // Iterate over each object in the JSON array
                                                                json.scores_df.forEach(function (obj) {
                                                                    // Push PC1, PC2, and Group values to the arrays
                                                                    pc1Values.push(obj[pc1Key]);
                                                                    pc2Values.push(obj[pc2Key]);
                                                                    groupValues.push(obj[groupKey]);
                                                                });
                                                                // console.log(pc1Values)
    
                                                                pca_data = [];
    
                                                                // Iterate over each object in the JSON array
                                                                json.scores_df.forEach(function (obj) {
                                                                    // Retrieve additional data from metadata based on _row
                                                                    var gsm = obj._row;
                                                                    var group = obj.Group;
    
                                                                    // Retrieve smokerclass, stage, pc1, and pc2 from metadata
                                                                    var smokerclass = metadata['Cigarette Smoking Status:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                                    var stage = metadata['Stage:ch1'][metadata.geo_accession.indexOf(gsm)];
                                                                    var pc1 = obj.PC1;
                                                                    var pc2 = obj.PC2;
    
                                                                    // Create an object with the required fields
                                                                    var newObj = {
                                                                        GSM: gsm,
                                                                        group: group,
                                                                        smokerclass: smokerclass,
                                                                        stage: stage,
                                                                        pc1: pc1,
                                                                        pc2: pc2
                                                                    };
    
                                                                    // Push the new object to the newData array
                                                                    pca_data.push(newObj);
    
    
                                                                });
                                                                heatmap_data = []
                                                                json.scores_var.forEach(function (obj) {
                                                                    // Push PC1, PC2, and Group values to the arrays
                                                                    var gene = obj._row
                                                                    var pc1 = obj.PC1
                                                                    var pc2 = obj.PC2
                                                                    var pc3 = obj.PC3
                                                                    var pc4 = obj.PC4
                                                                    var pc5 = obj.PC5
                                                                    var pc6 = obj.PC6
    
                                                                    var newObj = {
                                                                        gene: gene,
                                                                        pc1: pc1,
                                                                        pc2: pc2,
                                                                        pc3: pc3,
                                                                        pc4: pc4,
                                                                        pc5: pc5,
                                                                        pc6: pc6
                                                                    };
                                                                    heatmap_data.push(newObj);
                                                                })
                                                                // Display the newData array
                                                                console.log("PCA first computing", pca_data);
    
    
                                                                pca(pca_data);
                                                                heatmap(heatmap_data);
    
                                                            })
    
    
    
    
    
                                                    })
                                                    // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                                    // var req = ocpu.call("enrichment", {
                                                    //     data: data_copy
                                                    //     }, function (session) {
    
                                                    // })
                                                });
    
    
                                        })
                                        ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////
    
    
                                        // Calculate the quantile
                                        log_thr_fc = Math.log2(thr_fc);
    
                                    })
                                const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {
    
                                    if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                        result.push(index);
                                    }
                                    return result;
                                }, []);
    
                                // const geneCountDiv2 = document.getElementById('geneCount2');
                                // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;
    
    
                            })
                            .catch(error => console.error('Error reading file:', error));
    
                    });
            });*/

        //**********************     FINE VECCHIA FUNZIONE INIZIALE LOADING DI TUTTI I VARI FILE  ******************************//
        function isInteger(value) {
            return Number.isInteger(parseFloat(value));
        }


        async function quantileNormalize(data) {
            // Step 1: Extract sample values (ignoring the first key 'ID_REF')
            const sampleValues = data.map(row => Object.values(row).slice(1).map(parseFloat));

            // Step 2: Initialize rank matrix
            const rankMatrix = Array.from({ length: sampleValues[0].length }, () => new Array(sampleValues.length));

            // Step 3: Rank the values for each column
            for (let col = 0; col < sampleValues[0].length; col++) {
                const values = sampleValues.map(row => row[col]);
                const sortedIndices = Array.from(values.keys()).sort((a, b) => values[a] - values[b]);

                let currentRank = 1; // Start ranking from 1
                for (let i = 0; i < sortedIndices.length; i++) {
                    let tieCount = 1; // Count how many values are the same
                    while (i + 1 < sortedIndices.length && values[sortedIndices[i]] === values[sortedIndices[i + 1]]) {
                        tieCount++;
                        i++;
                    }
                    // Assign the same rank to all tied values
                    for (let j = 0; j < tieCount; j++) {
                        rankMatrix[col][sortedIndices[i - tieCount + 1 + j]] = currentRank;
                    }
                    // Move to the next rank
                    currentRank += tieCount;
                }
            }

            console.log("Rank Matrix:", rankMatrix);

            // Step 4: Rearranging the values in each column
            const rearrangedSamples = [];
            for (let col = 0; col < sampleValues[0].length; col++) {
                const columnValues = sampleValues.map(row => row[col]);
                rearrangedSamples[col] = columnValues.slice().sort((a, b) => a - b);
            }

            console.log("Rearranged Samples:", rearrangedSamples);

            // Step 5: Calculate the mean of the rearranged samples for each gene (row)
            const means = rearrangedSamples[0].map((_, rowIndex) => {
                const sum = rearrangedSamples.reduce((acc, curr) => acc + curr[rowIndex], 0);
                return sum / rearrangedSamples.length; // Average across the samples
            });

            console.log("Means:", means);

            // Step 6: Substitute the ranks with their corresponding mean values
            const normalizedData = data.map((row, rowIndex) => {
                let newRow = { [Object.keys(row)[0]]: row[Object.keys(row)[0]] }; // Keep the gene ID intact
                Object.keys(row).slice(1).forEach((_, colIndex) => {
                    // Get the rank for the current row from the rank matrix
                    const rank = rankMatrix[colIndex][rowIndex]; // Rank can be from 1 to the number of rows
                    // Use the mean value corresponding to the rank
                    newRow[Object.keys(row)[colIndex + 1]] = means[rank - 1]; // Subtract 1 for zero-based index
                });
                return newRow;
            });

            console.log("Normalized Data:", normalizedData);
            return normalizedData;
        }


        // Function to update the table with normalized data
        function updateTableWithNormalizedData(normalizedData) {
            // Clear the existing table content
            let tableBody1 = document.querySelector("#csvTableData1 tbody");
            tableBody1.innerHTML = ''; // Clear previous rows for table 1

            // Create header for normalized data
            const headers = Object.keys(normalizedData[0]).slice(0, 5);
            let tableData1 = "<thead><tr>";

            // Function to truncate headers longer than 8 characters
            function truncateHeader(header) {
                return header.length > 8 ? header.slice(0, 8) + "..." : header;
            }

            // Function to create a header with a tooltip
            function createHeaderCell(header) {
                const truncated = truncateHeader(header);
                return `<th title="${header}">${truncated}</th>`;
            }

            // Display headers for normalized data
            headers.forEach(function (key) {
                tableData1 += createHeaderCell(key);
            });
            tableData1 += "</tr></thead><tbody>";

            // Function to truncate text longer than a given length
            function truncateText(text, maxLength) {
                // Convert non-string values to string
                const textString = String(text);
                return textString.length > maxLength ? textString.slice(0, maxLength) + "..." : textString;
            }

            // Function to create a cell with a tooltip
            function createCell(text, maxLength) {
                const truncated = truncateText(text, maxLength);
                return `<td title="${text}">${truncated}</td>`;
            }

            // Display data rows for normalized data
            for (let i = 0; i < normalizedData.length; i++) {
                tableData1 += "<tr>";
                headers.forEach(function (key) {
                    let value = normalizedData[i][key]; // Get the value
                    tableData1 += createCell(value !== undefined ? value : '', 8); // Handle undefined
                });
                tableData1 += "</tr>";
            }
            tableData1 += "</tbody>";

            // Insert the created HTML into the table
            document.getElementById("csvTableData1").innerHTML = tableData1;

            // Reinitialize DataTables
            if (table1) {
                table1.destroy(); // Destroy the previous instance if it exists
            }
            table1 = $('#csvTableData1').DataTable({
                "paging": true,
                "pageLength": 5,
                ordering: false,
                searching: false,
                "lengthChange": false
            });
        }

        function showDisplayCsvOverlay(data1, data2) {
            console.log(data1)
            document.getElementById("loadingOverlay").style.display = "none";

            document.getElementById("displayCsvOverlay").style.display = "block";

            // Display the first 10 columns of each CSV data in a table side by side
            var tableData1 = "<thead><tr>";
            var tableData2 = "<thead><tr>";

            // Determine the headers and data to display based on the presence of data1 and data2
            var headersData1 = [];
            var headersData2 = [];

            // Identify sample names (excluding the first column, which might be "Gene" or "Sample ID")
            let headers1 = Object.keys(data1[0]).slice(1); // Exclude first column
            let headers2 = Object.keys(data2[0]).slice(1);

            // Find common sample names
            let commonSamples = headers1.filter(sample => headers2.includes(sample));

            if (commonSamples.length === 0) {
                alert("No common samples found between the two datasets.");
                return;
            }

            // Ensure the first column is retained (e.g., "Gene" or "Sample ID")
            let firstColumn1 = Object.keys(data1[0])[0];
            let firstColumn2 = Object.keys(data2[0])[0];

            // Filter data1 and data2 to include only common samples + first column
            let filteredData1 = data1.map(row => {
                let filteredRow = { [firstColumn1]: row[firstColumn1] };
                commonSamples.forEach(sample => filteredRow[sample] = row[sample]);
                return filteredRow;
            });

            let filteredData2 = data2.map(row => {
                let filteredRow = { [firstColumn2]: row[firstColumn2] };
                commonSamples.forEach(sample => filteredRow[sample] = row[sample]);
                return filteredRow;
            });

            data1 = filteredData1

            data2 = filteredData2
            meta_for_heatmap = filteredData2;

            if (data1) {
                headersData1 = Object.keys(data1[0]).slice(0, 5);
                document.getElementById("totalColumns1").textContent = Object.keys(data1[0]).length;
            }

            if (data2) {
                headersData2 = Object.keys(data2[0]).slice(0, 5);
                document.getElementById("totalColumns2").textContent = Object.keys(data2[0]).length;
            }

            // Function to truncate headers longer than 8 characters
            function truncateHeader(header) {
                return header.length > 8 ? header.slice(0, 8) + "..." : header;
            }

            // Function to create a header with a tooltip
            function createHeaderCell(header) {
                const truncated = truncateHeader(header);
                return `<th title="${header}">${truncated}</th>`;
            }

            // Display headers for data1
            headersData1.forEach(function (key) {
                tableData1 += createHeaderCell(key);
            });
            tableData1 += "</tr></thead><tbody>";

            // Display headers for data2
            headersData2.forEach(function (key) {
                tableData2 += createHeaderCell(key);
            });
            tableData2 += "</tr></thead><tbody>";

            // Function to truncate text longer than a given length
            function truncateText(text, maxLength) {
                return text.length > maxLength ? text.slice(0, maxLength) + "..." : text;
            }

            // Function to create a cell with a tooltip
            function createCell(text, maxLength) {
                const truncated = truncateText(text, maxLength);
                return `<td title="${text}">${truncated}</td>`;
            }

            // Display data rows for data1
            for (var i = 0; i < data1.length; i++) {
                tableData1 += "<tr>";
                headersData1.forEach(function (key) {
                    tableData1 += createCell(data1[i][key] || '', 8);
                });
                tableData1 += "</tr>";
            }
            tableData1 += "</tbody>";

            // Display data rows for data2
            for (var i = 0; i < data2.length; i++) {
                tableData2 += "<tr>";
                headersData2.forEach(function (key) {
                    tableData2 += createCell(data2[i][key] || '', 8);
                });
                tableData2 += "</tr>";
            }
            tableData2 += "</tbody>";

            document.getElementById("csvTableData1").innerHTML = tableData1;
            document.getElementById("csvTableData2").innerHTML = tableData2;

            if (table1) {
                table1.destroy();
                table2.destroy();
            }

            table1 = $('#csvTableData1').DataTable({
                "paging": true, // Enable pagination
                "pageLength": 5, // Number of rows per page
                ordering: false,
                searching: false,
                "lengthChange": false
                // "scrollY": "200px", // Height of the scrolling container
                // "scrollCollapse": true // Collapse the table height to fit the scrolling container
            });

            // Initialize DataTable for the second table with virtual scrolling
            table2 = $('#csvTableData2').DataTable({
                "paging": true, // Enable pagination
                "pageLength": 5, // Number of rows per page
                ordering: false,
                searching: false,
                "lengthChange": false

                // "scrollY": "200px", // Height of the scrolling container
                // "scrollCollapse": true // Collapse the table height to fit the scrolling container
            });

            // Add CSS to hide the x-axis scrollbar
            $('#csvTableData2_wrapper .dataTables_scrollBody').css('overflow-x', 'hidden');


            // $('#csvTableData1_wrapper').css('margin-right', '40px');

            // Compare the headers excluding the first element
            // var headers1ToCompare = Object.keys(data1[0]).slice(1);
            // var headers2ToCompare = Object.keys(data2[0]).slice(1);
            var headersMatch = JSON.stringify(headers1) === JSON.stringify(headers2);

            // Create the message container and message element
            var messageContainer = document.getElementById('messageContainer');
            var messageElement = document.createElement('span');

            if (headersMatch) {
                messageElement.style.color = '#228B22'; // Better green color
                messageElement.innerHTML = '<span style="color: #228B22; font-weight: bold;">&#10003;</span> <strong>Everything looks good!</strong> The headers match, and the files are ready for analysis.';
                document.getElementById("selectMetadataBtn").disabled = false;
            } else {
                messageElement.style.color = 'orange';
                messageElement.innerHTML = `<span style="color: orange; font-weight: bold;">&#9888;</span> <strong>Notice:</strong> The original headers mismatched, but we retained ${commonSamples.length} common samples for analysis.`;
                document.getElementById("selectMetadataBtn").disabled = false;
            }

            // Clear any existing message and add the new message
            messageContainer.innerHTML = ''; // Clear previous message
            messageContainer.appendChild(messageElement);

            // Make sure the message container is visible
            document.getElementById("displayCsvOverlay").style.display = "block";

            // Define the quantile normalization logic as a string
            const workerScript = `
                self.onmessage = function (event) {
                    const data = event.data;

                    function quantileNormalize(data) {
                        const sampleValues = data.map(row => Object.values(row).slice(1).map(parseFloat));
                        const rankMatrix = Array.from({ length: sampleValues[0].length }, () => new Array(sampleValues.length));

                        for (let col = 0; col < sampleValues[0].length; col++) {
                            const values = sampleValues.map(row => row[col]);
                            const sortedIndices = Array.from(values.keys()).sort((a, b) => values[a] - values[b]);

                            let currentRank = 1;
                            for (let i = 0; i < sortedIndices.length; i++) {
                                let tieCount = 1;
                                while (i + 1 < sortedIndices.length && values[sortedIndices[i]] === values[sortedIndices[i + 1]]) {
                                    tieCount++;
                                    i++;
                                }
                                for (let j = 0; j < tieCount; j++) {
                                    rankMatrix[col][sortedIndices[i - tieCount + 1 + j]] = currentRank;
                                }
                                currentRank += tieCount;
                            }
                        }

                        const rearrangedSamples = [];
                        for (let col = 0; col < sampleValues[0].length; col++) {
                            const columnValues = sampleValues.map(row => row[col]);
                            rearrangedSamples[col] = columnValues.slice().sort((a, b) => a - b);
                        }

                        const means = rearrangedSamples[0].map((_, rowIndex) => {
                            const sum = rearrangedSamples.reduce((acc, curr) => acc + curr[rowIndex], 0);
                            return sum / rearrangedSamples.length;
                        });

                        const normalizedData = data.map((row, rowIndex) => {
                            let newRow = { [Object.keys(row)[0]]: row[Object.keys(row)[0]] };
                            Object.keys(row).slice(1).forEach((_, colIndex) => {
                                const rank = rankMatrix[colIndex][rowIndex];
                                newRow[Object.keys(row)[colIndex + 1]] = means[rank - 1];
                            });
                            return newRow;
                        });

                        return normalizedData;
                    }

                    const normalizedData = quantileNormalize(data);
                    self.postMessage(normalizedData);
                };
                `;

            // Create a blob from the worker script
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            const workerURL = URL.createObjectURL(blob);

            // Initialize Tippy.js for 'quantileNormalizeBtn'
            var quantileNormalizeBtn = document.getElementById("quantileNormalizeBtn");

            var tippyInstanceQuantile = tippy(quantileNormalizeBtn, {
                content: "Quantile normalization ensures that the distribution of expression values is the same across all samples. If you choose to apply quantile normalization, DESeq2 will no longer be available as it requires raw, unnormalized count data.",
                placement: 'top',
                theme: 'light',
                interactive: true,  // Allow interaction with the tooltip
            });

            // Button click event for performing quantile normalization
            document.getElementById("quantileNormalizeBtn").addEventListener("click", function () {
                // Show loading overlay
                document.getElementById("loadingOverlay").style.display = "block";

                // Create a new Web Worker
                const worker = new Worker(workerURL);

                // Listen for messages from the worker
                worker.onmessage = function (event) {
                    data1 = event.data;

                    // Update the table with the normalized data
                    updateTableWithNormalizedData(data1);

                    // Remove the button after it's clicked
                    document.getElementById("quantileNormalizeBtn").style.display = 'none';

                    // Hide loading overlay
                    document.getElementById("loadingOverlay").style.display = "none";

                    // Terminate the worker
                    worker.terminate();
                    URL.revokeObjectURL(workerURL); // Clean up the object URL
                };

                // Send data to the worker for normalization
                worker.postMessage(data1);
            });


            document.getElementById("selectMetadataBtn").addEventListener("click", function () {

                // Create the all_int variable
                let all_int = data1.every(item => {
                    // Exclude the first field, typically 'ID_REF'
                    return Object.values(item).slice(1).every(isInteger);
                });

                console.log(all_int); // This will be true if all values (excluding the first) are integers

                // Hide the current overlay
                document.getElementById("displayCsvOverlay").style.display = "none";

                // Create a new overlay for selecting metadata rows
                var selectMetadataOverlay = document.createElement("div");
                selectMetadataOverlay.setAttribute("id", "selectMetadataOverlay");
                selectMetadataOverlay.setAttribute("style", "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); z-index: 1001; display: flex; justify-content: center; align-items: center; overflow-y: auto;");
                document.body.appendChild(selectMetadataOverlay);

                // Create content for the overlay
                var selectMetadataContent = document.createElement("div");
                selectMetadataContent.setAttribute("style", "background-color: white; padding: 30px; border-radius: 8px; width: 80%; max-width: 800px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);");
                selectMetadataContent.innerHTML = `
        <h2 style="margin-bottom: 20px; font-size: 24px; color: #333; text-align: center;">Select Metadata Category</h2>
        <p style="margin-bottom: 20px; font-size: 16px; color: #555;">Please choose the category within the metadata that contains binary classifications (e.g., case vs. normal, male vs. female) for conducting the Differential Expression Gene (DEG) analysis:</p>
    `;


                // Create an array to keep track of all dropdown pairs
                var dropdownPairs = [];

                // Variables to store the selected values from the dropdowns
                var selectedValue1 = "";
                var selectedValue2 = "";


                // Create dropdown menus for each row in data2
                data2.forEach(function (row, index) {
                    var dropdownContainer = document.createElement("div");
                    dropdownContainer.setAttribute("style", "display: flex; align-items: center; margin-bottom: 10px;");

                    // Create radio button label
                    var radioLabel = document.createElement("label");
                    radioLabel.setAttribute("style", "margin-right: 10px;");
                    var radioButton = document.createElement("input");
                    radioButton.setAttribute("type", "radio");
                    radioButton.setAttribute("name", "metadataRow"); // Set the same name for all radio buttons to make them mutually exclusive
                    radioButton.setAttribute("value", index); // Use the index as the value for identifying the selected row
                    if (index === 0) {
                        radioButton.setAttribute("checked", "checked"); // Check the first radio button by default
                    }
                    radioLabel.appendChild(radioButton);
                    radioLabel.appendChild(document.createTextNode(row[Object.keys(row)[0]])); // Display the value of the first column
                    dropdownContainer.appendChild(radioLabel);

                    // Get the values of the selected row
                    var rowData = Object.values(data2[index]);
                    var values = rowData.slice(1); // Exclude the first value (name of the row)
                    var uniqueValues = Array.from(new Set(values)); // Convert Set to array for easier manipulation

                    // Create the first dropdown menu (dropdown1)
                    var dropdown1 = document.createElement("select");
                    dropdown1.setAttribute("name", "dropdown1");
                    dropdown1.setAttribute("style", "margin-left: 10px; width: 150px;");

                    // Create options for dropdown1
                    uniqueValues.forEach(function (value) {
                        var option = document.createElement("option");
                        option.textContent = value;
                        option.setAttribute("value", value);
                        dropdown1.appendChild(option);
                    });

                    // Set the first value as selected in dropdown1
                    dropdown1.selectedIndex = 0;
                    if (index === 0) {
                        selectedValue1 = dropdown1.options[0].value;
                    }

                    // Create the second dropdown menu (dropdown2)
                    var dropdown2 = document.createElement("select");
                    dropdown2.setAttribute("name", "dropdown2");
                    dropdown2.setAttribute("style", "width: 150px;");

                    // Create options for dropdown2 (same options as dropdown1)
                    uniqueValues.forEach(function (value) {
                        var option = document.createElement("option");
                        option.textContent = value;
                        option.setAttribute("value", value);
                        dropdown2.appendChild(option);
                    });

                    // Set the second value as selected in dropdown2
                    dropdown2.selectedIndex = 1;

                    if (index === 0) {
                        selectedValue2 = dropdown2.options[1].value;
                    }

                    // Disable dropdowns initially (except for the first pair)
                    if (index !== 0) {
                        dropdown1.disabled = true;
                        dropdown2.disabled = true;
                    }

                    // Add event listeners to synchronize dropdown values
                    dropdown1.addEventListener("change", function () {
                        selectedValue1 = dropdown1.value;
                        synchronizeDropdowns(dropdown1, dropdown2);
                    });

                    dropdown2.addEventListener("change", function () {
                        selectedValue2 = dropdown2.value;
                        synchronizeDropdowns(dropdown2, dropdown1);
                    });

                    // Function to synchronize dropdown values
                    function synchronizeDropdowns(dropdown1n, dropdown2n) {
                        var selectedValue = dropdown1n.value;
                        var selectedValuesec = dropdown2n.value;
                        if (selectedValuesec === selectedValue) {
                            dropdown2n.selectedIndex = (dropdown2n.selectedIndex + 1) % dropdown2n.options.length;
                            selectedValue2 = dropdown2n.value;
                        }
                    }

                    // Add event listener to radio button to enable/disable dropdowns
                    radioButton.addEventListener("change", function () {
                        if (radioButton.checked) {
                            enableDropdowns(index);
                        }
                    });

                    // Function to enable/disable dropdowns based on radio button selection
                    function enableDropdowns(selectedIndex) {
                        dropdownPairs.forEach(function (pair, i) {
                            var isSelected = (i === selectedIndex);
                            pair.dropdown1.disabled = !isSelected;
                            pair.dropdown2.disabled = !isSelected;
                            if (isSelected) {
                                // Update the selected values
                                selectedValue1 = pair.dropdown1.value;
                                selectedValue2 = pair.dropdown2.value;
                            }
                        });
                    }

                    // Create a span for the "vs" text
                    var vsText = document.createElement("span");
                    vsText.textContent = " vs ";
                    vsText.setAttribute("style", "margin: 0 10px;");

                    dropdownContainer.appendChild(dropdown1);
                    dropdownContainer.appendChild(vsText); // Add "vs" text between dropdowns
                    dropdownContainer.appendChild(dropdown2);

                    dropdownPairs.push({ dropdown1: dropdown1, dropdown2: dropdown2 });

                    selectMetadataContent.appendChild(dropdownContainer);
                });

                var buttonContainer = document.createElement("div");
                buttonContainer.setAttribute("style", "margin-top: 20px; display: flex; justify-content: space-between; gap: 10px;");

                var selectRowBtn = document.createElement("button");
                selectRowBtn.textContent = "Perform DEG with t-test\n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; ");
                selectRowBtn.disabled = false;

                var selectRowBtn2 = document.createElement("button");
                selectRowBtn2.textContent = "Perform DEG with limma\n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn2.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; ");
                selectRowBtn2.disabled = false;

                var selectRowBtn3 = document.createElement("button");
                selectRowBtn3.textContent = "Perform DEG with deseq2\n(This may take a while. Don't panic if it seems stuck)";
                if (all_int) {
                    selectRowBtn3.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; ");
                    selectRowBtn3.disabled = false;
                }
                else {
                    selectRowBtn3.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: not-allowed; white-space: pre-line; opacity:0.6");
                    selectRowBtn3.disabled = true;
                }

                var selectRowBtn4 = document.createElement("button");
                selectRowBtn4.textContent = "Perform DEG with Wilcox\n(This may take a while. Don't panic if it seems stuck)";
                selectRowBtn4.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; ");
                selectRowBtn4.disabled = false;


                // Create div containers for each disabled button
                var div1 = document.createElement("div");
                div1.style.display = "inline-block";  // Ensure inline display for proper alignment
                div1.style.pointerEvents = "auto";    // Allow pointer events on the div
                div1.appendChild(selectRowBtn);

                var div2 = document.createElement("div");
                div2.style.display = "inline-block";
                div2.style.pointerEvents = "auto";
                div2.appendChild(selectRowBtn2);

                var div3 = document.createElement("div");
                div3.style.display = "inline-block";
                div3.style.pointerEvents = "auto";
                div3.appendChild(selectRowBtn3);

                // Create div containers for each disabled button
                var div4 = document.createElement("div");
                div4.style.display = "inline-block";  // Ensure inline display for proper alignment
                div4.style.pointerEvents = "auto";    // Allow pointer events on the div
                div4.appendChild(selectRowBtn4);


                // Initialize Tippy.js for tooltips on div containers
                var tippyInstance1 = tippy(div1, {
                    content: "The t-test is a parametric test that compares the means of two groups to identify statistically significant differences. It assumes that the data follows a normal distribution and is suitable for comparing two conditions.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var tippyInstance2 = tippy(div2, {
                    content: "Limma (Linear Models for Microarray Data) is an advanced statistical method that borrows information across genes to improve detection power in differential expression analysis.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var tippyInstance3 = tippy(div3, {
                    content: "DESeq2 (Differential Expression using RNA-Seq 2) is a popular tool for analyzing RNA-Seq data. It requires raw count data with integer values. If your data contains non-integer or pre-processed values, DESeq2 will be disabled.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var tippyInstance4 = tippy(div4, {
                    content: "The Wilcoxon test is a non-parametric test that compares two groups without assuming a normal distribution. It is particularly useful for small sample sizes or when the normality assumption is violated.",
                    placement: 'bottom',
                    theme: 'light',
                    interactive: true,  // Allow interaction with the tooltip
                });

                var selectColors = document.createElement("button");
                selectColors.textContent = "Select Color";
                selectColors.setAttribute("style", "padding: 10px; background-color: #FFC107; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;");
                data2.forEach(function (category, i) {
                    var rowData = Object.values(data2[i]); // Get the values of the selected row
                    var rowName = rowData[0];
                    var values = rowData.slice(1); // Exclude the first value (name of the row)
                    // Create an object to store the colors for this category
                    var categoryColors = {};

                    // Create a container for each category
                    var categoryContainer = document.createElement("div");
                    categoryContainer.classList.add("category-container");

                    // Create a label for the category
                    var categoryLabelContainer = document.createElement("div");
                    categoryLabelContainer.classList.add("category-label-container");

                    var categoryLabel = document.createElement("label");
                    categoryLabel.textContent = rowName + ": ";
                    categoryLabel.classList.add("category-label");
                    categoryLabelContainer.appendChild(categoryLabel);

                    // Create a "Resort Scale" button
                    var resortButton = document.createElement("button");
                    resortButton.textContent = "Resort Scale";
                    resortButton.classList.add("resort-button");
                    resortButton.setAttribute("style", "background-color: #78909c; color: white; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;");
                    resortButton.addEventListener('click', function () {
                        // Resort the colors based on the current order
                        var colorInputs = categoryContainer.querySelectorAll('.color-input-container');
                        colorInputs.forEach(function (colorInputContainer, index) {
                            var value = colorInputContainer.querySelector('.value-span').textContent;
                            var colorInput = colorInputContainer.querySelector('.color-input');

                            // Reapply colors based on the order
                            if (uniqueValues.size >= 4) {
                                var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                colorInput.value = colorScale(index);
                            } else {
                                colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                            }

                            // Update colorScaleValues
                            categoryColors[value] = colorInput.value;
                        });

                        // Update colorScaleValues object
                        colorScaleValues[rowName] = categoryColors;
                    });

                    resortButton.addEventListener('dblclick', function () {
                        // Reverse the colors based on the current order
                        var colorInputs = Array.from(categoryContainer.querySelectorAll('.color-input-container')).reverse();
                        colorInputs.forEach(function (colorInputContainer, index) {
                            var value = colorInputContainer.querySelector('.value-span').textContent;
                            var colorInput = colorInputContainer.querySelector('.color-input');

                            // Reapply colors based on the order
                            if (uniqueValues.size >= 4) {
                                var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                colorInput.value = colorScale(index);
                            } else {
                                colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                            }

                            // Update colorScaleValues
                            categoryColors[value] = colorInput.value;
                        });

                        // Update colorScaleValues object
                        colorScaleValues[rowName] = categoryColors;
                    });

                    categoryLabelContainer.appendChild(resortButton);
                    categoryContainer.appendChild(categoryLabelContainer);

                    // Filter values that contain 'I' or 'IA'
                    var filteredValues = values.filter(value => {
                        return value === 'I' || value === 'IA' || value === 'II' || value === 'IB';
                    });

                    if (filteredValues.length > 0) {
                        values.sort();
                        values.reverse();
                    }

                    // Get unique values for the current category
                    var uniqueValues = new Set(values);

                    // Check if there are fewer than 9 unique values
                    if (uniqueValues.size < 9) {
                        // Create a Sortable instance for this group of unique values
                        var sortable = new Sortable(categoryContainer, {
                            draggable: '.color-input-container',
                            animation: 150,
                            onEnd: function (evt) {
                                updateColorScaleValues();
                            }
                        });
                        // Create color inputs for each unique value
                        let colorIndex = 0;
                        uniqueValues.forEach(function (value) {
                            var colorInputContainer = document.createElement("div");
                            colorInputContainer.classList.add("color-input-container");

                            // Create a span to hold the unique value (centered)
                            var valueSpan = document.createElement("span");
                            valueSpan.textContent = value;
                            valueSpan.classList.add("value-span");
                            colorInputContainer.appendChild(valueSpan);

                            // Create a wrapper div for the color input
                            var inputWrapper = document.createElement("div");
                            inputWrapper.classList.add("input-wrapper");

                            // Create a color input (aligned to the right)
                            var colorInput = document.createElement("input");
                            colorInput.type = "color";
                            colorInput.id = "color_modal"; // Apply the style by setting the id
                            colorInput.name = category + "_" + value; // Use a unique name for each color input

                            // Assign specific colors for "female" and "male"
                            if (value === selectedValue1) {
                                colorInput.value = "#F4B653"
                            } else if (value === selectedValue2) {
                                colorInput.value = "#53D16E"
                            } else if (value.toLowerCase().includes("female")) {
                                colorInput.value = d3.schemeSet1[7]; // Eighth color of the schemeSet1 for "female"
                            } else if (value.toLowerCase().includes("male")) {
                                colorInput.value = d3.schemeSet1[1]; // Second color of the schemeSet1 for "male"
                            } else if (uniqueValues.size >= 4) {
                                var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                colorInput.value = colorScale(colorIndex);
                                colorIndex++;
                            } else {
                                colorInput.value = d3.schemeSet1[colorIndex % d3.schemeSet1.length]; // Default to cycling through the schemeSet1 colors
                                colorIndex++;
                            }

                            colorInput.classList.add("color-input");
                            inputWrapper.appendChild(colorInput);

                            // Add an event listener to update colorScaleValues on color change
                            colorInput.addEventListener('input', updateColorScaleValues);

                            // Add the wrapper div to the color input container
                            colorInputContainer.appendChild(inputWrapper);

                            // Add the color input container to the category container
                            categoryContainer.appendChild(colorInputContainer);

                            // Store the category information in the colorScaleValues object
                            categoryColors[value] = colorInput.value;
                        });

                        // Store the initial colors for the category
                        colorScaleValues[rowName] = categoryColors;
                    }
                });



                // Function to update the color scale values
                function updateColorScaleValues() {
                    // Clear the colorScaleValues object
                    colorScaleValues = {};

                    // Iterate over each category container
                    var categoryContainers = document.querySelectorAll('.category-container');
                    categoryContainers.forEach(function (container) {
                        // Get the category name
                        var categoryName = container.querySelector('.category-label').textContent.replace(':', '').trim();

                        // Create an object to store the colors for this category
                        var categoryColors = {};

                        // Iterate over each color input container in the category container
                        var colorInputContainers = container.querySelectorAll('.color-input-container');
                        colorInputContainers.forEach(function (colorInputContainer) {
                            // Get the value and color of the color input
                            var value = colorInputContainer.querySelector('.value-span').textContent;
                            var colorInput = colorInputContainer.querySelector('.color-input');
                            var color = colorInput.value;

                            // Store the value and color in the categoryColors object
                            categoryColors[value] = color;
                        });

                        // Store the categoryColors object in the colorScaleValues object
                        colorScaleValues[categoryName] = categoryColors;
                    });
                }
                selectColors.addEventListener("click", function () {

                    tippyInstance1.setContent("The t-test is a statistical test that compares the means of two groups to identify significant differences. Make sure to select a color scheme for visualization.");

                    tippyInstance2.setContent("Limma (Linear Models for Microarray Data) is an advanced statistical method that borrows information across genes to improve detection power in differential expression analysis.");

                    tippyInstance3.setContent("DESeq2 (Differential Expression using RNA-Seq 2) is a popular tool for analyzing RNA-Seq data. It requires raw count data with integer values. If your data contains non-integer or pre-processed values, DESeq2 will be disabled.");

                    tippyInstance4.setContent("The Wilcoxon test is a non-parametric test that compares two groups without assuming a normal distribution. It is particularly useful for small sample sizes or when the normality assumption is violated.");

                    // Create the full-screen black overlay with opacity
                    var fullScreenOverlay = document.createElement("div");
                    fullScreenOverlay.setAttribute("id", "fullScreenOverlay");
                    fullScreenOverlay.setAttribute("style",
                        "position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0, 0, 0, 0.7); z-index: 1002;" // Ensure this covers the whole page
                    );

                    // Create a new overlay for the content selection, centered within the screen
                    var selectColorOverlay = document.createElement("div");
                    selectColorOverlay.setAttribute("id", "selectColorOverlay");
                    selectColorOverlay.setAttribute("style",
                        "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 30%; height: auto; background-color: transparent; z-index: 1003; display: flex; justify-content: center; align-items: center; overflow-y: auto;"
                    );
                    var selectColorContent = document.createElement("div");
                    selectColorContent.setAttribute("style", "background-color: white; padding: 20px; border-radius: 5px;");

                    selectColorContent.innerHTML = "<h2>Select Colors</h2><p>Select a color for each unique value in the metadata categories. You can also reorder elements by dragging them. If you reordered and you want to restore the color scale, click on the 'Resort Scale Button'. With a double-click on it, you can revert the scale. Both the order and the color encoding will be used in the parallel coordinates plot.</p>";
                    console.log(data2)

                    data2.forEach(function (category, i) {
                        var rowData = Object.values(data2[i]); // Get the values of the selected row
                        var rowName = rowData[0];
                        var values = rowData.slice(1); // Exclude the first value (name of the row)
                        // Create an object to store the colors for this category
                        var categoryColors = {};

                        // Create a container for each category
                        var categoryContainer = document.createElement("div");
                        categoryContainer.classList.add("category-container");

                        // Create a label for the category
                        var categoryLabelContainer = document.createElement("div");
                        categoryLabelContainer.classList.add("category-label-container");

                        var categoryLabel = document.createElement("label");
                        categoryLabel.textContent = rowName + ": ";
                        categoryLabel.classList.add("category-label");
                        categoryLabelContainer.appendChild(categoryLabel);

                        // Create a "Resort Scale" button
                        var resortButton = document.createElement("button");
                        resortButton.textContent = "Resort Scale";
                        resortButton.classList.add("resort-button");
                        resortButton.setAttribute("style", "background-color: #78909c; color: white; border: none; border-radius: 4px; font-size: 10px; cursor: pointer;");
                        resortButton.addEventListener('click', function () {
                            // Resort the colors based on the current order
                            var colorInputs = categoryContainer.querySelectorAll('.color-input-container');
                            colorInputs.forEach(function (colorInputContainer, index) {
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');

                                // Reapply colors based on the order
                                if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(index);
                                } else {
                                    colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                                }

                                // Update colorScaleValues
                                categoryColors[value] = colorInput.value;
                            });

                            // Update colorScaleValues object
                            colorScaleValues[rowName] = categoryColors;
                        });

                        resortButton.addEventListener('dblclick', function () {
                            // Reverse the colors based on the current order
                            var colorInputs = Array.from(categoryContainer.querySelectorAll('.color-input-container')).reverse();
                            colorInputs.forEach(function (colorInputContainer, index) {
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');

                                // Reapply colors based on the order
                                if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(index);
                                } else {
                                    colorInput.value = d3.schemeSet1[index % d3.schemeSet1.length];
                                }

                                // Update colorScaleValues
                                categoryColors[value] = colorInput.value;
                            });

                            // Update colorScaleValues object
                            colorScaleValues[rowName] = categoryColors;
                        });

                        categoryLabelContainer.appendChild(resortButton);
                        categoryContainer.appendChild(categoryLabelContainer);

                        // Filter values that contain 'I' or 'IA'
                        var filteredValues = values.filter(value => {
                            return value === 'I' || value === 'IA' || value === 'II' || value === 'IB';
                        });

                        if (filteredValues.length > 0) {
                            values.sort();
                            values.reverse();
                        }

                        // Get unique values for the current category
                        var uniqueValues = new Set(values);

                        // Check if there are fewer than 9 unique values
                        if (uniqueValues.size < 9) {
                            // Create a Sortable instance for this group of unique values
                            var sortable = new Sortable(categoryContainer, {
                                draggable: '.color-input-container',
                                animation: 150,
                                onEnd: function (evt) {
                                    updateColorScaleValues();
                                }
                            });
                            // Create color inputs for each unique value
                            let colorIndex = 0;
                            uniqueValues.forEach(function (value) {
                                var colorInputContainer = document.createElement("div");
                                colorInputContainer.classList.add("color-input-container");

                                // Create a span to hold the unique value (centered)
                                var valueSpan = document.createElement("span");
                                valueSpan.textContent = value;
                                valueSpan.classList.add("value-span");
                                colorInputContainer.appendChild(valueSpan);

                                // Create a wrapper div for the color input
                                var inputWrapper = document.createElement("div");
                                inputWrapper.classList.add("input-wrapper");

                                // Create a color input (aligned to the right)
                                var colorInput = document.createElement("input");
                                colorInput.type = "color";
                                colorInput.id = "color_modal"; // Apply the style by setting the id
                                colorInput.name = category + "_" + value; // Use a unique name for each color input

                                // Assign specific colors for "female" and "male"
                                if (value === selectedValue1) {
                                    colorInput.value = "#F4B653"
                                } else if (value === selectedValue2) {
                                    colorInput.value = "#53D16E"
                                } else if (value.toLowerCase().includes("female")) {
                                    colorInput.value = d3.schemeSet1[7]; // Eighth color of the schemeSet1 for "female"
                                } else if (value.toLowerCase().includes("male")) {
                                    colorInput.value = d3.schemeSet1[1]; // Second color of the schemeSet1 for "male"
                                } else if (uniqueValues.size >= 4) {
                                    var colorScale = d3.scaleSequential(d3.interpolatePlasma).domain([uniqueValues.size - 1, 0]);
                                    colorInput.value = colorScale(colorIndex);
                                    colorIndex++;
                                } else {
                                    colorInput.value = d3.schemeSet1[colorIndex % d3.schemeSet1.length]; // Default to cycling through the schemeSet1 colors
                                    colorIndex++;
                                }

                                colorInput.classList.add("color-input");
                                inputWrapper.appendChild(colorInput);

                                // Add an event listener to update colorScaleValues on color change
                                colorInput.addEventListener('input', updateColorScaleValues);

                                // Add the wrapper div to the color input container
                                colorInputContainer.appendChild(inputWrapper);

                                // Add the color input container to the category container
                                categoryContainer.appendChild(colorInputContainer);

                                // Store the category information in the colorScaleValues object
                                categoryColors[value] = colorInput.value;
                            });

                            // Add the category container to the selectColorContent element
                            selectColorContent.appendChild(categoryContainer);

                            // Store the initial colors for the category
                            colorScaleValues[rowName] = categoryColors;
                        }
                    });



                    // Function to update the color scale values
                    function updateColorScaleValues() {
                        // Clear the colorScaleValues object
                        colorScaleValues = {};

                        // Iterate over each category container
                        var categoryContainers = document.querySelectorAll('.category-container');
                        categoryContainers.forEach(function (container) {
                            // Get the category name
                            var categoryName = container.querySelector('.category-label').textContent.replace(':', '').trim();

                            // Create an object to store the colors for this category
                            var categoryColors = {};

                            // Iterate over each color input container in the category container
                            var colorInputContainers = container.querySelectorAll('.color-input-container');
                            colorInputContainers.forEach(function (colorInputContainer) {
                                // Get the value and color of the color input
                                var value = colorInputContainer.querySelector('.value-span').textContent;
                                var colorInput = colorInputContainer.querySelector('.color-input');
                                var color = colorInput.value;

                                // Store the value and color in the categoryColors object
                                categoryColors[value] = color;
                            });

                            // Store the categoryColors object in the colorScaleValues object
                            colorScaleValues[categoryName] = categoryColors;
                        });
                    }

                    // Add the overlay to the body
                    document.body.appendChild(fullScreenOverlay);
                    document.body.appendChild(selectColorOverlay);
                    selectColorOverlay.appendChild(selectColorContent);

                    console.log(colorScaleValues);
                    // Add a back button to go back to the previous step
                    var backBtn = document.createElement("button");
                    backBtn.textContent = "Save";
                    backBtn.setAttribute("style", "padding: 10px; background-color: green; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer;");
                    backBtn.addEventListener("click", function () {
                        fullScreenOverlay.remove()
                        selectColorOverlay.remove();
                        selectRowBtn.disabled = false; // Enable the button once colors are confirme
                        selectRowBtn.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; opacity: 1.0;");
                        selectRowBtn2.disabled = false; // Enable the button once colors are confirmed
                        selectRowBtn2.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; opacity: 1.0;");
                        if (all_int) {
                            selectRowBtn3.disabled = false;
                            selectRowBtn3.setAttribute("style", "flex: 1; padding: 10px; background-color: #008CBA; color: white; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; white-space: pre-line; opacity: 1.0;");
                        }
                        document.body.appendChild(selectMetadataOverlay);
                    });

                    selectColorContent.appendChild(backBtn);

                    selectColorOverlay.appendChild(selectColorContent);
                    document.body.appendChild(selectColorOverlay);

                });

                // console.log(data2)
                // console.log(data1)

                selectRowBtn4.addEventListener("click", async function () {
                    chosen_statistic = 'wilcox'
                    event.stopPropagation(); // Prevent event bubbling
                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the test type modal
                    document.getElementById("testTypeModal").style.display = "block";

                    // Wait for the user to select the test type
                    testType = await new Promise((resolve) => {
                        document.getElementById("pairedTestBtn").addEventListener("click", function () {
                            document.getElementById("testTypeModal").style.display = "none";
                            resolve('paired'); // Resolve the promise with 'paired'
                        });

                        document.getElementById("unpairedTestBtn").addEventListener("click", function () {
                            document.getElementById("testTypeModal").style.display = "none";
                            resolve('unpaired'); // Resolve the promise with 'unpaired'
                        });
                    });

                    console.log("User selected test type: " + testType);

                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2

                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];

                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })

                selectRowBtn2.addEventListener("click", async function () {
                    chosen_statistic = 'limma'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];


                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })

                selectRowBtn3.addEventListener("click", async function () {
                    chosen_statistic = 'deseq2'

                    // Change CSS styles to set width to 46% for each section
                    document.getElementById("IQR").style.flex = "0 0 0%"; // Set width to 46%
                    document.getElementById("logFCHistogram").style.flex = "0 0 46%"; // Set width to 46%
                    document.getElementById("boxPlot").style.flex = "0 0 46%"; // Set width to 46%

                    document.getElementById("thresholdSlider").style.display = "none"
                    document.getElementById("thresholdValue").style.display = "none"
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];


                    // console.log(data1, data2, selectedRowIndex, selectedValue)

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });

                })


                selectRowBtn.addEventListener("click", async function () {

                    chosen_statistic = 't-test'
                    event.stopPropagation(); // Prevent event bubbling
                    var selectedRowIndex = document.querySelector('input[name="metadataRow"]:checked').value;
                    var rowData = Object.values(data2[selectedRowIndex]); // Get the values of the selected row
                    selectedRowName = rowData[0]
                    selectedVariable = selectedRowName
                    // console.log(selectedRowName)
                    first_dims = [selectedRowName]
                    var values = rowData.slice(1); // Exclude the first value (name of the row)

                    console.log("Two groups of values found:\SelectedValue 1: " + selectedValue1 + "\SelectedValue 2: " + selectedValue2);

                    // Hide the overlay
                    var selectMetadataOverlay = document.getElementById("selectMetadataOverlay");
                    if (selectMetadataOverlay) {
                        selectMetadataOverlay.style.display = "none";
                        selectMetadataOverlay.style.visibility = "hidden"; // Optional, if necessary
                        // Alternatively: $("selectMetadataOverlay").hide(); if using jQuery
                    }

                    // Show the loading overlay
                    document.getElementById("loadingOverlay").style.display = "block";

                    console.log("REMOVED")

                    await new Promise(resolve => setTimeout(resolve, 100)); // Simulating async operation

                    var selectedValue = selectedValue1; // or group2[0] depending on which group represents the selected value
                    chosen_meta1 = selectedValue1
                    chosen_meta2 = selectedValue2


                    // Show the loading // Assuming you have already obtained the selected row index and values from data2
                    var dataC = [];
                    var dataN = [];

                    // Convert function to string to create the worker
                    const workerCode = `
                        // Function to perform data transformations
                        function performDataTransformations(data1, data2, selectedRowIndex, selectedValue) {
                            var dataC = [];
                            var dataN = [];

                            // console.log(data1, data2, selectedRowIndex, selectedValue)

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the gene name from the first property of the object

                                // Create new objects for dataC and dataN
                                var newObjC = { "gene": gene };
                                var newObjN = { "gene": gene };

                                // Loop through the keys in the object and add values to newObjC and newObjN accordingly
                                for (var key in obj) {
                                    if (key !== Object.keys(obj)[0]) {
                                        // Check if the value in data2 matches the selected value
                                        if (data2[selectedRowIndex][key] === selectedValue) {
                                            newObjC[key] = obj[key]; // Add value to newObjC
                                        } else {
                                            newObjN[key] = obj[key]; // Add value to newObjN
                                        }
                                    }
                                }

                                // Push the new objects to dataC and dataN
                                dataC.push(newObjC);
                                dataN.push(newObjN);
                            }

                            // Create a new array to hold the reordered data
                            var reorderedData = [];

                            // Loop through each object in data1
                            for (var i = 0; i < data1.length; i++) {
                                var obj = data1[i];
                                var gene = obj[Object.keys(obj)[0]]; // Get the first value of the object

                                // Find the corresponding row in dataC and dataN
                                var rowDataN = dataN.find(row => row.gene === gene);
                                var rowDataC = dataC.find(row => row.gene === gene);

                                // Construct the new object with the desired structure
                                var reorderedObj = { "gene": gene };

                                // Add GSM values from dataN to reorderedObj
                                for (var key in rowDataN) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataN[key];
                                    }
                                }

                                // Add GSM values from dataC to reorderedObj
                                for (var key in rowDataC) {
                                    if (key !== "gene") { // Skip the gene key
                                        reorderedObj[key] = rowDataC[key];
                                    }
                                }

                                // Push the new object to the reorderedData array
                                reorderedData.push(reorderedObj);
                            }

                            // Now, reorderedData contains the desired structure

                            data1 = reorderedData

                            case_number = Object.keys(dataC[0]).length - 1
                            normal_number = Object.keys(dataN[0]).length - 1

                            // console.log(case_number, normal_number)

                            // console.log(Object.keys(dataC[0]).length - 1)
                            // console.log(Object.keys(dataN[0]).length - 1)

                            // Assuming you have obtained genes from data1
                            var genes = data1.map(obj => obj[Object.keys(obj)[0]]);


                            // Calculate overall mean for data1
                            var overall_mean = data1.map(obj => {
                                var values = Object.values(obj).slice(1).map(parseFloat);
                                return values.reduce((acc, val) => acc + val, 0) / values.length;
                            });

                            // Filter out rows with overall mean equal to 0
                            var ind = overall_mean.reduce((acc, val, index) => {
                                if (val === 0) {
                                    // console.log("VALUE 0");
                                    acc.push(index);
                                }
                                return acc;
                            }, []);

                            // Filter dataC, dataN, data1, and genes based on ind
                            if (ind.length > 0) {
                                dataN = dataN.filter((_, index) => !ind.includes(index));
                                dataC = dataC.filter((_, index) => !ind.includes(index));
                                data1 = data1.filter((_, index) => !ind.includes(index));
                                genes = genes.filter((_, index) => !ind.includes(index));
                            }

                            // Logarithmic transformation for dataN, dataC, and data1
                            dataN = dataN.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC = dataC.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            data1 = data1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            console.log("CIAO")

                            // Return the processed data
                            return {
                                dataC: dataC,
                                dataN: dataN,
                                data1: data1,
                                genes: genes, // Assuming genes are extracted from data1
                                case_number: case_number,
                                normal_number: normal_number
                            };
                        }

                        // Listen for messages from the main thread
                        self.addEventListener('message', function(e) {
                            // Retrieve data from the message
                            var { data1, data2, selectedRowIndex, selectedValue } = e.data;

                            // Perform data transformations
                            var result = performDataTransformations(data1, data2, selectedRowIndex, selectedValue);

                            // Send the result back to the main thread
                            postMessage(result);
                        }, false);
                    `;

                    // Create a Blob object from the worker code string
                    const blob = new Blob([workerCode], { type: 'application/javascript' });

                    // Create a URL for the blob object
                    const blobURL = URL.createObjectURL(blob);

                    // Create a new web worker from the blob URL
                    const worker = new Worker(blobURL);

                    // Promisify the web worker
                    function runWorker(worker, message) {
                        return new Promise((resolve, reject) => {
                            worker.onmessage = resolve;
                            worker.onerror = reject;
                            worker.postMessage(message);
                        });
                    }

                    // Start the data transformation process in the worker
                    runWorker(worker, {
                        data1: data1,
                        data2: data2,
                        selectedRowIndex: selectedRowIndex,
                        selectedValue: selectedValue1 // Change this to selectedValue2 if needed
                    }).then(result => {
                        console.log(result)
                        // Process the returned data
                        dataC = result.data.dataC;
                        dataN = result.data.dataN;
                        data1 = result.data.data1;
                        case_number = result.data.case_number;
                        normal_number = result.data.normal_number;
                        genes = result.data.genes;
                        // dataC, dataN, data1, genes, case_number, normal_number = result.data;

                        // Update your UI or further process the data as needed
                        console.log(dataC);
                        console.log(dataN);
                        console.log(data1);
                        console.log(genes);
                        console.log(case_number);
                        console.log(normal_number);

                        // Hide the loading overlay after all operations are complete
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();

                        // Start the next step
                        start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second_time);

                    }).catch(error => {
                        console.error('Error in web worker:', error);

                        // Hide the loading overlay on error
                        document.getElementById("loadingOverlay").style.display = "none";

                        // Terminate the web worker
                        worker.terminate();
                    });
                });
                buttonContainer.appendChild(div1);
                buttonContainer.appendChild(div2);
                buttonContainer.appendChild(div3);
                buttonContainer.appendChild(div4);

                selectMetadataContent.appendChild(selectColors);
                selectMetadataContent.appendChild(buttonContainer);
                selectMetadataOverlay.appendChild(selectMetadataContent);

            });
        }
        // Function to download data as a .txt file
        function downloadDataAsTxt(data, filename) {
            // Convert the data to a CSV format (or any desired format)
            const header = data.map(entry => Object.keys(data[0]).join("\t")).join("\n");
            const content = data.map(entry => Object.values(entry).join("\t")).join("\n");
            const csvContent = header.concat(content)
            const blob = new Blob([csvContent], { type: 'text/plain' });

            // Create a link element to trigger the download
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;

            // Append link to the body (needed for Firefox)
            document.body.appendChild(link);
            link.click();

            // Clean up and remove the link
            document.body.removeChild(link);
        }

        let differentialUpExpressedTable; // Declare the DataTable reference globally
        let differentialDownExpressedTable; // Declare the DataTable reference globally


        function start(data1, data2, selectedRowIndex, dataC, dataN, chosen_statistic, second) {
            if (second) {
                d3.select("#radioBoxContainer").html("")
                d3.select("#checkboxContainer").html("")
                d3.select("#heatmap").html("")
                d3.select("#boxPlot").html("")
                combinedData = []
                selectedGeneData = [];
                greencircles = []
                old_p_adj
                transposedData = [];
                ordering = undefined
                metadata;
                combinedData1 = []
                gsmList = []
                json = []
            }
            document.getElementById("loadingOverlay").style.display = "block";
            document.getElementById("overlay").style.display = "none";
            // Hide all elements with the ID 'selectMetadataOverlay'
            const overlays = document.querySelectorAll('#selectMetadataOverlay');
            overlays.forEach(function (overlay) {
                overlay.style.display = 'none';
            });
            document.getElementById("survivalOverlay").style.display = "none";
            updateChosenAnalysis()
            dataC_original = dataC
            dataN_original = dataN
            data_original = data1
            metadata = data2

            console.log(data_original)
            const miRNARegex = /^hsa-(let|mir|miR)/i;

            // Filter genes based on the regex
            const miRNAs = data_original.filter(entry => miRNARegex.test(entry.gene));

            // Determine dataset type
            if (miRNAs.length > 0) {
                only_miRNAs = true
            } else {
                only_miRNAs = false
            }

            document.getElementById("upregulatedtabletitle").innerText =
                only_miRNAs ? "Up-regulated miRNAs" : "Up-regulated Genes";

            document.getElementById("downregulatedtabletitle").innerText =
                only_miRNAs ? "Down-regulated miRNAs" : "Down-regulated Genes";

            console.log(miRNAs)

            document.getElementById("nav").style.display = "flex"
            document.getElementById("main_div").style.display = "flex"

            if (chosen_statistic == 'deseq2') {
                document.getElementById("thresholdSlider").style.display = "none"
                document.getElementById("thresholdValue").style.display = "none"
                // Change CSS styles to set width to 46% for each section
                document.getElementById("IQR").style.flex = "0 0 0%"; // Set width to 46%
                document.getElementById("logFCHistogram").style.flex = "0 0 46%"; // Set width to 46%
                document.getElementById("boxPlot").style.flex = "0 0 46%"; // Set width to 46%

                document.getElementById("IQR").style.display = "none"
                updateStatisticalMethod('DESeq2');

                console.log(dataC_original)
                console.log(dataN_original)

                var dataN_or = dataN_original

                var dataC_or = dataC_original
                dataN_copy = dataN_original

                dataC_copy = dataC_original
                data_copy = data_original

                console.log(dataC_or)
                console.log(dataN_or)
                var post_string = "deseq2DE"
                if (!example) {
                    post_string = "deseq2DE?no_cache=1"
                }

                var req = ocpu.call(post_string, {
                    dataC: dataC_or,  // Pass your processed case data
                    dataN: dataN_or   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    //console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            var data = data.filter(row => !isNaN(row.pval_adj));
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                entry.logFC = parseFloat(entry.logFC); // Convert string to number if necessary
                            });
                            console.log(data_original)
                            console.log(data)

                            parsedLogFC = data.map(row => ({
                                "Gene": row.Gene,
                                "logFC": row.logFC
                            }));

                            // Step 1: Create a set of Gene values from the `data` array (these are genes remaining from the thres)
                            const geneSet = new Set(data.map(entry => entry.Gene));
                            data_original.filter(entry => geneSet.has(entry.gene))
                            dataC_original.filter(entry => geneSet.has(entry.gene));
                            dataN_original.filter(entry => geneSet.has(entry.gene));

                            // Step 2: Filter `data_original` to create `data_copy1` with only matching gene values
                            data_copy1 = data_original
                            dataC_copy1 = dataC_original
                            dataN_copy1 = dataN_original;
                            parsedLogFC = parsedLogFC.filter(entry => geneSet.has(entry.Gene));

                            console.log(data_copy1);

                            // Now, data*_copy1 contains the original data filtered by deseq2DE

                            parsedLogFC_origin1 = parsedLogFC
                            parsedLogFC_origin = parsedLogFC
                            console.log(parsedLogFC)

                            //  console.log("first parsed origin after",parsedLogFC_origin.length)
                            //  console.log("first data orign afterN ",dataN_copy.length)
                            //  console.log("first data orign afterC ",dataC_copy.length)

                            // This logarithmic transformation is needed for the scatter plot
                            data_log = data_copy1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataN_log = dataN_copy1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            dataC_log = dataC_copy1.map(obj => {
                                var newObj = {};
                                for (var key in obj) {
                                    if (key !== "gene") {
                                        newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                                    }
                                }
                                newObj["gene"] = obj["gene"];
                                return newObj;
                            });

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_log);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_log);

                            // Now is time to filter out the genes using the logFC

                            // Step 1: Initialize the geneset and log threshold
                            log_thr_fc = Math.log2(2);

                            // Step 2: Create a geneset of genes to keep based on the filtering condition
                            const geneset = new Set();
                            parsedLogFC_origin.forEach(entry => {
                                if (Math.abs(entry.logFC) > Math.log2(thr_fc)) {
                                    geneset.add(entry.Gene);  // Add the gene to the set if it passes the filter
                                }
                            });

                            console.log("Number of genes passing the LOGFC filter", geneset.size);

                            // Step 3: Filter dataC_copy1, dataN_copy1, data_copy1, and parsedLogFC_origin using the geneset
                            if (geneset.size > 0) {
                                dataC_copy = dataC_copy1.filter(entry => geneset.has(entry.gene));
                                dataN_copy = dataN_copy1.filter(entry => geneset.has(entry.gene));
                                data_copy = data_copy1.filter(entry => geneset.has(entry.gene));
                                parsedLogFC = parsedLogFC_origin.filter(entry => geneset.has(entry.Gene));
                            }

                            console.log("Filtered logFC dataC_copy", dataC_copy.length);
                            console.log("Filtered logFC dataN_copy", dataN_copy.length);
                            console.log("Filtered logFC data_copy", data_copy.length);
                            console.log("Filtered logFC parsedLogFC", parsedLogFC.length);

                            updateLogFCHistogram(parsedLogFC_origin)

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data.filter(entry => geneset.has(entry.Gene))
                            deseq_p_adj = old_p_adj

                            // Step 1: Initialize the geneset and the p-value threshold
                            const geneset_pval = new Set();

                            // Step 2: Create a geneset of genes to keep based on the p-value condition
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {
                                    geneset_pval.add(entry.Gene);
                                }
                            });

                            console.log("Number of genes passing the pval_adj filter", geneset_pval.size);

                            // Step 3: Filter dataC_copy, dataN_copy, and data_copy using the geneset_pval
                            if (geneset_pval.size > 0) {

                                //console.log(parsedLogFC.length)

                                dataC_copy_pval = dataC_log.filter(entry => geneset_pval.has(entry.gene));

                                dataN_copy_pval = dataN_log.filter(entry => geneset_pval.has(entry.gene));

                                data_copy_pval = data_log.filter(entry => geneset_pval.has(entry.gene));

                                console.log("geni rimamenti dal primo filtering", data_copy.length)

                                // Remove entries corresponding to ind from logFC
                                //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                                parsedLogFC_pval = parsedLogFC.filter(entry => geneset_pval.has(entry.gene));
                                console.log(log_thr_fc)
                                console.log(parsedLogFC_origin1)
                                console.log(old_p_adj)

                                if (parsedLogFC.length == 0) {
                                    alert("No deg found!")
                                }

                                console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                console.log(sortedLogFC)

                                var mostUpregulatedGene = sortedLogFC[0];

                                var secondMostUpregulatedGene = sortedLogFC[1];

                                var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                console.log(mostUpregulatedGene)

                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }

                                // Sort the genes based on their p-values (ascending order, smallest first)
                                const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                // Get the top 5 genes with the smallest p-values
                                const top5Genes = sortedGenesByPValue.slice(0, 10);

                                // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                top5Genes.forEach(gene => {
                                    if (gene.pval_adj < 0.05) {
                                        selectedGeneData.push(gene.Gene);
                                    }
                                });

                                const selectedGeneDataSet = new Set(selectedGeneData);

                                selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed



                                // // Find the select element
                                // var selectElement = document.getElementById("selectButton");

                                // // Clear existing options
                                // selectElement.innerHTML = "";

                                // if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                //     // Add the new options dynamically
                                //     var option1 = document.createElement("option");
                                //     option1.value = mostUpregulatedGene.Gene;
                                //     option1.text = `${mostUpregulatedGene.Gene}`;
                                //     option1.selected = true;
                                //     selectElement.appendChild(option1);
                                // }

                                // if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                //     var option2 = document.createElement("option");
                                //     option2.value = mostDownregulatedGene.Gene;
                                //     option2.text = `${mostDownregulatedGene.Gene}`;
                                //     selectElement.appendChild(option2);
                                // }

                                const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                    map[gene.Gene] = gene.logFC;
                                    return map;
                                }, {});

                                const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                // Prepare data for Differential Expressed Genes
                                const geneData = sortedOldPAdj.map(gene => {
                                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                    return {
                                        Gene: gene.Gene,
                                        AdjPVal: gene.pval_adj,
                                        LogFC: logFC
                                    };
                                });

                                // Initialize the DataTable for Differential Expressed Genes
                                initializedifferentialUpExpressedTable(geneData);
                                initializedifferentialDownExpressedTable(geneData);
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj); // Call the next plot update

                                async function runVisualizations() {
                                    try {
                                        await dendo_heatmap();  // Wait until dendo_heatmap() is done
                                        miRNA_target();         // Call the next function
                                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                        if (only_miRNAs === false) {
                                            toggleView(data_copy, dataC_copy, dataN_copy)
                                            document.getElementById("buttonSwitchContainer").style.display = "none"
                                        }
                                        console.log(dataN_copy.length)
                                        var pc1Values = [];
                                        var pc2Values = [];
                                        var groupValues = [];
                                        if (data_copy_pval === undefined) {
                                            alert("No deg found!")
                                        }
                                        console.log(data_copy_pval)
                                        console.log(dataC_copy_pval)
                                        console.log(dataN_copy_pval)
                                        const geneNames = data_copy_pval.map(entry => entry.gene);
                                        const uniqueGeneNames = new Set(geneNames);

                                        if (geneNames.length !== uniqueGeneNames.size) {
                                            console.error("Duplicate gene names detected in the input data.");
                                        }
                                        console.log(data_copy_pval)

                                        // downloadDataAsTxt(data_copy_pval, 'filtered_data.txt');

                                        var pca_string = "pca"
                                        if (!example) {
                                            pca_string = "pca?no_cache=1"
                                        }

                                        if (only_miRNAs === false) {
                                            toggleView(data_copy, dataC_copy, dataN_copy)
                                            document.getElementById("buttonSwitchContainer").style.display = "none"
                                        }

                                        document.getElementById("loadingOverlay").style.display = "none"


                                    } catch (error) {
                                        console.error("Error during visualizations:", error);
                                        miRNA_target();         // Call the next function
                                        updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj); // Call the next plot update
                                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                    }
                                }

                                // Call the function that runs the visualizations
                                runVisualizations();

                                data_copy = data_log.filter(entry => geneset.has(entry.gene))
                                dataC_copy = dataC_log.filter(entry => geneset.has(entry.gene))
                                dataN_copy = dataN_log.filter(entry => geneset.has(entry.gene))

                                // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_log[0])


                                // updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                updateCounter();
                                updateUpandDown();


                            }
                        });


                })

            }
            else {
                var variation_string = "variation"
                if (!example) {
                    variation_string = "variation?no_cache=1"
                }

                var req = ocpu.call(variation_string, {
                    rawdata: data1,
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {

                            const innerData = JSON.parse(data[0]);
                            console.log(data1)

                            // Extract variation values from the inner JSON array
                            variation_data = innerData.map(obj => obj.Variation);

                            // Now you have an array of variation values, you can use it as needed
                            console.log(variation_data);
                            row_length = variation_data.length
                            initial_num_genes = row_length

                            console.log("numero di geni iniziali prima di qualsiasi filtro " + row_length)

                            thr_prc = ss.quantile(variation_data, prc_IQR);
                            updateHistogram(variation_data);
                            variation_data_copy = (variation_data);

                            const ind = variation_data_copy.reduce((result, entry, index) => {

                                if (entry < thr_prc) {
                                    result.push(index);
                                }
                                return result;
                            }, []);

                            console.log(ind)

                            if (ind.length > 0) {

                                // Remove entries corresponding to ind from dataN
                                data_copy1 = data_original.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from dataC
                                dataC_copy1 = dataC_original.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from data
                                dataN_copy1 = dataN_original.filter((entry, index) => !ind.includes(index));

                                data_original_cpy = data_copy1

                                dataC_original_cpy = dataC_copy1

                                dataN_original_cpy = dataN_copy1

                                // Remove entries corresponding to ind from genes
                                //genes = genes.filter((entry, index) => !ind.includes(index));

                                // Remove entries corresponding to ind from logFC
                                //parsedLogFC = parsedLogFC.filter((entry, index) => !ind.includes(index));

                            }
                            else {
                                // Remove entries corresponding to ind from dataN
                                data_copy1 = data_original

                                // Remove entries corresponding to ind from dataC
                                dataC_copy1 = dataC_original

                                // Remove entries corresponding to ind from data
                                dataN_copy1 = dataN_original

                                data_original_cpy = data_copy1

                                dataC_original_cpy = dataC_copy1

                                dataN_original_cpy = dataN_copy1

                            }

                            dataN_copy = dataN_copy1
                            dataC_copy = dataC_copy1
                            data_copy = data_copy1
                            console.log("geni tolti dal primo filtering del IQR", ind.length)

                            // Update the gene count display
                            // const geneCountDiv = document.getElementById('geneCount');
                            // geneCountDiv.innerHTML = `Initial number of genes: ${initial_num_genes}<br>Number of genes after filtering: ${data_copy.length}`;

                            first_filter_number_genes = data_copy.length
                            console.log(dataC_original)


                            parsedLogFC_origin1 = calculateLogFC(dataC_original, dataN_original)
                            parsedLogFC_origin = calculateLogFC(dataC_copy, dataN_copy);
                            parsedLogFC = parsedLogFC_origin
                            console.log(parsedLogFC)

                            //  console.log("first parsed origin after",parsedLogFC_origin.length)
                            //  console.log("first data orign afterN ",dataN_copy.length)
                            //  console.log("first data orign afterC ",dataC_copy.length)

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy);

                            if (parsedLogFC) {

                                // Calculate the quantile
                                log_thr_fc = Math.log2(2);
                                //console.log(log_thr_fc)
                                const ind = parsedLogFC_origin.reduce((result, entry, index) => {

                                    if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                        result.push(index);

                                    }
                                    return result;
                                }, []);
                                console.log("geni tolti dal primo filtering del LOGFC", ind.length)

                                // console.log("parsed log before ",parsedLogFC.length)
                                // console.log("data copy beforeC ",dataC_copy.length)
                                // console.log("data copy beforeN ",dataN_copy.length)

                                // console.log("parsed log origin ",parsedLogFC_origin.length)
                                /////////////////////// 

                                //DIMENSIONE DI PARSED E DATAC,DATAN SONO UGUALI , GIUSTAMENTE

                                //////////////////////
                                // console.log(parsedLogFC_origin)
                                // console.log(data_copy)
                                if (ind.length > 0) {

                                    // Remove entries corresponding to ind from dataN
                                    dataC_copy = dataC_copy1.filter((entry, index) => !ind.includes(index));

                                    // Remove entries corresponding to ind from dataN
                                    dataN_copy = dataN_copy1.filter((entry, index) => !ind.includes(index));

                                    data_copy = data_copy1.filter((entry, index) => !ind.includes(index));

                                    parsedLogFC = parsedLogFC_origin.filter((entry, index) => !ind.includes(index));
                                } else {
                                    // Remove entries corresponding to ind from dataN
                                    dataC_copy = dataC_copy1

                                    // Remove entries corresponding to ind from dataN
                                    dataN_copy = dataN_copy1

                                    data_copy = data_copy1

                                    parsedLogFC = parsedLogFC_origin

                                }

                                //////// DATI FILTRATI DAL PRIMO FOLD-CHANGE//////////////////
                                // console.log(parsedLogFC)
                                // console.log(data_copy)

                                updateLogFCHistogram(parsedLogFC_origin)

                                if (chosen_statistic == 't-test') {
                                    updateStatisticalMethod('T-test');
                                    var pval_string = "pval"
                                    if (!example) {
                                        pval_string = "pval?no_cache=1"
                                    }

                                    var req = ocpu.call(pval_string, {
                                        data: data_copy,
                                        N: normal_number,
                                        M: case_number
                                    }, function (session) {
                                        var filteredDataURL = session.loc + "/R/.val/json";
                                        //console.log(session);
                                        // Fetch the filtered data from the URL
                                        fetch(filteredDataURL)
                                            .then(response => response.json())
                                            .then(data => {
                                                console.log(session);
                                                // Convert pval_adj values back to numbers if needed
                                                data.forEach(entry => {
                                                    entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                                });

                                                old_p_adj = data
                                                const ind = old_p_adj.reduce((result, entry, index) => {

                                                    if (entry.pval_adj > threshold) {
                                                        result.push(index);
                                                    }
                                                    return result;
                                                }, []);

                                                console.log(old_p_adj)
                                                console.log(ind)


                                                const pvalGeneSet = new Set();
                                                old_p_adj.forEach(entry => {
                                                    if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                                        pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                                    }
                                                });

                                                console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                                                console.log("Threshold p-value:", threshold);

                                                dataC_copy_pval = dataC_copy;
                                                dataN_copy_pval = dataN_copy;
                                                data_copy_pval = data_copy;

                                                if (pvalGeneSet.size > 0) {
                                                    // Filter the data based on the pvalGeneSet
                                                    dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                                    dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                                    data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                                    parsedLogFC = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                                    console.log("Genes passed to box plot after p-value filter:", parsedLogFC.length);
                                                }
                                                console.log("geni tolti dal primo filtering del pval", ind.length)

                                                if (ind.length > 0 || dataC_copy_pval.length > 1) {

                                                    //console.log(parsedLogFC.length)

                                                    // Remove entries corresponding to ind from dataN

                                                    console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                    // Remove entries corresponding to ind from logFC

                                                    parsedLogFC_pval = parsedLogFC
                                                    console.log(log_thr_fc)
                                                    console.log(parsedLogFC_origin1)
                                                    console.log(old_p_adj)

                                                    if (parsedLogFC.length == 0) {
                                                        alert("No deg found!")
                                                    }

                                                    console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                    var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                    console.log(sortedLogFC)

                                                    var mostUpregulatedGene = sortedLogFC[0];
                                                    var secondMostUpregulatedGene = sortedLogFC[1];

                                                    var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                    var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                    console.log(mostUpregulatedGene)

                                                    // Function to find the adjusted p-value for a given gene
                                                    function getAdjustedPValue(geneName) {
                                                        const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                                        return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                                    }

                                                    var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                                    var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                                    // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                                    if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostUpregulatedGeneName);
                                                    }

                                                    if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostDownregulatedGeneName);
                                                    }

                                                    // Sort the genes based on their p-values (ascending order, smallest first)
                                                    const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                                    // Get the top 5 genes with the smallest p-values
                                                    const top5Genes = sortedGenesByPValue.slice(0, 10);

                                                    // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                                    top5Genes.forEach(gene => {
                                                        if (gene.pval_adj < 0.05) {
                                                            selectedGeneData.push(gene.Gene);
                                                        }
                                                    });
                                                    const selectedGeneDataSet = new Set(selectedGeneData);

                                                    selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed

                                                    const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                                        map[gene.Gene] = gene.logFC;
                                                        return map;
                                                    }, {});

                                                    const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                                    // Prepare data for Differential Expressed Genes
                                                    const geneData = sortedOldPAdj.map(gene => {
                                                        const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                                        return {
                                                            Gene: gene.Gene,
                                                            AdjPVal: gene.pval_adj,
                                                            LogFC: logFC
                                                        };
                                                    });

                                                    // Initialize the DataTable for Differential Expressed Genes
                                                    initializedifferentialUpExpressedTable(geneData);
                                                    initializedifferentialDownExpressedTable(geneData);

                                                    async function runVisualizations() {
                                                        try {
                                                            await dendo_heatmap();  // Wait until dendo_heatmap() is done
                                                            miRNA_target();         // Call the next function
                                                            updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj); // Call the next plot update
                                                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                                            console.log(dataN_copy.length)
                                                            var pc1Values = [];
                                                            var pc2Values = [];
                                                            var groupValues = [];
                                                            console.log(data_copy_pval)
                                                            var pca_string = "pca"
                                                            if (!example) {
                                                                pca_string = "pca?no_cache=1"
                                                            }

                                                            if (only_miRNAs === false) {
                                                                toggleView(data_copy, dataC_copy, dataN_copy)
                                                                document.getElementById("buttonSwitchContainer").style.display = "none"
                                                            }
                                                        } catch (error) {
                                                            console.error("Error during visualizations:", error);
                                                        }
                                                    }

                                                    // Call the function that runs the visualizations
                                                    runVisualizations();
                                                    // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)

                                                    // updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                    updateCounter();
                                                    updateUpandDown();



                                                }
                                            });


                                    })
                                }
                                else if (chosen_statistic == 'wilcox') {
                                    updateStatisticalMethod('Wilcoxon');
                                    var wilcox_string = "wilcox"
                                    if (!example) {
                                        wilcox_string = "wilcox?no_cache=1"
                                    }

                                    var req = ocpu.call(wilcox_string, {
                                        data: data_copy,
                                        N: normal_number,
                                        M: case_number,
                                        test: testType
                                    }, function (session) {
                                        var filteredDataURL = session.loc + "/R/.val/json";
                                        //console.log(session);
                                        // Fetch the filtered data from the URL
                                        fetch(filteredDataURL)
                                            .then(response => response.json())
                                            .then(data => {
                                                console.log(session);
                                                // Convert pval_adj values back to numbers if needed
                                                data.forEach(entry => {
                                                    entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                                });

                                                old_p_adj = data
                                                const ind = old_p_adj.reduce((result, entry, index) => {

                                                    if (entry.pval_adj > threshold) {
                                                        result.push(index);
                                                    }
                                                    return result;
                                                }, []);

                                                console.log(old_p_adj)
                                                console.log(ind)


                                                const pvalGeneSet = new Set();
                                                old_p_adj.forEach(entry => {
                                                    if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                                        pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                                    }
                                                });

                                                console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                                                console.log("Threshold p-value:", threshold);

                                                dataC_copy_pval = dataC_copy;
                                                dataN_copy_pval = dataN_copy;
                                                data_copy_pval = data_copy;

                                                if (pvalGeneSet.size > 0) {
                                                    // Filter the data based on the pvalGeneSet
                                                    dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                                    dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                                    data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                                    parsedLogFC = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                                    console.log("Genes passed to box plot after p-value filter:", parsedLogFC.length);
                                                }
                                                console.log("geni tolti dal primo filtering del pval", ind.length)

                                                if (ind.length > 0 || dataC_copy_pval.length > 1) {

                                                    //console.log(parsedLogFC.length)

                                                    // Remove entries corresponding to ind from dataN

                                                    console.log("geni rimamenti dal primo filtering", data_copy.length)
                                                    // Remove entries corresponding to ind from logFC

                                                    parsedLogFC_pval = parsedLogFC
                                                    console.log(log_thr_fc)
                                                    console.log(parsedLogFC_origin1)
                                                    console.log(old_p_adj)

                                                    if (parsedLogFC.length == 0) {
                                                        alert("No deg found!")
                                                    }

                                                    console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                    var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                    console.log(sortedLogFC)

                                                    var mostUpregulatedGene = sortedLogFC[0];
                                                    var secondMostUpregulatedGene = sortedLogFC[1];

                                                    var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                    var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                    console.log(mostUpregulatedGene)

                                                    // Function to find the adjusted p-value for a given gene
                                                    function getAdjustedPValue(geneName) {
                                                        const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                                        return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                                    }

                                                    var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                                    var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                                    // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                                    if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostUpregulatedGeneName);
                                                    }

                                                    if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostDownregulatedGeneName);
                                                    }

                                                    // Sort the genes based on their p-values (ascending order, smallest first)
                                                    const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                                    // Get the top 5 genes with the smallest p-values
                                                    const top5Genes = sortedGenesByPValue.slice(0, 10);

                                                    // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                                    top5Genes.forEach(gene => {
                                                        if (gene.pval_adj < 0.05) {
                                                            selectedGeneData.push(gene.Gene);
                                                        }
                                                    });
                                                    const selectedGeneDataSet = new Set(selectedGeneData);

                                                    selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed


                                                    // Find the select element
                                                    // var selectElement = document.getElementById("selectButton");

                                                    // // Clear existing options
                                                    // selectElement.innerHTML = "";

                                                    // // Add the new options dynamically
                                                    // var option1 = document.createElement("option");
                                                    // option1.value = mostUpregulatedGene.Gene;
                                                    // option1.text = `${mostUpregulatedGene.Gene}`;
                                                    // option1.selected = true;
                                                    // selectElement.appendChild(option1);

                                                    // var option2 = document.createElement("option");
                                                    // option2.value = mostDownregulatedGene.Gene;
                                                    // option2.text = `${mostDownregulatedGene.Gene}`;
                                                    // selectElement.appendChild(option2);

                                                    const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                                        map[gene.Gene] = gene.logFC;
                                                        return map;
                                                    }, {});

                                                    const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                                    // Prepare data for Differential Expressed Genes
                                                    const geneData = sortedOldPAdj.map(gene => {
                                                        const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                                        return {
                                                            Gene: gene.Gene,
                                                            AdjPVal: gene.pval_adj,
                                                            LogFC: logFC
                                                        };
                                                    });

                                                    // Initialize the DataTable for Differential Expressed Genes
                                                    initializedifferentialUpExpressedTable(geneData);
                                                    initializedifferentialDownExpressedTable(geneData);

                                                    async function runVisualizations() {
                                                        try {
                                                            await dendo_heatmap();  // Wait until dendo_heatmap() is done
                                                            miRNA_target();         // Call the next function
                                                            updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj); // Call the next plot update
                                                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                                            console.log(dataN_copy.length)
                                                            var pc1Values = [];
                                                            var pc2Values = [];
                                                            var groupValues = [];
                                                            console.log(data_copy_pval)
                                                            var pca_string = "pca"
                                                            if (!example) {
                                                                pca_string = "pca?no_cache=1"
                                                            }

                                                            if (only_miRNAs === false) {
                                                                toggleView(data_copy, dataC_copy, dataN_copy)
                                                                document.getElementById("buttonSwitchContainer").style.display = "none"
                                                            }
                                                        } catch (error) {
                                                            console.error("Error during visualizations:", error);
                                                        }
                                                    }

                                                    // Call the function that runs the visualizations
                                                    runVisualizations();
                                                    // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims)

                                                    // updateBoxPlot(mostUpregulatedGeneName, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                                                    updateCounter();
                                                    updateUpandDown();



                                                }
                                            });


                                    })
                                } else if (chosen_statistic == 'limma') {
                                    updateStatisticalMethod('limma');
                                    console.log(dataC_copy)
                                    console.log(dataN_copy)
                                    console.log(data_copy_pval)
                                    var limmaDE_string = "limmaDE"
                                    if (!example) {
                                        limmaDE_string = "limmaDE?no_cache=1"
                                    }
                                    var req = ocpu.call(limmaDE_string, {
                                        dataC: dataC_copy,  // Pass your processed case data
                                        dataN: dataN_copy   // Pass your processed normal data
                                    }, function (session) {
                                        var filteredDataURL = session.loc + "/R/.val/json";
                                        // console.log(session);
                                        // Fetch the filtered data from the URL
                                        fetch(filteredDataURL)
                                            .then(response => response.json())
                                            .then(data => {
                                                console.log(session);
                                                // Convert pval_adj values back to numbers if needed
                                                data.forEach(entry => {
                                                    entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                                                });

                                                // Rename '_row' to 'Gene'
                                                data.forEach(entry => {
                                                    if (entry.hasOwnProperty('_row')) {
                                                        entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                                        delete entry._row; // Remove '_row' property
                                                    }
                                                });

                                                old_p_adj = data
                                                old_p_adj.sort((a, b) => {
                                                    if (a.Gene < b.Gene) {
                                                        return -1;
                                                    }
                                                    if (a.Gene > b.Gene) {
                                                        return 1;
                                                    }
                                                    return 0;
                                                });

                                                const ind = old_p_adj.reduce((result, entry, index) => {

                                                    if (entry.pval_adj > threshold) {
                                                        result.push(index);
                                                    }
                                                    return result;
                                                }, []);

                                                console.log(old_p_adj)
                                                console.log(ind)

                                                console.log("geni tolti dal primo filtering del pval", ind.length)
                                                const pvalGeneSet = new Set();
                                                old_p_adj.forEach(entry => {
                                                    if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                                        pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                                    }
                                                });

                                                console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                                                console.log("Threshold p-value:", threshold);

                                                dataC_copy_pval = dataC_copy;
                                                dataN_copy_pval = dataN_copy;
                                                data_copy_pval = data_copy;

                                                if (pvalGeneSet.size > 0) {
                                                    // Filter the data based on the pvalGeneSet
                                                    dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                                    dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                                    data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                                    parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                                    console.log("Genes passed to box plot after p-value filter:", parsedLogFC_pval.length);
                                                }

                                                if (ind.length > 0 || dataC_copy_pval.length > 1) {

                                                    //console.log(parsedLogFC.length)

                                                    console.log("geni rimamenti dal primo filtering", data_copy.length)

                                                    parsedLogFC_pval = parsedLogFC
                                                    console.log(log_thr_fc)
                                                    console.log(parsedLogFC_origin1)
                                                    console.log(old_p_adj)

                                                    if (parsedLogFC.length == 0) {
                                                        alert("No deg found!")
                                                    }

                                                    console.log("Promise: al box gli passo parsedlogFC", parsedLogFC.length)

                                                    var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                                                    console.log(sortedLogFC)

                                                    var mostUpregulatedGene = sortedLogFC[0];

                                                    var secondMostUpregulatedGene = sortedLogFC[1];

                                                    var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                                                    var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                                                    console.log(mostUpregulatedGene)

                                                    // Function to find the adjusted p-value for a given gene
                                                    function getAdjustedPValue(geneName) {
                                                        const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                                        return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                                    }

                                                    var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                                    var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                                    // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                                    if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostUpregulatedGeneName);
                                                    }

                                                    if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                                        selectedGeneData.push(mostDownregulatedGeneName);
                                                    }
                                                    // Sort the genes based on their p-values (ascending order, smallest first)
                                                    const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                                    // Get the top 5 genes with the smallest p-values
                                                    const top5Genes = sortedGenesByPValue.slice(0, 10);

                                                    // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                                    top5Genes.forEach(gene => {
                                                        if (gene.pval_adj < 0.05) {
                                                            selectedGeneData.push(gene.Gene);
                                                        }
                                                    });
                                                    const selectedGeneDataSet = new Set(selectedGeneData);

                                                    selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed


                                                    // Find the select element
                                                    // var selectElement = document.getElementById("selectButton");

                                                    // // Clear existing options
                                                    // selectElement.innerHTML = "";

                                                    // // Add the new options dynamically
                                                    // var option1 = document.createElement("option");
                                                    // option1.value = mostUpregulatedGene.Gene;
                                                    // option1.text = `${mostUpregulatedGene.Gene}`;
                                                    // option1.selected = true;
                                                    // selectElement.appendChild(option1);

                                                    // var option2 = document.createElement("option");
                                                    // option2.value = mostDownregulatedGene.Gene;
                                                    // option2.text = `${mostDownregulatedGene.Gene}`;
                                                    // selectElement.appendChild(option2);

                                                    const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                                        map[gene.Gene] = gene.logFC;
                                                        return map;
                                                    }, {});

                                                    const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                                    // Prepare data for Differential Expressed Genes
                                                    const geneData = sortedOldPAdj.map(gene => {
                                                        const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                                        return {
                                                            Gene: gene.Gene,
                                                            AdjPVal: gene.pval_adj,
                                                            LogFC: logFC
                                                        };
                                                    });

                                                    // Initialize the DataTable for Differential Expressed Genes
                                                    initializedifferentialUpExpressedTable(geneData);
                                                    initializedifferentialDownExpressedTable(geneData);

                                                    async function runVisualizations() {
                                                        try {
                                                            await dendo_heatmap();  // Wait until dendo_heatmap() is done
                                                            miRNA_target();         // Call the next function
                                                            updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj); // Call the next plot update
                                                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                                            console.log(dataN_copy.length)
                                                            var pc1Values = [];
                                                            var pc2Values = [];
                                                            var groupValues = [];
                                                            console.log("PCA DATA COPY PVAL:", data_copy_pval)
                                                            var pca_string = "pca"
                                                            if (!example) {
                                                                pca_string = "pca?no_cache=1"
                                                            }
                                                            if (only_miRNAs === false) {
                                                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
                                                                toggleView(data_copy, dataC_copy, dataN_copy)
                                                                document.getElementById("buttonSwitchContainer").style.display = "none"
                                                            }

                                                            document.getElementById("loadingOverlay").style.display = "none"

                                                        } catch (error) {
                                                            console.error("Error during visualizations:", error);
                                                        }
                                                    }
                                                    // Call the function that runs the visualizations
                                                    runVisualizations();
                                                    console.log(dataN_copy_pval[0])

                                                    updateCounter();
                                                    updateUpandDown();


                                                }
                                                // DEG(data_copy_pval,parsedLogFC,old_p_adj)
                                                // var req = ocpu.call("enrichment", {
                                                //     data: data_copy
                                                //     }, function (session) {

                                                // })
                                            });


                                    })
                                } else if (chosen_statistic == 'deseq2') {
                                }


                                ///// DATI FILTRATI DAL PRIMO PVALUE, GIA' FILTRATI DAL PRIMO LOGFC, CHE ERANO GIA FILTRATI DA PRIMO IQR IN dataC_copy dataN_copy data_copy parsedLogFC ///////


                                // Calculate the quantile
                                log_thr_fc = Math.log2(thr_fc);
                            }
                            const ind2 = parsedLogFC_origin.reduce((result, entry, index) => {

                                if (Math.abs(entry.logFC) < Math.log2(thr_fc)) {
                                    result.push(index);
                                }
                                return result;
                            }, []);

                            // const geneCountDiv2 = document.getElementById('geneCount2');
                            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;


                        }).catch(err => {
                            console.error("Failed to fetch filtered data:", err);
                        });
                }).fail(function (error) {
                    console.error("OpenCPU call failed:", error);


                })
            }
        }

        function highlightHeatmapRows() {

            const indices = []

            console.log(selectedGeneData)
            d3.selectAll(".cell")
                .filter(function () {
                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                })
                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

            selectedGeneData.forEach(name => {
                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                if (index !== -1) {
                    indices.push(index); // Add the index if found
                }
            });
            console.log(indices); // Log the collected indices

            // Highlight the corresponding rows
            indices.forEach(index => {
                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                // Highlight the row labels
                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
            });

            d3.selectAll(".rnode").each(function (d) {
                // console.log(d); // Log the current data object for debugging
                if (d.data.name && d.data.name.length > 0 && selectedGeneData.includes(d.data.name[0])) {

                    d3.select(this).classed("selected", true)
                    // Select the circle of the current node (using 'this' to refer to the current DOM element)
                    // d3.select(this).select("circle")
                    //     .style("stroke", function () {
                    //         console.log(d.data.name[0])
                    //         return (selectedGeneData.includes(d.data.name[0])) ? "red" : "none"; // Set stroke color based on condition
                    //     })
                    //     .attr("r", function () {
                    //         return (selectedGeneData.includes(d.data.name[0])) ? 3.5 : 1.5; // Set radius based on condition
                    //     });
                }
            })
        }

        function dehighlightHeatmapRow(gene) {
            const indextoremove = rowLabel.indexOf(gene);

            var className = 'cr' + indextoremove; // Assuming 'cr' is the prefix for row classes
            d3.selectAll(`.${className}`).style("opacity", 0.2).classed("selected", false); // Make the cell visible

            // Highlight the row labels
            var labelClass = 'r' + indextoremove; // Assuming row labels have classes like 'r0', 'r1', etc.
            d3.selectAll(`.${labelClass}`).classed("text-highlight", false).classed("selected", false);

            d3.selectAll(".rnode").each(function (d) {
                // console.log(d); // Log the current data object for debugging
                if (d.data.name && d.data.name.length > 0 && gene === d.data.name[0]) {

                    d3.select(this).classed("selected", false)
                }
            })

            if (selectedGeneData.length === 0) {
                d3.selectAll(".cell")
                    .style("opacity", 1); // Set these cells to be semi-transparent or gray

            }
        }

        function areArraysEqualSet(arr1, arr2) {
            // Convert arrays to sets
            const set1 = new Set(arr1);
            const set2 = new Set(arr2);

            // Check if the sizes are the same
            if (set1.size !== set2.size) {
                return false; // If sizes are different, they can't be equal
            }

            // Compare elements in set1 to elements in set2
            for (let element of set1) {
                if (!set2.has(element)) {
                    return false; // If any element in set1 is not in set2, they're not equal
                }
            }

            return true; // If all elements match, the sets are equal
        }


        var filteredUpData, filteredDownData

        // Function to initialize the DataTable for up-regulated miRNAs
        function initializedifferentialUpExpressedTable(data) {

            if ($.fn.DataTable.isDataTable('#differentialUpExpressedTable')) {
                // $('#differentialUpExpressedTable tbody').off('click', 'tr');
                // Reapply selection on DataTable events (page change, sorting, filtering, etc.)
                $('#differentialUpExpressedTable').off('page.dt draw.dt');

                // Reapply selection after page change, sorting, filtering, or search with a delay
                $('#differentialUpExpressedTable').off('search.dt');

                $('#differentialUpExpressedTable tbody').off('change', 'input[type="checkbox"]')

                $('#differentialUpExpressedTable').DataTable().clear().destroy();
                $('#differentialUpExpressedTable' + " tbody").empty();
                $('#differentialUpExpressedTable' + " thead").empty();
            }

            // Filter for up-regulated miRNAs: LogFC > 0
            // Add isHighlighted property to the data
            filteredUpData = data
                .filter(item => item.LogFC > 0 && item.AdjPVal < threshold) // Filter for LogFC > 0 and AdjPVal > threshold
                .map(item => ({
                    ...item,
                    LogFC: item.LogFC.toExponential(4), // Format LogFC to exponential notation with 3 decimal places
                    AdjPVal: item.AdjPVal.toExponential(4), // Format AdjPVal (p-value) similarly
                    isHighlighted: selectedGeneData.includes(item.Gene) // Add isHighlighted field
                }));

            $.fn.dataTable.ext.order['dom-highlighted'] = function (settings, col) {
                return settings.aoData.map(function (row) {
                    // Access the raw data for the row
                    const rowData = row._aData;
                    return rowData.isHighlighted ? 1 : 0; // Use isHighlighted to determine order
                });
            };
            // Initialize the DataTable
            differentialUpExpressedTable = $('#differentialUpExpressedTable').DataTable({
                data: filteredUpData,
                columns: [
                    {
                        title: "Selected",
                        data: null, // No specific data field for the checkbox
                        render: function (data, type, row) {
                            // Create the Pretty Checkbox HTML
                            return `
                    <div class="pretty p-default p-curve p-fill ${row.isHighlighted ? 'upHighlighted' : ''}">
                        <input type="checkbox" data-gene="${row.Gene}" />
                        <div class="state">
                            <label></label>
                        </div>
                    </div>
                `;
                        },
                        orderable: true, // Enable ordering for this column
                        searchable: false, // Exclude from search functionality
                        createdCell: function (td, cellData, rowData, row, col) {
                            // No need for additional sorting logic here since we use isHighlighted directly
                        },
                        orderDataType: 'dom-highlighted' // Assign custom sorting type
                    },
                    { title: only_miRNAs ? "miRNA" : "Gene", data: "Gene" },
                    { title: "AdjPVal", data: "AdjPVal" },
                    { title: "LogFC", data: "LogFC" }
                ],
                destroy: true,
                paging: true,
                pageLength: 5,
                ordering: true,
                searching: false,
                lengthChange: false,
                order: [[0, 'desc']] // Initial ordering based on the "Selected" column
            });
            $('#differentialUpExpressedTable tbody').off('change', 'input[type="checkbox"]')

            // Add click event to each row
            $('#differentialUpExpressedTable tbody').on('change', 'input[type="checkbox"]', function () {
                const gene = $(this).data('gene');

                // Check if the gene is already in the selectedGeneData array
                const index = selectedGeneData.indexOf(gene);
                if (index === -1) {
                    // Add the gene to the selectedGeneData array and add 'selected' class to the row
                    selectedGeneData.push(gene);
                    $(this).prop('checked', false).closest('.pretty').addClass('upHighlighted'); // Add custom class for styling

                    const indices = []

                    console.log(selectedGeneData)
                    d3.selectAll(".cell")
                        .filter(function () {
                            return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                        })
                        .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                    selectedGeneData.forEach(name => {
                        const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                        if (index !== -1) {
                            indices.push(index); // Add the index if found
                        }
                    });
                    console.log(indices); // Log the collected indices

                    // Highlight the corresponding rows
                    indices.forEach(index => {
                        var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                        d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                        // Highlight the row labels
                        var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                    });

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        // d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        // d3.select(this).select("circle")
                        //     .style("stroke", null)
                        //     .attr("r", function (d) {
                        //         return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                        //     });
                    });

                } else {
                    // Remove the gene from the selectedGeneData array and remove 'selected' class from the row
                    selectedGeneData.splice(index, 1);
                    $(this).prop('checked', false).closest('.pretty').removeClass('upHighlighted'); // Add custom class for styling

                    const indextoremove = rowLabel.indexOf(gene);

                    var className = 'cr' + indextoremove; // Assuming 'cr' is the prefix for row classes
                    d3.selectAll(`.${className}`).style("opacity", 0.2).classed("selected", false); // Make the cell visible

                    // Highlight the row labels
                    var labelClass = 'r' + indextoremove; // Assuming row labels have classes like 'r0', 'r1', etc.
                    d3.selectAll(`.${labelClass}`).classed("text-highlight", false).classed("selected", false);

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        // d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        // d3.select(this).select("circle")
                        //     .style("stroke", null)
                        //     .attr("r", function (d) {
                        //         return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                        //     });
                    });

                    if (selectedGeneData.length === 0) {
                        d3.selectAll(".cell")
                            .style("opacity", 1); // Set these cells to be semi-transparent or gray
                    }
                }
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else if (currentPlot === 'scatter') {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                }

                if (ridge) updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                // Update the isHighlighted property in filteredUpData
                filteredUpData.forEach(item => {
                    item.isHighlighted = selectedGeneData.includes(item.Gene);
                });

                // Invalidate rows to refresh only the updated data
                differentialUpExpressedTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                    const rowData = this.data();
                    rowData.isHighlighted = selectedGeneData.includes(rowData.Gene);
                    this.invalidate(); // Mark the row as needing a redraw
                });

                console.log(selectedGeneData)
                console.log(selectedmiRNAs)

                console.log(areArraysEqualSet(selectedGeneData, selectedmiRNAs))

                if (!areArraysEqualSet(selectedGeneData, selectedmiRNAs) && selectedGeneData.length > 0) {
                    getInteractions.disabled = false
                }

                console.log("Selected Genes: ", selectedGeneData);  // Log the selected gene list
            });

            // // Reapply selection on DataTable events (page change, sorting, filtering, etc.)
            // $('#differentialUpExpressedTable').on('page.dt draw.dt', function () {
            //     highlightUpRows();
            // });

            // // Reapply selection after page change, sorting, filtering, or search with a delay
            // $('#differentialUpExpressedTable').on('search.dt', function () {
            //     // Use a small timeout to allow the search/sort/page to complete
            //     setTimeout(function () {
            //         highlightUpRows();  // Reapply highlighting after the table is done processing
            //     }, 100);  // Adjust delay time if necessary
            // });

        }

        // Function to highlight up-regulated rows
        function highlightUpRows() {
            // Update the isHighlighted property in filteredUpData
            filteredUpData.forEach(item => {
                item.isHighlighted = selectedGeneData.includes(item.Gene);
            });

            // Invalidate rows to refresh only the updated data
            differentialUpExpressedTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                const rowData = this.data();
                rowData.isHighlighted = selectedGeneData.includes(rowData.Gene);
                this.invalidate(); // Mark the row as needing a redraw
            });

            differentialUpExpressedTable.draw(false);

            // Iterate over all rows in the up-regulated table
            $('#differentialUpExpressedTable tbody tr').each(function () {
                const rowData = differentialUpExpressedTable.row(this).data();
                if (rowData !== undefined) {
                    const gene = rowData.Gene;

                    // Update the isHighlighted property in rowData
                    rowData.isHighlighted = selectedGeneData.includes(gene);


                    // Check if the gene is in the selectedGeneData array
                    const checkbox = $(this).find('input[type="checkbox"]');
                    if (selectedGeneData.includes(gene)) {
                        checkbox.prop('checked', false).closest('.pretty').addClass('upHighlighted'); // Add custom class for styling
                    } else {
                        checkbox.prop('checked', false).closest('.pretty').removeClass('upHighlighted'); // Add custom class for styling
                    }
                }
            });
            if (!areArraysEqualSet(selectedGeneData, selectedmiRNAs) && selectedGeneData.length > 0) {
                getInteractions.disabled = false
            }
        }


        // Function to initialize the DataTable for down-regulated miRNAs
        function initializedifferentialDownExpressedTable(data) {

            if ($.fn.DataTable.isDataTable('#differentialDownExpressedTable')) {
                // $('#differentialDownExpressedTable tbody').off('click', 'tr');
                // Reapply selection on DataTable events (page change, sorting, filtering, etc.)
                $('#differentialDownExpressedTable').off('page.dt draw.dt');

                // Reapply selection after page change, sorting, filtering, or search with a delay
                $('#differentialDownExpressedTable').off('search.dt');
                $('#differentialDownExpressedTable tbody').off('change', 'input[type="checkbox"]')

                $('#differentialDownExpressedTable').DataTable().clear().destroy();
                $('#differentialDownExpressedTable' + " tbody").empty();
                $('#differentialDownExpressedTable' + " thead").empty();
            }

            filteredDownData = data
                .filter(item => item.LogFC < 0 && item.AdjPVal < threshold) // Filter for LogFC > 0 and AdjPVal > threshold
                .map(item => ({
                    ...item,
                    LogFC: item.LogFC.toExponential(4), // Format LogFC to exponential notation with 3 decimal places
                    AdjPVal: item.AdjPVal.toExponential(4), // Format AdjPVal (p-value) similarly
                    isHighlighted: selectedGeneData.includes(item.Gene) // Add isHighlighted field
                }));

            $.fn.dataTable.ext.order['dom-highlighted'] = function (settings, col) {
                return settings.aoData.map(function (row) {
                    // Access the raw data for the row
                    const rowData = row._aData;
                    return rowData.isHighlighted ? 1 : 0; // Use isHighlighted to determine order
                });
            };

            differentialDownExpressedTable = $('#differentialDownExpressedTable').DataTable({
                data: filteredDownData,
                columns: [
                    {
                        title: "Selected",
                        data: null, // No specific data field for the checkbox
                        render: function (data, type, row) {
                            // Create the Pretty Checkbox HTML
                            return `
                    <div class="pretty p-default p-curve p-fill ${row.isHighlighted ? 'downHighlighted' : ''}">
                        <input type="checkbox" data-gene="${row.Gene}" />
                        <div class="state">
                            <label></label>
                        </div>
                    </div>
                `;
                        },
                        orderable: true, // Enable ordering for this column
                        searchable: false, // Exclude from search functionality
                        createdCell: function (td, cellData, rowData, row, col) {
                            // No need for additional sorting logic here since we use isHighlighted directly
                        },
                        orderDataType: 'dom-highlighted' // Assign custom sorting type
                    },
                    { title: only_miRNAs ? "miRNA" : "Gene", data: "Gene" },
                    { title: "AdjPVal", data: "AdjPVal" },
                    { title: "LogFC", data: "LogFC" }
                ],
                destroy: true,
                paging: true,
                pageLength: 5,
                ordering: true,
                searching: false,
                lengthChange: false,
                order: [[0, 'desc']] // Initial ordering based on the "Selected" column
            });
            $('#differentialDownExpressedTable tbody').off('change', 'input[type="checkbox"]')

            // Add click event to each row
            $('#differentialDownExpressedTable tbody').on('change', 'input[type="checkbox"]', function () {
                const gene = $(this).data('gene');

                // Check if the gene is already in the selectedGeneData array
                const index = selectedGeneData.indexOf(gene);
                if (index === -1) {
                    // Add the gene to the selectedGeneData array and add 'selected' class to the row
                    selectedGeneData.push(gene);
                    $(this).prop('checked', false).closest('.pretty').addClass('downHighlighted'); // Add custom class for styling

                    const indices = []

                    console.log(selectedGeneData)
                    d3.selectAll(".cell")
                        .filter(function () {
                            return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                        })
                        .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                    selectedGeneData.forEach(name => {
                        const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                        if (index !== -1) {
                            indices.push(index); // Add the index if found
                        }
                    });
                    console.log(indices); // Log the collected indices

                    // Highlight the corresponding rows
                    indices.forEach(index => {
                        var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                        d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                        // Highlight the row labels
                        var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                    });

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        // d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        // d3.select(this).select("circle")
                        //     .style("stroke", null)
                        //     .attr("r", function (d) {
                        //         return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                        //     });
                    });

                } else {
                    // Remove the gene from the selectedGeneData array and remove 'selected' class from the row
                    selectedGeneData.splice(index, 1);
                    $(this).prop('checked', false).closest('.pretty').removeClass('downHighlighted'); // Add custom class for styling

                    const indextoremove = rowLabel.indexOf(gene);

                    var className = 'cr' + indextoremove; // Assuming 'cr' is the prefix for row classes
                    d3.selectAll(`.${className}`).style("opacity", 0.2).classed("selected", false); // Make the cell visible

                    // Highlight the row labels
                    var labelClass = 'r' + indextoremove; // Assuming row labels have classes like 'r0', 'r1', etc.
                    d3.selectAll(`.${labelClass}`).classed("text-highlight", false).classed("selected", false);

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        // d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        // d3.select(this).select("circle")
                        //     .style("stroke", null)
                        //     .attr("r", function (d) {
                        //         return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                        //     });
                    });

                    if (selectedGeneData.length === 0) {
                        d3.selectAll(".cell")
                            .style("opacity", 1); // Set these cells to be semi-transparent or gray
                    }
                }
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else if (currentPlot === 'scatter') {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                }

                if (ridge) updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)

                // Update the isHighlighted property in filteredUpData
                filteredDownData.forEach(item => {
                    item.isHighlighted = selectedGeneData.includes(item.Gene);
                });

                // Invalidate rows to refresh only the updated data
                differentialDownExpressedTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                    const rowData = this.data();
                    rowData.isHighlighted = selectedGeneData.includes(rowData.Gene);
                    this.invalidate(); // Mark the row as needing a redraw
                });


                if (!areArraysEqualSet(selectedGeneData, selectedmiRNAs) && selectedGeneData.length > 0) {
                    getInteractions.disabled = false
                }


                console.log("Selected Genes: ", selectedGeneData);  // Log the selected gene list
            });

            // // Reapply selection on DataTable events (page change, sorting, filtering, etc.)
            // $('#differentialDownExpressedTable').on('page.dt draw.dt', function () {
            //     highlightDownRows();
            // });

            // // Reapply selection after page change, sorting, filtering, or search with a delay
            // $('#differentialDownExpressedTable').on('search.dt', function () {
            //     // Use a small timeout to allow the search/sort/page to complete
            //     setTimeout(function () {
            //         highlightDownRows();  // Reapply highlighting after the table is done processing
            //     }, 100);  // Adjust delay time if necessary
            // });

            // highlightDownRows()

        }

        // Function to highlight down-regulated rows
        function highlightDownRows() {
            // Update the isHighlighted property in filteredUpData
            filteredDownData.forEach(item => {
                item.isHighlighted = selectedGeneData.includes(item.Gene);
            });

            // Invalidate rows to refresh only the updated data
            differentialDownExpressedTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                const rowData = this.data();
                rowData.isHighlighted = selectedGeneData.includes(rowData.Gene);
                this.invalidate(); // Mark the row as needing a redraw
            });

            differentialDownExpressedTable.draw(false);

            // Iterate over all rows in the down-regulated table
            $('#differentialDownExpressedTable tbody tr').each(function () {
                const rowData = differentialDownExpressedTable.row(this).data();
                if (rowData !== undefined) {
                    const gene = rowData.Gene;

                    // Update the isHighlighted property in rowData
                    rowData.isHighlighted = selectedGeneData.includes(gene);


                    // Check if the gene is in the selectedGeneData array
                    const checkbox = $(this).find('input[type="checkbox"]');
                    if (selectedGeneData.includes(gene)) {
                        checkbox.prop('checked', false).closest('.pretty').addClass('downHighlighted'); // Add custom class for styling
                    } else {
                        checkbox.prop('checked', false).closest('.pretty').removeClass('downHighlighted'); // Add custom class for styling
                    }
                }
            });
            if (!areArraysEqualSet(selectedGeneData, selectedmiRNAs) && selectedGeneData.length > 0) {
                getInteractions.disabled = false
            }
        }



        document.getElementById("thresholdSlider").addEventListener("input", function () {
            // Update the threshold value on slider change
            prc_IQR = parseFloat(this.value);
            document.getElementById("thresholdValue").innerText = `${Math.round(prc_IQR * 100)}%`;

            // Calculate the quantile
            thr_prc = ss.quantile(variation_data_copy, prc_IQR);
            updateHistogram(variation_data);
            console.log(variation_data);

            // Step 1: Create a Set of genes that pass the IQR threshold
            const iqrGeneset = new Set();
            variation_data_copy.forEach((entry, index) => {
                if (entry >= thr_prc) {
                    iqrGeneset.add(data_original[index].gene);  // Assuming 'gene' is the key
                }
            });

            console.log("Number of genes passing the IQR filter:", iqrGeneset.size);

            dataC_copy1 = dataC_original;
            dataN_copy1 = dataN_original;
            data_copy1 = data_original;

            if (iqrGeneset.size > 0) {
                // Step 2: Filter data based on the IQR gene set
                dataC_copy1 = dataC_original.filter(entry => iqrGeneset.has(entry.gene));  // Assuming 'gene' is the key
                dataN_copy1 = dataN_original.filter(entry => iqrGeneset.has(entry.gene));
                data_copy1 = data_original.filter(entry => iqrGeneset.has(entry.gene));
            }

            first_filter_number_genes = dataC_copy1.length;

            // Step 3: Calculate the logFC after the IQR filtering
            parsedLogFC_origin = calculateLogFC(dataC_copy1, dataN_copy1);
            parsedLogFC = parsedLogFC_origin;
            updateLogFCHistogram(parsedLogFC_origin);

            // Step 4: Create a Set of genes that pass the logFC threshold
            const logFCGeneset = new Set();
            parsedLogFC_origin.forEach(entry => {
                if (Math.abs(entry.logFC) >= Math.log2(thr_fc)) {
                    logFCGeneset.add(entry.Gene);  // Assuming 'Gene' is the key
                }
            });

            console.log("Number of genes passing the logFC filter:", logFCGeneset.size);

            // Step 5: Filter data based on the logFC gene set
            dataC_copy = dataC_copy1.filter(entry => logFCGeneset.has(entry.gene));
            dataN_copy = dataN_copy1.filter(entry => logFCGeneset.has(entry.gene));
            data_copy = data_copy1.filter(entry => logFCGeneset.has(entry.gene));
            parsedLogFC = parsedLogFC_origin.filter(entry => logFCGeneset.has(entry.Gene));

            console.log("Remaining genes after logFC filtering:", data_copy.length);

            // Step 6: Update the gene count and plots
            updateCounter();
            updateUpandDown();
        });

        document.getElementById("thresholdSlider").addEventListener("change", function () {
            document.getElementById("loadingOverlay").style.display = "block";
            if (chosen_statistic == 't-test') {
                console.log("data copy in iqr prima di chiamare pval", data_copy)
                var req = ocpu.call("pval?no_cache=1", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);


                            console.log("thr pval ", threshold)
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            const pvalGeneSet = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                    pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                            console.log("Threshold p-value:", threshold);

                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneSet.size > 0) {
                                // Filter the data based on the pvalGeneSet
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC
                            }
                            console.log("geni passati a box dal IQR slider", parsedLogFC.length)

                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            } else {
                                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }


                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }
                                // Sort the genes based on their p-values (ascending order, smallest first)
                                const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                // Get the top 5 genes with the smallest p-values
                                const top5Genes = sortedGenesByPValue.slice(0, 10);

                                // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                top5Genes.forEach(gene => {
                                    if (gene.pval_adj < 0.05) {
                                        selectedGeneData.push(gene.Gene);
                                    }
                                });
                                const selectedGeneDataSet = new Set(selectedGeneData);

                                selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed


                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }
                            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                map[gene.Gene] = gene.logFC;
                                return map;
                            }, {});

                            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                            // Prepare data for Differential Expressed Genes
                            const geneData = sortedOldPAdj.map(gene => {
                                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                return {
                                    Gene: gene.Gene,
                                    AdjPVal: gene.pval_adj,
                                    LogFC: logFC
                                };
                            });

                            // Initialize the DataTable for Differential Expressed Genes
                            initializedifferentialUpExpressedTable(geneData);
                            initializedifferentialDownExpressedTable(geneData);

                            dendo_heatmap()
                            // miRNA_target()

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            if (document.getElementById('rightPanel2').style.display !== 'none') {
                                updatePCAandPC()
                                document.getElementById("loadingOverlay").style.display = "none"
                            }


                            // // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)
                            updateCounter();
                            updateUpandDown();
                            // var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            // console.log("PCA DATA COPY PVAL:", data_copy_pval)



                        });
                })

            } else if (chosen_statistic == 'wilcox') {
                console.log("data copy in iqr prima di chiamare pval", data_copy)
                var req = ocpu.call("wilcox?no_cache=1", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number,
                    test: testType
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);


                            console.log("thr pval ", threshold)
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            const pvalGeneSet = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                    pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                            console.log("Threshold p-value:", threshold);

                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneSet.size > 0) {
                                // Filter the data based on the pvalGeneSet
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC
                            }
                            console.log("geni passati a box dal IQR slider", parsedLogFC.length)

                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            } else {
                                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }


                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }
                                // Sort the genes based on their p-values (ascending order, smallest first)
                                const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                // Get the top 5 genes with the smallest p-values
                                const top5Genes = sortedGenesByPValue.slice(0, 10);

                                // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                top5Genes.forEach(gene => {
                                    if (gene.pval_adj < 0.05) {
                                        selectedGeneData.push(gene.Gene);
                                    }
                                });
                                const selectedGeneDataSet = new Set(selectedGeneData);

                                selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed


                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }
                            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                map[gene.Gene] = gene.logFC;
                                return map;
                            }, {});

                            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                            // Prepare data for Differential Expressed Genes
                            const geneData = sortedOldPAdj.map(gene => {
                                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                return {
                                    Gene: gene.Gene,
                                    AdjPVal: gene.pval_adj,
                                    LogFC: logFC
                                };
                            });

                            // Initialize the DataTable for Differential Expressed Genes
                            initializedifferentialUpExpressedTable(geneData);
                            initializedifferentialDownExpressedTable(geneData);

                            dendo_heatmap()
                            // miRNA_target()

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            if (document.getElementById('rightPanel2').style.display !== 'none') {
                                updatePCAandPC()
                                document.getElementById("loadingOverlay").style.display = "none"
                            }


                            // // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)
                            updateCounter();
                            updateUpandDown();
                            // var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            // console.log("PCA DATA COPY PVAL:", data_copy_pval)



                        });
                })

            } else if (chosen_statistic == 'limma') {
                console.log("data copy in iqr prima di chiamare limma", data_copy)
                console.log(dataC_copy)
                console.log(dataN_copy)
                var req = ocpu.call("limmaDE?no_cache=1", {
                    dataC: dataC_copy,  // Pass your processed case data
                    dataN: dataN_copy   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);



                            const pvalGeneSet = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                    pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                            console.log("Threshold p-value:", threshold);

                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneSet.size > 0) {
                                // Filter the data based on the pvalGeneSet
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                console.log("Genes passed to box plot after p-value filter:", parsedLogFC_pval.length);
                            }
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            } else {
                                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }



                            var sortedLogFC = parsedLogFC.slice().sort((a, b) => b.logFC - a.logFC);

                            var mostUpregulatedGene = sortedLogFC[0];
                            var secondMostUpregulatedGene = sortedLogFC[1];

                            var mostDownregulatedGene = sortedLogFC[sortedLogFC.length - 1];
                            var secondMostDownregulatedGene = sortedLogFC[sortedLogFC.length - 2];

                            var mostUpregulatedGeneName = mostUpregulatedGene.Gene
                            //var secondMostUpregulatedGeneName = secondMostUpregulatedGene.Gene
                            var mostDownregulatedGeneName = mostDownregulatedGene.Gene
                            //var secondMostDownregulatedGeneName = secondMostDownregulatedGene.Gene


                            genes = [mostUpregulatedGeneName, mostDownregulatedGeneName]
                            if (selectedGeneData == []) {
                                // Function to find the adjusted p-value for a given gene
                                function getAdjustedPValue(geneName) {
                                    const geneInfo = old_p_adj.find(g => g.Gene === geneName);
                                    return geneInfo ? geneInfo.pval_adj : null; // Return the p-value if the gene is found
                                }

                                var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
                                var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

                                // Check the adjusted p-values and push the genes into selectedGeneData if conditions are met
                                if (getAdjustedPValue(mostUpregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostUpregulatedGeneName);
                                }

                                if (getAdjustedPValue(mostDownregulatedGeneName) < 0.05) {
                                    selectedGeneData.push(mostDownregulatedGeneName);
                                }
                                // Sort the genes based on their p-values (ascending order, smallest first)
                                const sortedGenesByPValue = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                                // Get the top 5 genes with the smallest p-values
                                const top5Genes = sortedGenesByPValue.slice(0, 10);

                                // Push the genes into selectedGeneData if their p-value is smaller than 0.05
                                top5Genes.forEach(gene => {
                                    if (gene.pval_adj < 0.05) {
                                        selectedGeneData.push(gene.Gene);
                                    }
                                });
                                const selectedGeneDataSet = new Set(selectedGeneData);

                                selectedGeneData = Array.from(selectedGeneDataSet); // Convert Set to array if needed


                            }
                            else {
                                // Filter out genes that are not present in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });
                            }

                            console.log(selectedGeneData)

                            // Find the select element
                            // var selectElement = document.getElementById("selectButton");

                            // // Clear existing options
                            // selectElement.innerHTML = "";

                            // // Add the new options dynamically
                            // var option1 = document.createElement("option");
                            // option1.value = mostUpregulatedGene.Gene;
                            // option1.text = `${mostUpregulatedGene.Gene}`;
                            // option1.selected = true;
                            // selectElement.appendChild(option1);

                            // var option2 = document.createElement("option");
                            // option2.value = mostDownregulatedGene.Gene;
                            // option2.text = `${mostDownregulatedGene.Gene}`;
                            // selectElement.appendChild(option2);
                            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                map[gene.Gene] = gene.logFC;
                                return map;
                            }, {});

                            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                            // Prepare data for Differential Expressed Genes
                            const geneData = sortedOldPAdj.map(gene => {
                                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                return {
                                    Gene: gene.Gene,
                                    AdjPVal: gene.pval_adj,
                                    LogFC: logFC
                                };
                            });

                            // Initialize the DataTable for Differential Expressed Genes
                            initializedifferentialUpExpressedTable(geneData);
                            initializedifferentialDownExpressedTable(geneData);

                            dendo_heatmap()
                            // miRNA_target()

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }


                            //// dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy_pval, first_dims)


                            updateCounter();
                            updateUpandDown();

                            if (document.getElementById('rightPanel2').style.display !== 'none') {
                                updatePCAandPC()
                                document.getElementById("loadingOverlay").style.display = "none"
                            }

                        });
                })

            }



            // const geneCountDiv2 = document.getElementById('geneCount2');
            // geneCountDiv2.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${data_copy.length - ind2.length}`;

        });


        // Reference to the input field for the threshold value
        const thresholdInput = document.getElementById('log_thresholdSliderValue');
        const thresholdSlider = document.getElementById('log_thresholdSlider');
        var last_log_selected = 1.1

        // Make the input editable on double-click
        thresholdInput.addEventListener('dblclick', function () {
            last_log_selected = thresholdSlider.value; // Store the slider value
            this.readOnly = false;
            this.style.backgroundColor = '#fff'; // Change background to indicate edit mode
            this.style.color = "black"; // Change text color to black

            // Handle clicks outside the input field to make it non-editable
            const clickOutsideHandler = function (event) {
                if (event.target !== thresholdInput) { // Check if the click target is not the input field
                    thresholdInput.readOnly = true;
                    thresholdInput.style.backgroundColor = 'transparent'; // Return to non-edit mode
                    thresholdInput.style.color = "var(--text-color)"; // Change text color back to white

                    // Update the slider and input to the last selected value
                    thresholdSlider.value = last_log_selected;
                    thresholdInput.value = thresholdSlider.value; // Sync input with slider

                    // Trigger slider input event
                    thresholdSlider.dispatchEvent(new Event('input'));

                    // Remove the event listener after clicking outside
                    document.removeEventListener('click', clickOutsideHandler);
                }
            };

            // Add event listener for clicks outside
            document.addEventListener('click', clickOutsideHandler);
        });

        // Validate and restrict input to only float/int numbers
        thresholdInput.addEventListener('input', function () {
            const regex = /^[0-9]*[.]?[0-9]*$/; // Regex for float or int, allowing optional digits before and after the dot

            // Check if input is a valid number
            if (!regex.test(this.value)) {
                this.value = this.value.slice(0, -1); // Remove the last invalid character
            }

            const value = this.value;

            // Check if the last character is a decimal point
            const isLastCharPoint = value.endsWith('.');

            // Convert the input value to a float
            const newValue = parseFloat(value);

            // Validate the new value
            if (!isNaN(newValue) && !isLastCharPoint && newValue >= thresholdSlider.min && newValue <= thresholdSlider.max) {
                thresholdSlider.value = newValue;
                thresholdSlider.dispatchEvent(new Event('input')); // Trigger slider input event
            }
        });

        // Trigger the threshold slider's logic when the user presses "Enter"
        thresholdInput.addEventListener('keypress', function (event) {
            if (event.key === 'Enter') {
                this.readOnly = true;
                this.style.backgroundColor = 'transparent'; // Return to non-edit mode
                this.style.color = "var(--text-color)"; // Change text color back to white

                // Trigger the slider input event
                const newValue = parseFloat(this.value);
                if (!isNaN(newValue) && newValue >= thresholdSlider.min && newValue <= thresholdSlider.max) {
                    thresholdSlider.value = newValue;
                    thresholdSlider.dispatchEvent(new Event('input')); // Trigger slider input event
                    thresholdSlider.dispatchEvent(new Event('change')); // Trigger slider change event
                } else {
                    alert(`Please enter a value between ${thresholdSlider.min} and ${thresholdSlider.max}`);
                }
            }
        });

        document.getElementById("log_thresholdSlider").addEventListener("input", function () {
            // Step 1: Create a Set of genes that pass the logFC threshold
            thr_fc = parseFloat(this.value);
            thresholdInput.value = thr_fc;
            log_thr_fc = Math.log2(thr_fc);


            const geneset = new Set();
            parsedLogFC_origin.forEach(entry => {
                if (Math.abs(entry.logFC) >= log_thr_fc) {
                    geneset.add(entry.Gene);  // Add the gene to the set if it passes the filter
                }
            });

            console.log("Number of genes passing the LOGFC filter:", geneset.size);

            // Step 2: Filter dataC_copy1, dataN_copy1, data_copy1, and parsedLogFC_origin using the geneset
            if (geneset.size > 0) {
                dataC_copy = dataC_copy1.filter(entry => geneset.has(entry.gene));  // Use the 'gene' key for comparison
                dataN_copy = dataN_copy1.filter(entry => geneset.has(entry.gene));
                data_copy = data_copy1.filter(entry => geneset.has(entry.gene));
                parsedLogFC = parsedLogFC_origin.filter(entry => geneset.has(entry.Gene));  // Use the 'Gene' key for comparison
            }

            updateCounter();
            updateUpandDown();
            updateLogFCHistogram(parsedLogFC_origin);

        });

        document.getElementById("log_thresholdSlider").addEventListener("change", function () {
            last_log_selected = thr_fc
            document.getElementById("loadingOverlay").style.display = "block";
            dataC_copy_pval = dataC_copy
            dataN_copy_pval = dataN_copy
            data_copy_pval = data_copy
            updateCounter();
            updateUpandDown();

            if (chosen_statistic == 't-test') {

                var req = ocpu.call("pval?no_cache=1", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);
                            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                map[gene.Gene] = gene.logFC;
                                return map;
                            }, {});

                            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                            // Prepare data for Differential Expressed Genes
                            const geneData = sortedOldPAdj.map(gene => {
                                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                return {
                                    Gene: gene.Gene,
                                    AdjPVal: gene.pval_adj,
                                    LogFC: logFC
                                };
                            });

                            // Initialize the DataTable for Differential Expressed Genes
                            initializedifferentialUpExpressedTable(geneData);
                            initializedifferentialDownExpressedTable(geneData);


                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            const pvalGeneSet = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                    pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                            console.log("Threshold p-value:", threshold);

                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneSet.size > 0) {
                                // Filter the data based on the pvalGeneSet
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                console.log("Genes passed to box plot after p-value filter:", parsedLogFC_pval.length);
                            }
                            dendo_heatmap()
                            // miRNA_target()

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            console.log("geni con pval minore di thr nel logFC slider", ind.length)

                            if (ind.length > 0 || dataC_copy_pval.length > 1) {

                                //console.log(parsedLogFC.length)

                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                } else {
                                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });

                                console.log(selectedGeneData)

                                // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_copy.length)
                            }
                            updateCounter();
                            updateUpandDown();

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            console.log("PCA DATA COPY PVAL:", data_copy_pval)
                            if (document.getElementById('rightPanel2').style.display !== 'none') {
                                updatePCAandPC()
                                document.getElementById("loadingOverlay").style.display = "none"
                            }


                        });
                })
            } else if (chosen_statistic == 'wilcox') {

                var req = ocpu.call("wilcox?no_cache=1", {
                    data: data_copy,
                    N: normal_number,
                    M: case_number,
                    test: testType
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);
                            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                map[gene.Gene] = gene.logFC;
                                return map;
                            }, {});

                            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                            // Prepare data for Differential Expressed Genes
                            const geneData = sortedOldPAdj.map(gene => {
                                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                return {
                                    Gene: gene.Gene,
                                    AdjPVal: gene.pval_adj,
                                    LogFC: logFC
                                };
                            });

                            // Initialize the DataTable for Differential Expressed Genes
                            initializedifferentialUpExpressedTable(geneData);
                            initializedifferentialDownExpressedTable(geneData);


                            selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            const ind = old_p_adj.reduce((result, entry, index) => {

                                if (entry.pval_adj > threshold) {
                                    result.push(index);
                                }
                                return result;
                            }, []);
                            dataC_copy_pval = dataC_copy
                            dataN_copy_pval = dataN_copy
                            data_copy_pval = data_copy

                            const pvalGeneSet = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                                    pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneSet.size);
                            console.log("Threshold p-value:", threshold);

                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneSet.size > 0) {
                                // Filter the data based on the pvalGeneSet
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                                data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                                console.log("Genes passed to box plot after p-value filter:", parsedLogFC_pval.length);
                            }
                            dendo_heatmap()
                            // miRNA_target()

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            }

                            console.log("geni con pval minore di thr nel logFC slider", ind.length)

                            if (ind.length > 0 || dataC_copy_pval.length > 1) {

                                //console.log(parsedLogFC.length)

                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                } else {
                                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                selectedGeneData = selectedGeneData.filter(function (gene) {
                                    // Check if the gene is present in dataC_copy or dataN_copy
                                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                        dataN_copy.some(function (d) { return d.gene === gene; });
                                });

                                console.log(selectedGeneData)

                                // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                                console.log(dataN_copy.length)
                            }
                            updateCounter();
                            updateUpandDown();

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            console.log("PCA DATA COPY PVAL:", data_copy_pval)
                            if (document.getElementById('rightPanel2').style.display !== 'none') {
                                updatePCAandPC()
                                document.getElementById("loadingOverlay").style.display = "none"
                            }


                        });
                })
            } else if (chosen_statistic == 'limma') {
                console.log(dataC_copy)
                console.log(dataN_copy)

                var req = ocpu.call("limmaDE?no_cache=1", {
                    dataC: dataC_copy,  // Pass your processed case data
                    dataN: dataN_copy   // Pass your processed normal data
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";
                    console.log(session);
                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => response.json())
                        .then(data => {
                            console.log(session);
                            // Convert pval_adj values back to numbers if needed
                            data.forEach(entry => {
                                entry.pval_adj = parseFloat(entry.pval_adj); // Convert string to number if necessary
                            });

                            // Rename '_row' to 'Gene'
                            data.forEach(entry => {
                                if (entry.hasOwnProperty('_row')) {
                                    entry.Gene = entry._row; // Assign '_row' value to 'Gene'
                                    delete entry._row; // Remove '_row' property
                                }
                            });

                            old_p_adj = data

                            averageExpressions10C = calculateAverageLog10Expressions(dataC_copy1);
                            averageExpressions10N = calculateAverageLog10Expressions(dataN_copy1);
                            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                                map[gene.Gene] = gene.logFC;
                                return map;
                            }, {});

                            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                            // Prepare data for Differential Expressed Genes
                            const geneData = sortedOldPAdj.map(gene => {
                                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                                return {
                                    Gene: gene.Gene,
                                    AdjPVal: gene.pval_adj,
                                    LogFC: logFC
                                };
                            });

                            // Initialize the DataTable for Differential Expressed Genes
                            initializedifferentialUpExpressedTable(geneData);
                            initializedifferentialDownExpressedTable(geneData);

                            dendo_heatmap()
                            // miRNA_target()

                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } selectedGeneData = selectedGeneData.filter(function (gene) {
                                // Check if the gene is present in dataC_copy or dataN_copy
                                return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                                    dataN_copy.some(function (d) { return d.gene === gene; });
                            });

                            console.log(selectedGeneData)

                            // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                            // Step 1: Create a Set of genes that pass the p-value threshold
                            const pvalGeneset = new Set();
                            old_p_adj.forEach(entry => {
                                if (entry.pval_adj <= threshold) {
                                    pvalGeneset.add(entry.Gene);  // Assuming 'Gene' is the key
                                }
                            });

                            console.log("Number of genes passing the p-value filter:", pvalGeneset.size);

                            // Step 2: Initialize copies of the data
                            dataC_copy_pval = dataC_copy;
                            dataN_copy_pval = dataN_copy;
                            data_copy_pval = data_copy;

                            if (pvalGeneset.size > 0) {
                                // Step 3: Filter dataC_copy, dataN_copy, and data_copy using the p-value gene set
                                dataC_copy_pval = dataC_copy.filter(entry => pvalGeneset.has(entry.gene));  // Assuming 'gene' is the key
                                dataN_copy_pval = dataN_copy.filter(entry => pvalGeneset.has(entry.gene));
                                data_copy_pval = data_copy.filter(entry => pvalGeneset.has(entry.gene));

                                // Step 4: Filter parsedLogFC_pval based on the gene set
                                parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneset.has(entry.Gene));  // Assuming 'Gene' is the key

                                console.log("First gene after p-value filtering:", dataN_copy_pval[0]);

                                // Step 5: Update box plot
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                } else {
                                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }

                                // Step 6: Filter selectedGeneData based on whether genes are in dataC_copy or dataN_copy
                                selectedGeneData = selectedGeneData.filter(gene =>
                                    dataC_copy_pval.some(d => d.gene === gene) || dataN_copy_pval.some(d => d.gene === gene)
                                );

                                console.log("Selected gene data after filtering:", selectedGeneData);

                                // Step 7: Update the parallel coordinates plot
                                // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy, dataN_copy, first_dims);

                                console.log("Filtered dataN_copy length:", dataN_copy_pval.length);
                            }
                            updateCounter();
                            updateUpandDown();

                            //   var pc1Values = [];
                            // var pc2Values = [];
                            // var groupValues = [];
                            if (document.getElementById('rightPanel2').style.display !== 'none') {
                                updatePCAandPC()
                                document.getElementById("loadingOverlay").style.display = "none"
                            }


                        });
                })

            } else if (chosen_statistic == 'deseq2') {
                const geneset = new Set();
                parsedLogFC_origin.forEach(entry => {
                    if (Math.abs(entry.logFC) >= log_thr_fc) {
                        geneset.add(entry.Gene);  // Add the gene to the set if it passes the filter
                    }
                });

                console.log("Number of genes passing the LOGFC filter", geneset.size);

                // Step 3: Filter dataC_copy1, dataN_copy1, data_copy1, and parsedLogFC_origin using the geneset
                if (geneset.size > 0) {
                    dataC_copy = dataC_copy1.filter(entry => geneset.has(entry.gene));
                    dataN_copy = dataN_copy1.filter(entry => geneset.has(entry.gene));
                    data_copy = data_copy1.filter(entry => geneset.has(entry.gene));
                    parsedLogFC = parsedLogFC_origin.filter(entry => geneset.has(entry.Gene));
                    old_p_adj = deseq_p_adj.filter(entry => geneset.has(entry.Gene))
                }

                console.log(data_copy)
                console.log(parsedLogFC)
                console.log(old_p_adj)

                data_log = data_copy1.map(obj => {
                    var newObj = {};
                    for (var key in obj) {
                        if (key !== "gene") {
                            newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                        }
                    }
                    newObj["gene"] = obj["gene"];
                    return newObj;
                });

                dataN_log = dataN_copy1.map(obj => {
                    var newObj = {};
                    for (var key in obj) {
                        if (key !== "gene") {
                            newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                        }
                    }
                    newObj["gene"] = obj["gene"];
                    return newObj;
                });

                dataC_log = dataC_copy1.map(obj => {
                    var newObj = {};
                    for (var key in obj) {
                        if (key !== "gene") {
                            newObj[key] = Math.log2(parseFloat(obj[key]) + 1);
                        }
                    }
                    newObj["gene"] = obj["gene"];
                    return newObj;
                });

                averageExpressions10C = calculateAverageLog10Expressions(dataC_log);
                averageExpressions10N = calculateAverageLog10Expressions(dataN_log);
                const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                    map[gene.Gene] = gene.logFC;
                    return map;
                }, {});

                const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                // Prepare data for Differential Expressed Genes
                const geneData = sortedOldPAdj.map(gene => {
                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                    return {
                        Gene: gene.Gene,
                        AdjPVal: gene.pval_adj,
                        LogFC: logFC
                    };
                });

                // Initialize the DataTable for Differential Expressed Genes
                initializedifferentialUpExpressedTable(geneData);
                initializedifferentialDownExpressedTable(geneData);

                dendo_heatmap()
                // miRNA_target()

                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else if (currentPlot === 'scatter') {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                }
                // Step 1: Initialize the geneset and the p-value threshold
                const geneset_pval = new Set();

                // Step 2: Create a geneset of genes to keep based on the p-value condition
                old_p_adj.forEach(entry => {
                    if (entry.pval_adj <= threshold) {  // Adjust condition according to your filtering logic
                        geneset_pval.add(entry.Gene);  // Assuming 'Gene' is the property name
                    }
                });

                console.log("Number of genes passing the pval_adj filter", geneset_pval.size);

                selectedGeneData = selectedGeneData.filter(function (gene) {
                    // Check if the gene is present in dataC_copy or dataN_copy
                    return dataC_copy.some(function (d) { return d.gene === gene; }) ||
                        dataN_copy.some(function (d) { return d.gene === gene; });
                });

                console.log(selectedGeneData)

                data_copy = data_log.filter(entry => geneset.has(entry.gene))
                dataC_copy = dataC_log.filter(entry => geneset.has(entry.gene))
                dataN_copy = dataN_log.filter(entry => geneset.has(entry.gene))

                // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                const pvalGeneSet = new Set();
                old_p_adj.forEach(entry => {
                    if (entry.pval_adj <= threshold) {  // Include genes that pass the p-value filter
                        pvalGeneSet.add(entry.Gene);  // Assuming 'Gene' is the key for genes
                    }
                });

                console.log("Number of genes passing the p-value filter in the logFC slider:", pvalGeneSet.size);

                dataC_copy_pval = dataC_copy;
                dataN_copy_pval = dataN_copy;
                data_copy_pval = data_copy;

                if (pvalGeneSet.size > 0) {
                    // Filter the data based on the pvalGeneSet
                    dataC_copy_pval = dataC_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataC_copy
                    dataN_copy_pval = dataN_copy.filter(entry => pvalGeneSet.has(entry.gene));  // Assuming 'gene' is the key for dataN_copy
                    data_copy_pval = data_copy.filter(entry => pvalGeneSet.has(entry.gene));    // Assuming 'gene' is the key for data_copy
                    parsedLogFC_pval = parsedLogFC.filter(entry => pvalGeneSet.has(entry.Gene));  // Assuming 'Gene' is the key for parsedLogFC

                    console.log(dataN_copy_pval[0]);

                    if (ridge) {
                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    } else {
                        updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    }

                    // Update selectedGeneData based on the filtered data
                    selectedGeneData = selectedGeneData.filter(function (gene) {
                        // Check if the gene is present in the filtered data
                        return dataC_copy.some(d => d.gene === gene) || dataN_copy.some(d => d.gene === gene);
                    });
                }

                console.log(selectedGeneData)

                // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)

                console.log(dataN_copy.length)

                updateCounter();
                updateUpandDown();

                //   var pc1Values = [];
                // var pc2Values = [];
                // var groupValues = [];                                                
                if (document.getElementById('rightPanel2').style.display !== 'none') {
                    updatePCAandPC()
                    document.getElementById("loadingOverlay").style.display = "none"
                }


            }



            //updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            // console.log("parsed log ",parsedLogFC.length)
            // console.log("data copy beforeC ",dataC_copy.length)
            // console.log("data copy beforeN",dataN_copy.length)

            // const geneCountDiv = document.getElementById('geneCount2');
            // geneCountDiv.innerHTML = `First filtering number of genes: ${first_filter_number_genes}<br>Number of genes after filtering: ${parsedLogFC.length}`;

            // Now, dataN, dataC, data, genes, and logFC are updated
        })

        document.getElementById('thresholdSelect').addEventListener('change', function () {
            //console.log(dataC_copy)
            //console.log(data_copy)
            //console.log(dataN_copy)

            document.getElementById("loadingOverlay").style.display = "block";
            console.log("DATAC COPY PVAL", dataC_copy_pval)
            console.log("DATAC COPY ", dataC_copy)
            // dataC_copy_pval = dataC_copy
            // dataN_copy_pval = dataN_copy
            // data_copy_pval = data_copy
            // parsedLogFC_pval = parsedLogFC

            threshold = parseFloat(this.value);

            const genesToRemove = new Set();

            old_p_adj.forEach(entry => {
                if (entry.pval_adj >= threshold) {
                    genesToRemove.add(entry.Gene);
                }
            });

            console.log("Number of genes to remove:", genesToRemove.size);
            console.log(genesToRemove)

            if (currentPlot === 'volcano') {
                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } else if (currentPlot === 'scatter') {
                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } else {
                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            }            // dataN_copy_pval=dataN_copy
            // data_copy_pval=data_copy


            if (genesToRemove.size > 0) {

                //console.log(parsedLogFC.length)

                // Remove entries corresponding to ind from dataN

                // Filter out entries from data arrays directly
                // Step 2: Filter dataC_copy, dataN_copy, data_copy, and parsedLogFC using the Set
                dataC_copy_pval = dataC_copy.filter(entry => !genesToRemove.has(entry.gene));
                dataN_copy_pval = dataN_copy.filter(entry => !genesToRemove.has(entry.gene));
                data_copy_pval = data_copy.filter(entry => !genesToRemove.has(entry.gene));
                parsedLogFC_pval = parsedLogFC.filter(entry => !genesToRemove.has(entry.Gene));  // Use 'Gene' key for comparison

                updateCounter();
                updateUpandDown();

                const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                    map[gene.Gene] = gene.logFC;
                    return map;
                }, {});

                const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

                // Prepare data for Differential Expressed Genes
                const geneData = sortedOldPAdj.map(gene => {
                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                    return {
                        Gene: gene.Gene,
                        AdjPVal: gene.pval_adj,
                        LogFC: logFC
                    };
                });

                // Filter selectedGeneData to only keep genes that exist in data_copy_pval
                selectedGeneData = selectedGeneData.filter(gene => !genesToRemove.has(gene));

                // Initialize the DataTable for Differential Expressed Genes
                initializedifferentialUpExpressedTable(geneData);
                initializedifferentialDownExpressedTable(geneData);

                document.getElementById("loadingOverlay").style.display = "block"
                dendo_heatmap()
                // miRNA_target()


                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                } else {
                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }

                var pc1Values = [];
                var pc2Values = [];
                var groupValues = [];
                if (document.getElementById('rightPanel2').style.display !== 'none') {
                    updatePCAandPC()
                    document.getElementById("loadingOverlay").style.display = "none"
                }

                // downloadDataAsTxt(data_copy_pval, 'filtered_data.txt');

            } else {
                document.getElementById("loadingOverlay").style.display = "none"
            }

        })


        d3.select("#deselectGenesButton").on("click", function () {
            if (!zoomEnabled) {
                zoomEnabled = true
                document.getElementById("resetButton").style.cursor = "pointer"
                document.getElementById("resetButton").style.opacity = 1
                document.getElementById("resetButton").disabled = false
                document.getElementById("switchButton").style.cursor = "pointer"
                document.getElementById("switchButton").style.opacity = 1
                document.getElementById("switchButton").disabled = false
                document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
            }

            selectedGeneData = []
            // Find and remove the corresponding option from the select element
            // var select = document.getElementById("selectButton");
            // var options = select.options;

            // for (var i = 0; i < options.length; i++) {
            //     if (!selectedGeneData.includes(options[i].value)) {
            //         select.removeChild(options[i]);
            //     }
            // }
            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                map[gene.Gene] = gene.logFC;
                return map;
            }, {});

            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

            // Prepare data for Differential Expressed Genes
            const geneData = sortedOldPAdj.map(gene => {
                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.pval_adj,
                    LogFC: logFC
                };
            });

            // Initialize the DataTable for Differential Expressed Genes
            initializedifferentialUpExpressedTable(geneData);
            initializedifferentialDownExpressedTable(geneData);

            // miRNA_target()

            dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy, dataN_copy, first_dims);
            if (ridge) {
                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
            } else {
                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
            }
            if (currentPlot === 'volcano') {
                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } else if (currentPlot === 'scatter') {
                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } else {
                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
            } heatmap(heatmap_data)
            if (ridge) {
                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
            }

            // Iterate through each row index (from 0 to rowNumber)
            for (let index = 0; index < data_copy_pval.length; index++) {
                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", false); // Make the cell visible

                // Highlight the row labels
                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                d3.selectAll(`.${labelClass}`).classed("text-highlight", false).classed("selected", false);
            }

            d3.selectAll(".rnode").each(function (d) {
                // console.log(d); // Log the current data object for debugging

                d3.select(this).classed("selected", false)
                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                d3.select(this).select("circle")
                    .style("stroke", null)
                    .attr("r", function (d) {
                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                    });
            });
            if (document.getElementById('rightPanel2').style.display !== 'none') {
                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims, ordering)
                document.getElementById("loadingOverlay").style.display = "none"
            }

        });



        function pca(pca_data) {

            console.log(colorScaleValues)
            console.log(selectedRowName)
            console.log("update pca")
            pc1Values = []
            pc2Values = []
            pc3Values = []
            pc4Values = []
            pc5Values = []
            pc6Values = []
            groupValues = []
            smokerValues = []
            stageValues = []

            console.log(pca_data)

            // Iterate over the newData array
            pca_data.forEach(function (obj) {
                // Access pc1, pc2, and group values from each object
                var groupValue = obj.group;
                var gsmValue = obj.GSM; // Assuming GSM is a property in the object
                // Check for the existence of each principal component before adding to newObj
                if (obj.pc1 !== undefined) pc1Values.push(obj.pc1);
                if (obj.pc2 !== undefined) pc2Values.push(obj.pc2);
                if (obj.pc3 !== undefined) pc3Values.push(obj.pc3);
                if (obj.pc4 !== undefined) pc4Values.push(obj.pc4);
                if (obj.pc5 !== undefined) pc5Values.push(obj.pc5);
                if (obj.pc6 !== undefined) pc6Values.push(obj.pc6);

                groupValues.push(groupValue);

                //console.log("PC1:", pc1Value, ", PC2:", pc2Value, ", Group:", groupValue);
            });


            if (pc2Values.length === 0) {
                return;
            }

            // Define margins and calculate width and height
            var margin = { top: 20, right: 10, bottom: 50, left: 40 };
            var container = document.getElementById("pca");
            var width = container.clientWidth - margin.left - margin.right;
            var height = container.clientHeight - margin.top - margin.bottom;

            // Adjust the viewBox to include the margins
            var totalWidth = width + margin.left + margin.right;
            var totalHeight = height + margin.top + margin.bottom;

            // Create x and y scales with offsets
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(pc1Values) - 2, // Apply offset to min value
                    d3.max(pc1Values) + 2  // Apply offset to max value
                ])
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain([
                    d3.min(pc2Values) - 2, // Apply offset to min value
                    d3.max(pc2Values) + 2  // Apply offset to max value
                ])
                .range([height, 0]);

            // Create SVG container with the correct viewBox and scaling
            var svg = d3.select("#pca")
                .html("")  // Clear previous content
                .append("svg")
                .attr("viewBox", `0 0 ${totalWidth} ${totalHeight}`)  // Set viewBox for scaling
                .style("width", "100%")  // Set width to 100% of container
                .style("height", "100%")  // Set height to 100% of container
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Add circles for each data point
            svg.selectAll(".data-circle")
                .data(pca_data) // Bind data directly to the circles
                .enter().append("circle")
                .attr("class", "data-circle") // Assign the class "data-circle" to the circles
                .attr("cx", function (d) { return xScale(d.pc1); })
                .attr("cy", function (d) { return yScale(d.pc2); })
                .attr("r", 5) // Adjust the radius as needed
                .style("fill", function (d) {
                    const value = d[selectedRowName]; // Get the value for the selected row name
                    const color = colorScaleValues[selectedRowName]?.[value]; // Look up the color
                    return color ? color : "#ccc"; // Default to gray if no color is found
                })
                .attr("stroke", function (d) {
                    // Set stroke color based on presence in gsmList
                    return gsmList.includes(d.GSM) ? "black" : null;
                })
                .attr("stroke-width", function (d) {
                    // Set stroke width based on presence in gsmList
                    return gsmList.includes(d.GSM) ? null : null;
                })
                .style("opacity", function (d) {
                    // If gsmList is not empty, reduce opacity for unselected circles
                    return gsmList.length > 0 && !gsmList.includes(d.GSM) ? 0.2 : 1;
                })

            // Add x-axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            xAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            // Add y-axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            yAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Principal Component Analysis")
                .style("fill", "var(--text-color)");


            // Add X axis label
            var xAxisLabel = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .text(`PC1 (${explainedVariance[0].toFixed(2)}%)`);

            // Add Y axis label
            var yAxisLabel = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .text(`PC2 (${explainedVariance[1].toFixed(2)}%)`);


            // Define brush function
            var brush = d3.brush()
                .extent([[0, 0], [width, height]])
                .on("start", function () {
                    // Change cursor to indicate brushing
                    d3.select(".brush").style("cursor", "crosshair");
                })
                .on("brush", function () {
                    // Change cursor to indicate brushing
                    d3.select(".brush").style("cursor", "crosshair");
                })
                .on("end", brushended);

            // Append brush to SVG
            var brushGroup = svg.append("g")
                .attr("class", "brush")
                .call(brush);

            // Function to handle brushend event
            function brushended() {
                var selection = d3.event.selection; // Get the brush selection
                var selectedCircles; // Initialize variable to store selected circles

                if (!selection) {
                    // If there's no selection (brush is removed)
                    // Deselect all circles and clear the GSM list
                    selectedCircles = d3.selectAll(".data-circle").each(function () {
                        d3.select(this)
                            .attr("stroke", null) // Remove stroke
                            .attr("stroke-width", null); // Remove stroke width
                    });
                    gsmList = []; // Clear GSM list
                } else {
                    // If there's a selection, filter selected circles
                    selectedCircles = d3.selectAll(".data-circle").filter(function () {
                        var cx = d3.select(this).attr("cx"); // Get the x-coordinate of the circle
                        var cy = d3.select(this).attr("cy"); // Get the y-coordinate of the circle
                        return cx >= selection[0][0] && cx <= selection[1][0] && cy >= selection[0][1] && cy <= selection[1][1];
                    });

                    // Handle selected circles
                    selectedCircles.each(function () {
                        var circle = d3.select(this); // Select the circle
                        var circleGSM = circle.datum().GSM; // Get the GSM value associated with the circle

                        // Add circle's GSM to the list
                        if (!gsmList.includes(circleGSM)) {
                            gsmList.push(circleGSM);
                        }

                        // Select the circle visually
                        circle.attr("stroke", "black")
                            .attr("stroke-width", null)
                    });
                    // applyThemeToSVG();
                }

                // Update the opacity for all circles after brushing
                svg.selectAll(".data-circle")
                    .style("opacity", function (d) {
                        return gsmList.length > 0 && !gsmList.includes(d.GSM) ? 0.2 : 1;
                    })

                // Update parallel plot or any other function with the updated GSM list
                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);


                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                } else {
                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }

            }

            // Define maximum length for legend labels before truncating
            var maxLabelLength = 18; // You can adjust this value as needed

            var legendItems = [
                { label: chosen_meta2, color: colorScaleValues[selectedRowName]?.[chosen_meta2] },
                { label: chosen_meta1, color: colorScaleValues[selectedRowName]?.[chosen_meta1] }
            ];

            // Store previous axis selections globally
            var prevXAxisSelect = d3.select("#x-axis-select").property("value");
            var prevYAxisSelect = d3.select("#y-axis-select").property("value");

            // Function to update the plot based on selected axes
            function updatePlot() {
                var xAxisSelect = d3.select("#x-axis-select").property("value");
                var yAxisSelect = d3.select("#y-axis-select").property("value");
                if (xAxisSelect !== prevXAxisSelect || yAxisSelect !== prevYAxisSelect) {
                    var xValues = pca_data.map(d => d[xAxisSelect]);
                    var yValues = pca_data.map(d => d[yAxisSelect]);

                    // Update scales with offsets
                    xScale.domain([
                        d3.min(xValues) - 2, // Apply offset to min value
                        d3.max(xValues) + 2  // Apply offset to max value
                    ]);

                    yScale.domain([
                        d3.min(yValues) - 2, // Apply offset to min value
                        d3.max(yValues) + 2  // Apply offset to max value
                    ]);

                    // Update circles
                    var circles = svg.selectAll(".data-circle")
                        .data(pca_data);

                    circles.enter()
                        .append("circle")
                        .attr("class", "data-circle")
                        .attr("r", 5)
                        .style("fill", function (d) {
                            return d[selectedRowName] == chosen_meta1 ? d3.schemeSet1[0] : d3.schemeSet1[2];
                        })
                        .merge(circles) // Merge enter and update selection
                        .transition() // Apply transition
                        .duration(1000)
                        .attr("cx", function (d) { return xScale(d[xAxisSelect]); })
                        .attr("cy", function (d) { return yScale(d[yAxisSelect]); });

                    circles.exit().remove(); // Remove any extra circles

                    // Update axes only if they've changed
                    if (xAxisSelect !== prevXAxisSelect) {
                        // Update x-axis
                        xAxis.transition().duration(1000).call(d3.axisBottom(xScale));
                        xAxisLabel.transition() // Smooth transition for the X axis label
                            .duration(500)
                            .style("opacity", 0)  // Fade out
                            .transition()  // After fading out, update the text and fade in
                            .duration(500)
                            .style("opacity", 1)
                            .text(`${xAxisSelect.toUpperCase()} (${explainedVariance[availablePCs.indexOf(xAxisSelect)].toFixed(2)}%)`);
                    }

                    if (yAxisSelect !== prevYAxisSelect) {
                        // Update y-axis
                        yAxis.transition().duration(1000).call(d3.axisLeft(yScale));
                        yAxisLabel.transition()  // Smooth transition for the Y axis label
                            .duration(500)
                            .style("opacity", 0)  // Fade out
                            .transition()  // After fading out, update the text and fade in
                            .duration(500)
                            .style("opacity", 1)
                            .text(`${yAxisSelect.toUpperCase()} (${explainedVariance[availablePCs.indexOf(yAxisSelect)].toFixed(2)}%)`);
                    }

                    // Style ticks to be white
                    xAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                    xAxis.selectAll("text").style("fill", "var(--text-color)");

                    yAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                    yAxis.selectAll("text").style("fill", "var(--text-color)");

                }
                // Update the previous axis selections for the next update
                prevXAxisSelect = xAxisSelect;
                prevYAxisSelect = yAxisSelect;
                // applyThemeToSVG()
            }
            // Create legend group
            var legend = svg.append("g")
                .attr("class", "legend")
                .call(d3.drag()
                    .on("start", function (event) {
                        // Store initial positions and mouse offset when dragging starts
                        var transform = d3.select(this).attr("transform");
                        var match = /translate\(([^,]+),([^,]+)\)/.exec(transform);
                        // Calculate initial offset
                        this.offsetX = d3.event.x - +match[1];
                        this.offsetY = d3.event.y - +match[2];
                    })
                    .on("drag", function (event) {
                        // Use the stored offsets to update the position during dragging
                        d3.select(this).attr("transform", function () {
                            return "translate(" + (d3.event.x - this.offsetX) + "," + (d3.event.y - this.offsetY) + ")";
                        });
                    })
                )
                .attr("transform", "translate(" + 10 + "," + margin.top + ")")

            // Append legend circles and text
            legendItems.forEach(function (d, i) {
                // Append circles
                legend.append("circle")
                    .attr("class", "legend-item")
                    .attr("cx", 5)
                    .attr("cy", i * 20 + 5)
                    .attr("r", 4)
                    .style("fill", d.color);

                // Append text
                legend.append("text")
                    .attr("class", "legend-item")
                    .attr("x", 15)
                    .attr("y", i * 20 + 10)
                    .text(function () {
                        // Truncate the label if it exceeds the maximum length
                        var text = d.label;
                        if (text.length > maxLabelLength) {
                            return text.slice(0, maxLabelLength) + '...'; // Truncate and add ellipsis
                        }
                        return text;
                    })
                    .style("font-size", "12px")
                    .style("fill", "var(--text-color)")
                    .append("title") // Add tooltip with the full text
                    .text(function () { return d.label; }); // Full text for tooltip
            });

            // Calculate total height and width for the legend rectangle
            var legendHeight = legendItems.length * 20; // Height based on number of items and spacing

            // Get the maximum width of the text elements
            var longestLabelWidth = 0;
            legend.selectAll("text.legend-item").each(function () {
                var width = this.getComputedTextLength(); // Get the width of the rendered text
                longestLabelWidth = Math.max(longestLabelWidth, width); // Update longest width
            });

            // Append white transparent rectangle around the legend
            legend.append("rect")
                .attr("x", -5)
                .attr("y", -5)
                .attr("width", longestLabelWidth + 20) // Add padding to the longest label width
                .attr("height", legendHeight + 10) // Add padding to the legend height
                .style("fill", "none")
                .style("stroke", "var(--text-color)")  // Add stroke attribute
                .style("stroke-width", 1);  // Set stroke width

            // Change cursor to pointer when mouse enters the legend rectangle
            legend.on("mouseover", function (event) {
                d3.select(this).style("cursor", "move");
            });


            // Append legend circles and text
            legend.selectAll("circle.legend-item")
                .data(legendItems)
                .enter().append("circle")
                .attr("class", "legend-item")
                .attr("cx", 5) // Adjust the x-coordinate as needed
                .attr("cy", function (d, i) { return i * 20 + 5; }) // Adjust the y-coordinate as needed
                .attr("r", 4) // Adjust the radius as needed
                .style("fill", function (d) { return d.color; });




            // Add button click listener to update the plot
            d3.select("#update-plot").on("click", updatePlot);

            // applyThemeToSVG()
        }

        // function updateHistogram(variation_data) {
        //     console.log(variation_data);
        //     // Filter data based on the threshold
        //     const filteredData = variation_data.filter(variation => variation >= thr_prc);

        //     // Create histogram using D3.js
        //     const svgWidth = 600; // Width of the SVG in pixels
        //     const svgHeight = 250; // Height of the SVG in pixels
        //     const margin = { top: 20, right: 20, bottom: 40, left: 50 };
        //     const width = svgWidth - margin.left - margin.right;
        //     const height = svgHeight - margin.top - margin.bottom;

        //     const svg = d3.select("#IQR")
        //         .html("")  // Clear previous content
        //         .append("svg")
        //         .attr("width", "100%")
        //         .attr("height", "100%")
        //         .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`) // Set the viewBox for scaling
        //         .append("g")
        //         .attr("transform", `translate(${margin.left},${margin.top})`);

        //     // Create histogram
        //     const histogram = d3.histogram()
        //         .value(variation => variation)
        //         .domain(d3.extent(variation_data))
        //         .thresholds(100);

        //     const bins = histogram(variation_data);

        //     const xScale = d3.scaleLinear()
        //         .domain(d3.extent(variation_data))
        //         .range([0, width]);

        //     const yScale = d3.scaleLinear()
        //         .domain([0, d3.max(bins, d => d.length)])
        //         .range([height, 0]);

        //     // Add histogram bars
        //     svg.selectAll("rect")
        //         .data(bins)
        //         .enter()
        //         .append("rect")
        //         .attr("x", d => xScale(d.x0))
        //         .attr("y", d => yScale(d.length))
        //         .attr("width", d => xScale(d.x1) - xScale(d.x0))
        //         .attr("height", d => height - yScale(d.length))
        //         .attr("fill", d => {
        //             const thresholdPosition = xScale(thr_prc);
        //             return xScale(d.x1) < thresholdPosition ? "grey" : "#2e8b57";
        //         });

        //     // Add overlay for colored portion
        //     svg.selectAll(".overlay")
        //         .data(bins)
        //         .enter()
        //         .append("rect")
        //         .attr("class", "overlay")
        //         .attr("x", d => xScale(d.x0)) // Start the overlay from the beginning of the bar
        //         .attr("y", d => yScale(d.length))
        //         .attr("width", d => {
        //             const thresholdPosition = xScale(thr_prc);
        //             if (xScale(d.x0) < thresholdPosition && xScale(d.x1) > thresholdPosition) {
        //                 return thresholdPosition - xScale(d.x0); // Only color the left portion
        //             } else {
        //                 return 0; // Set width to 0 for bars where threshold is not in range
        //             }
        //         })
        //         .attr("height", d => height - yScale(d.length))
        //         .attr("fill", "grey") // Color the left portion of the overlay
        //         .attr("opacity", 1); // Set opacity for transparency

        //     // Add x-axis
        //     const xAxis = svg.append("g")
        //         .attr("transform", `translate(0,${height})`)
        //         .call(d3.axisBottom(xScale));

        //     xAxis.selectAll("line, path").style("stroke", "var(--text-color)");
        //     xAxis.selectAll("text").style("fill", "var(--text-color)");

        //     // Add y-axis
        //     const yAxis = svg.append("g")
        //         .call(d3.axisLeft(yScale));

        //     yAxis.selectAll("line, path").style("stroke", "var(--text-color)");
        //     yAxis.selectAll("text").style("fill", "var(--text-color)");

        //     // Add X axis label
        //     svg.append("text")
        //         .attr("x", width / 2)
        //         .attr("y", height + margin.bottom - 10)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "14px")
        //         .style("fill", "var(--text-color)")
        //         .text("IQR value");

        //     // Add Y axis label
        //     svg.append("text")
        //         .attr("transform", "rotate(-90)")
        //         .attr("x", -height / 2)
        //         .attr("y", -margin.left + 12)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "14px")
        //         .style("fill", "var(--text-color)")
        //         .text("Frequency");

        //     // Add title
        //     svg.append("text")
        //         .attr("x", width / 2)
        //         .attr("y", -margin.top * 0.1)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "18px")
        //         .style("fill", "var(--text-color)")
        //         .text("IQR Frequency distribution");

        //     // Add a red line indicating the threshold
        //     const thresholdLine = svg.append("line")
        //         .attr("y1", 0)
        //         .attr("y2", height)
        //         .attr("stroke", "darkred")
        //         .attr("stroke-width", 2);

        //     // Update the position of the threshold line
        //     thresholdLine.attr("x1", xScale(thr_prc))
        //         .attr("x2", xScale(thr_prc));

        //     // Create a legend
        //     const legend = svg.append("g")
        //         .attr("transform", `translate(${width - 150},20)`);

        //     // Add a filter for the shadow
        //     const defs = svg.append("defs");
        //     const filter = defs.append("filter")
        //         .attr("id", "legendShadow")
        //         .attr("height", "150%");

        //     filter.append("feGaussianBlur")
        //         .attr("in", "SourceAlpha")
        //         .attr("stdDeviation", 3)
        //         .attr("result", "blur");

        //     filter.append("feOffset")
        //         .attr("in", "blur")
        //         .attr("dx", 3)
        //         .attr("dy", 3)
        //         .attr("result", "offsetBlur");

        //     const feMerge = filter.append("feMerge");
        //     feMerge.append("feMergeNode").attr("in", "offsetBlur");
        //     feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        //     // Add a rectangle around the legend with shadow
        //     const legendRect = legend.append("rect")
        //         .attr("x", 5)  // Adjusted x-coordinate to provide some padding
        //         .attr("y", 5)  // Adjusted y-coordinate to provide some padding
        //         .attr("width", 140)  // Adjusted width to encapsulate the legend content
        //         .attr("height", 70)  // Adjusted height to encapsulate the legend content
        //         .style("stroke", "var(--text-color)")  // Border color
        //         .style("fill", "none")  // No fill for the rectangle
        //         .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

        //     // Add Remaining genes
        //     legend.append("rect")
        //         .attr("x", 10)
        //         .attr("y", 10)
        //         .attr("width", 10)
        //         .attr("height", 10)
        //         .style("fill", "#2e8b57");

        //     legend.append("text")
        //         .attr("x", 30)
        //         .attr("y", 18)
        //         .text("Remaining genes")
        //         .attr("text-anchor", "left")
        //         .style("fill", "var(--text-color)")
        //         .style("alignment-baseline", "middle");

        //     // Add Filtered genes
        //     legend.append("rect")
        //         .attr("x", 10)
        //         .attr("y", 35)
        //         .attr("width", 10)
        //         .attr("height", 10)
        //         .style("fill", "grey");

        //     legend.append("text")
        //         .attr("x", 30)
        //         .attr("y", 45)
        //         .text("Filtered genes")
        //         .attr("text-anchor", "left")
        //         .style("fill", "var(--text-color)")
        //         .style("alignment-baseline", "middle");

        //     applyThemeToSVG()
        // }

        function updateHistogram(variation_data) {
            // Filter data based on threshold
            const filteredData = variation_data.filter(variation => variation >= thr_prc);

            // SVG setup
            const svgWidth = 600;
            const svgHeight = 250;
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            const svg = d3.select("#IQR")
                .html("")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
                .style("max-height", "350px")
                .style("max-width", "650px")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Define x and y scales
            const xScale = d3.scaleLinear()
                .domain(d3.extent(variation_data))
                .range([0, width]);

            const kde = kernelDensityEstimator(kernelEpanechnikov(0.1), xScale.ticks(500));
            const density = kde(variation_data);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(density, d => d[1])])
                .range([height, 0]);

            // Define the area generator for the entire density
            const area = d3.area()
                .x(d => xScale(d[0]))
                .y0(height)  // Start the area at the bottom of the SVG
                .y1(d => yScale(d[1]));  // Go up to the density value

            // Append the filled area path for the entire density
            svg.append("path")
                .datum(density)
                .attr("fill", "#2e8b57")
                .attr("opacity", 0.8)
                .attr("d", area);  // Use area generator here

            // Append the filled area path for the left side of the threshold
            const leftArea = d3.area()
                .x(d => xScale(d[0]))
                .y0(height)
                .y1(d => yScale(d[1]));

            svg.append("path")
                .datum(density.filter(d => d[0] <= thr_prc))  // Filter for left side only
                .attr("fill", "grey")  // Fill color for left area
                .attr("opacity", 1)  // Adjust opacity if needed
                .attr("d", leftArea);

            // Optional: Add an outline to the path
            svg.append("path")
                .datum(density)
                .attr("stroke", "green")
                .attr("fill", "none")  // Ensure outline path has no fill
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()  // Use line generator for the outline
                    .x(d => xScale(d[0]))
                    .y(d => yScale(d[1]))
                );

            // Calculate the density height at the threshold
            const thresholdDensity = density.find(d => Math.abs(d[0] - thr_prc) < 0.01); // Finds the closest density point to thr_prc
            const thresholdHeight = thresholdDensity ? yScale(thresholdDensity[1]) : height;

            // Add threshold line with dynamic height
            svg.append("line")
                .attr("x1", xScale(thr_prc))
                .attr("x2", xScale(thr_prc))
                .attr("y1", thresholdHeight) // Match the height of the density
                .attr("y2", height)
                .attr("stroke", "darkred")
                .attr("stroke-width", 2);


            // Add x-axis
            const xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line").style("stroke", "var(--text-color)");
            xAxis.selectAll("text").style("fill", "var(--text-color)");

            // Add y-axis
            const yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line").style("stroke", "var(--text-color)");
            yAxis.selectAll("text").style("fill", "var(--text-color)");

            // Axis Labels and Title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .text("IQR value");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .text("Density");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "var(--text-color)")
                .text("IQR Density Distribution");


            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width - 120}, ${0})`);

            legend.append("rect")
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", "#2e8b57");

            legend.append("text")
                .attr("x", 15)
                .attr("y", 5)
                .attr("dy", ".35em")
                .style("font-size", "15px")
                .style("fill", "var(--text-color)")
                .text("Genes Retained");

            legend.append("rect")
                .attr("y", 30)
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", "grey");

            legend.append("text")
                .attr("x", 15)
                .attr("y", 35)
                .attr("dy", ".35em")
                .style("font-size", "15px")
                .style("fill", "var(--text-color)")
                .text("Genes Removed");

            // applyThemeToSVG();
        }

        // function updateLogFCHistogram(logFCData) {
        //     // Extract logFC values and convert them to numbers
        //     const logFCValues = logFCData.map(entry => entry.logFC);

        //     // Define histogram parameters
        //     const svgWidth = 600;
        //     const svgHeight = 250;
        //     const margin = { top: 30, right: 20, bottom: 40, left: 50 };
        //     const width = svgWidth - margin.left - margin.right;
        //     const height = svgHeight - margin.top - margin.bottom;

        //     // Create SVG container
        //     const svg = d3.select("#logFCHistogram")
        //         .html("")  // Clear previous content
        //         .append("svg")
        //         .attr("width", "100%")
        //         .attr("height", "100%")
        //         .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`) // Set the viewBox for scaling
        //         .append("g")
        //         .attr("transform", `translate(${margin.left},${margin.top})`);

        //     // Create histogram using D3.js
        //     const histogram = d3.histogram()
        //         .value(d => d)
        //         .domain(d3.extent(logFCValues))
        //         .thresholds(100); // Number of bins

        //     const bins = histogram(logFCValues);

        //     const xScale = d3.scaleLinear()
        //         .domain(d3.extent(logFCValues))
        //         .nice()
        //         .range([0, width]);

        //     const yScale = d3.scaleLinear()
        //         .domain([0, d3.max(bins, d => d.length)])
        //         .nice()
        //         .range([height, 0]);

        //     // Add histogram bars
        //     svg.selectAll("rect")
        //         .data(bins)
        //         .enter()
        //         .append("rect")
        //         .attr("x", d => xScale(d.x0))
        //         .attr("y", d => yScale(d.length))
        //         .attr("width", d => xScale(d.x1) - xScale(d.x0))
        //         .attr("height", d => height - yScale(d.length))
        //         .attr("fill", "gold");

        //     // Add x-axis
        //     var xAxis = svg.append("g")
        //         .attr("transform", `translate(0,${height})`)
        //         .call(d3.axisBottom(xScale))
        //     xAxis.selectAll("line, path")
        //         .style("stroke", "var(--text-color)");
        //     xAxis.selectAll("text")
        //         .style("fill", "var(--text-color)");
        //     // .append("text")
        //     // .attr("x", width / 2)
        //     // .attr("y", margin.bottom * 0.8)
        //     // .attr("text-anchor", "middle")
        //     // .text("logFC");


        //     // Add y-axis
        //     var yAxis = svg.append("g")
        //         .call(d3.axisLeft(yScale))
        //     // .append("text")
        //     // .attr("transform", "rotate(-90)")
        //     // .attr("y", -margin.left * 0.7)
        //     // .attr("x", -height / 2)
        //     // .attr("text-anchor", "middle")
        //     // .text("frequency");

        //     yAxis.selectAll("line, path")
        //         .style("stroke", "var(--text-color)");

        //     yAxis.selectAll("text")
        //         .style("fill", "var(--text-color)");

        //     // Add X axis label
        //     svg.append("text")
        //         .attr("x", width / 2)
        //         .attr("y", height + margin.bottom - 10)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "14px")
        //         .style("fill", "var(--text-color)")
        //         .text("Log fold change");

        //     // Add Y axis label
        //     svg.append("text")
        //         .attr("transform", "rotate(-90)")
        //         .attr("x", -height / 2)
        //         .attr("y", -margin.left + 12)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "14px")
        //         .style("fill", "var(--text-color)")
        //         .text("Frequency");



        //     // Add title
        //     svg.append("text")
        //         .attr("x", width / 2)
        //         .attr("y", -margin.top * 0.1)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "18px")
        //         .style("fill", "var(--text-color)")
        //         .text("FC (logarithmic) frequency distribution");

        //     // Add ablines
        //     svg.append("line")
        //         .attr("x1", xScale(-Math.log2(thr_fc)))
        //         .attr("y1", 0)
        //         .attr("x2", xScale(-Math.log2(thr_fc)))
        //         .attr("y2", height)
        //         .style("stroke", "darkred")
        //         .style("stroke-width", "2");

        //     svg.append("line")
        //         .attr("x1", xScale(Math.log2(thr_fc)))
        //         .attr("y1", 0)
        //         .attr("x2", xScale(Math.log2(thr_fc)))
        //         .attr("y2", height)
        //         .style("stroke", "darkred")
        //         .style("stroke-width", "2");

        //     // Add overlay for colored portion
        //     svg.selectAll(".overlay")
        //         .data(bins)
        //         .enter()
        //         .append("rect")
        //         .attr("class", "overlay")
        //         .attr("x", d => {
        //             const thresholdPosition = xScale(-Math.log2(thr_fc)); // Position of the left abline
        //             return thresholdPosition < xScale(d.x0) ? xScale(d.x0) : thresholdPosition; // Start the overlay from the greater of the two positions
        //         })
        //         .attr("y", d => yScale(d.length)) // Start from the bottom of each bin
        //         .attr("width", d => {
        //             const thresholdPositionLeft = xScale(-Math.log2(thr_fc)); // Position of the left abline
        //             const thresholdPositionRight = xScale(Math.log2(thr_fc)); // Position of the right abline
        //             const barWidth = xScale(d.x1) - xScale(d.x0);
        //             // Calculate the width of the portion to color
        //             return Math.max(0, Math.min(thresholdPositionRight, xScale(d.x1)) - Math.max(thresholdPositionLeft, xScale(d.x0)));
        //         })
        //         .attr("height", d => height - yScale(d.length)) // Set the height based on the height of each bin
        //         .attr("fill", "grey") // Color the portion of the overlay
        //         .attr("opacity", 1); // Set opacity for transparency


        //     // Create a legend
        //     var legend = svg.append("g")
        //         .attr("transform", "translate(" + (width - 150) + "," + 20 + ")");

        //     // Add a filter for the shadow
        //     var defs = svg.append("defs");

        //     var filter = defs.append("filter")
        //         .attr("id", "legendShadow")
        //         .attr("height", "150%");

        //     filter.append("feGaussianBlur")
        //         .attr("in", "SourceAlpha")
        //         .attr("stdDeviation", 3)
        //         .attr("result", "blur");

        //     filter.append("feOffset")
        //         .attr("in", "blur")
        //         .attr("dx", 3)
        //         .attr("dy", 3)
        //         .attr("result", "offsetBlur");

        //     var feMerge = filter.append("feMerge");

        //     feMerge.append("feMergeNode")
        //         .attr("in", "offsetBlur");
        //     feMerge.append("feMergeNode")
        //         .attr("in", "SourceGraphic");

        //     // Add a rectangle around the legend with shadow
        //     var legendRect = legend.append("rect")
        //         .attr("x", 5)  // Adjusted x-coordinate to provide some padding
        //         .attr("y", 5)  // Adjusted y-coordinate to provide some padding
        //         .attr("width", 140)  // Adjusted width to encapsulate the legend content
        //         .attr("height", 70)  // Adjusted height to encapsulate the legend content
        //         .style("stroke", "var(--text-color)")  // Border color
        //         .style("fill", "none")  // No fill for the rectangle
        //         .style("filter", "url(#legendShadow)");  // Apply the drop shadow filter

        //     // Add Remaining genes
        //     legend.append("rect")
        //         .attr("x", 10)
        //         .attr("y", 10)
        //         .attr("width", 10)
        //         .attr("height", 10)
        //         .style("fill", "gold");

        //     legend.append("text")
        //         .attr("x", 30)
        //         .attr("y", 18)
        //         .text("Remaining genes")
        //         .attr("text-anchor", "left")
        //         .style("fill", "var(--text-color)")
        //         .style("alignment-baseline", "middle");

        //     // Add Filtered genes
        //     legend.append("rect")
        //         .attr("x", 10)
        //         .attr("y", 35)
        //         .attr("width", 10)
        //         .attr("height", 10)
        //         .style("fill", "grey");

        //     legend.append("text")
        //         .attr("x", 30)
        //         .attr("y", 45)
        //         .text("Filtered genes")
        //         .attr("text-anchor", "left")
        //         .style("fill", "var(--text-color)")
        //         .style("alignment-baseline", "middle");

        //     applyThemeToSVG()

        // }


        function updateLogFCHistogram(logFCData) {
            // Extract logFC values and convert them to numbers
            const logFCValues = logFCData.map(entry => entry.logFC);

            // SVG setup
            const svgWidth = 600;
            const svgHeight = 250;
            const margin = { top: 30, right: 20, bottom: 40, left: 50 };
            const width = svgWidth - margin.left - margin.right;
            const height = svgHeight - margin.top - margin.bottom;

            const svg = d3.select("#logFCHistogram")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
                .style("max-height", "350px")
                .style("max-width", "650px")
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Define x and y scales
            const xScale = d3.scaleLinear()
                .domain(d3.extent(logFCValues))
                .range([0, width]);

            const kde = kernelDensityEstimator(kernelEpanechnikov(0.1), xScale.ticks(500));
            const density = kde(logFCValues);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(density, d => d[1])])
                .range([height, 0]);

            // Define the area generator for the entire density
            const area = d3.area()
                .x(d => xScale(d[0]))
                .y0(height)  // Start the area at the bottom of the SVG
                .y1(d => yScale(d[1]));  // Go up to the density value

            // Append the filled area path for the entire density
            svg.append("path")
                .datum(density)
                .attr("fill", "gold")
                .attr("opacity", 0.8)
                .attr("d", area);  // Use area generator here

            // Append the filled area path for the region between thresholds
            const betweenArea = d3.area()
                .x(d => xScale(d[0]))
                .y0(height)
                .y1(d => yScale(d[1]));

            svg.append("path")
                .datum(density.filter(d => d[0] >= -Math.log2(thr_fc) && d[0] <= Math.log2(thr_fc)))  // Filter for the area between thresholds
                .attr("fill", "grey")  // Fill color for area between thresholds
                .attr("opacity", 1)  // Adjust opacity if needed
                .attr("d", betweenArea);

            // Optional: Add an outline to the path
            svg.append("path")
                .datum(density)
                .attr("stroke", "green")
                .attr("fill", "none")  // Ensure outline path has no fill
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()  // Use line generator for the outline
                    .x(d => xScale(d[0]))
                    .y(d => yScale(d[1]))
                );

            // Find density values at the threshold positions
            const negativeThresholdDensity = density.find(d => d[0] >= -Math.log2(thr_fc));
            const positiveThresholdDensity = density.find(d => d[0] >= Math.log2(thr_fc));

            // Add threshold lines for logFC
            svg.append("line")
                .attr("x1", xScale(-Math.log2(thr_fc)))
                .attr("x2", xScale(-Math.log2(thr_fc)))
                .attr("y1", height)  // Start from the bottom
                .attr("y2", yScale(negativeThresholdDensity ? negativeThresholdDensity[1] : 0))
                .attr("stroke", "darkred")
                .attr("stroke-width", 2);

            svg.append("line")
                .attr("x1", xScale(Math.log2(thr_fc)))
                .attr("x2", xScale(Math.log2(thr_fc)))
                .attr("y1", height)  // Start from the bottom
                .attr("y2", yScale(positiveThresholdDensity ? positiveThresholdDensity[1] : 0))
                .attr("stroke", "darkred")
                .attr("stroke-width", 2);

            // // Add threshold lines for logFC (no height difference)
            // svg.append("line")
            //     .attr("x1", xScale(-Math.log2(thr_fc)))
            //     .attr("x2", xScale(-Math.log2(thr_fc)))
            //     .attr("y1", 0)
            //     .attr("y2", height)
            //     .attr("stroke", "darkred")
            //     .attr("stroke-width", 2);

            // svg.append("line")
            //     .attr("x1", xScale(Math.log2(thr_fc)))
            //     .attr("x2", xScale(Math.log2(thr_fc)))
            //     .attr("y1", 0)
            //     .attr("y2", height)
            //     .attr("stroke", "darkred")
            //     .attr("stroke-width", 2);


            // Add titles and axes
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .text("Log fold change");

            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 12)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .text("Density");

            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            yAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            // Add X axis
            var xAxis = svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            xAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -margin.top * 0.1)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("fill", "var(--text-color)")
                .text("LogFC Density Distribution");


            // Add legend
            const legend = svg.append("g")
                .attr("transform", `translate(${width - 120}, ${0})`);

            legend.append("rect")
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", "gold");

            legend.append("text")
                .attr("x", 15)
                .attr("y", 5)
                .attr("dy", ".35em")
                .style("font-size", "15px")
                .style("fill", "var(--text-color)")
                .text("Genes Retained");

            legend.append("rect")
                .attr("y", 30)
                .attr("width", 10)
                .attr("height", 10)
                .attr("fill", "grey");

            legend.append("text")
                .attr("x", 15)
                .attr("y", 35)
                .attr("dy", ".35em")
                .style("font-size", "15px")
                .style("fill", "var(--text-color)")
                .text("Genes Removed");

            // Call theme application function
            // applyThemeToSVG();
        }

        function updateVolcanoPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;


            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;
                var A = logFCObj ? logFCObj.A : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type, meanExpr: A };
            });

            console.log(data);

            // Set up margin, width, and height
            var margin = { top: 60, right: 40, bottom: 40, left: 50 };
            // var width = 1000 - margin.left - margin.right;
            // var height = 600 - margin.top - margin.bottom;

            var width = document.getElementById("scatterPlot").clientWidth - margin.left - margin.right;
            var height = document.getElementById("scatterPlot").clientHeight - margin.top - margin.bottom;


            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // Set the viewBox for scaling
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("preserveAspectRatio", "xMidYMin")
                .style("max-height", "650px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain([
                    d3.min(data, d => d.logFC) - 0.5,
                    d3.max(data, d => d.logFC) + 0.5
                ])
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20))) + 2])
                .range([height, 0])
                .nice();

            // Add X axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            xAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            yAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Add X axis label with logarithmic notation
            xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

            // Add Y axis label with logarithmic notation
            ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                .style("fill", "var(--text-color)");

            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Volcano Plot")
                .style("fill", "var(--text-color)");

            // Create circles for each gene
            var tooltip = d3.select("#tooltip");

            svg.select("#scatter").selectAll("*").remove();

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + -(10) + "," + -(60) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "#C14A82")
                .classed("legend-circle", true);

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("LogFC > log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") and</tspan>");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(350," + 0 + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "#1A74D5")
                .classed("legend-circle", true);

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("LogFC < -log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") and</tspan>");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(165," + 0 + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "lightgrey")
                .style("opacity", "0.5")
                .classed("legend-circle", true);

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("|LogFC| < log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") or</tspan>");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj > " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle


            var circles = scatter.selectAll("circle")
                .data(data);

            // Enter new circles
            circles.enter().append("circle")
                .attr("cx", function (d) {
                    if (d.pval_adj !== null) {
                        return xScale(d.logFC)
                    }
                })
                .attr("cy", function (d) {
                    if (d.pval_adj !== null) {
                        return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                    }
                })
                .attr("r", function (d) {
                    if (selectedGeneData.length > 0) {
                        return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                    }
                    else {
                        return "2";
                    }
                })
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .style("opacity", function (d) {
                    if (selectedGeneData.length > 0) {
                        return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                    }
                    else {
                        if (d.pval_adj < threshold) {
                            if (d.logFC >= log_thr_fc) {
                                return 1; // Upregulated
                            } else if (d.logFC <= -log_thr_fc) {
                                return 1; // Downregulated
                            } else {
                                return 0.5; // Not significant
                            }
                        } else {
                            return 0.3; // Not significant
                        }
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .on("mouseover", function (d) {
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", .9);

                    tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with lightgrey
                    if (currentFill === "lightgrey") {
                        return; // If lightgrey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                    if (isHighlighted) {
                        // If already highlighted, remove the highlighting
                        // selectedElement.style("fill", d => {
                        //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                        //         return "#C14A82";
                        //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                        //         return "#1A74D5";
                        //     } else {
                        //         return "lightgrey";
                        //     }
                        // })
                        selectedElement.style("opacity", d => {
                            return 0.3
                        })
                            .attr("r", 2)

                        // .classed('pulse', false)
                        // .classed("pulse1", false);

                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        if (selectedGeneData.length === 0) {
                            scatter.selectAll("circle").style("opacity", d => {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }

                            })
                        }

                        // Find and remove the corresponding option from the select element
                        // var select = document.getElementById("selectButton");
                        // var options = select.options;

                        // for (var i = 0; i < options.length; i++) {
                        //     if (!selectedGeneData.includes(options[i].value)) {
                        //         select.removeChild(options[i]);
                        //         break; // Exit the loop once the option is removed
                        //     }
                        // }
                        heatmap(heatmap_data)
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        dehighlightHeatmapRow(d.gene)
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    } else {
                        if (selectedGeneData.length === 0) {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3;
                            })
                        }
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("opacity", "1")
                            .attr("r", "4")
                        // .classed('pulse', true)
                        // .classed('pulse1', false)

                        console.log(d)

                        // Find the corresponding scatterplot circle and toggle its selection
                        // var correspondingSquare = square
                        //     .filter(function (squaredata) {
                        //         return squaredata.gene === d.gene;
                        //     });

                        // correspondingSquare.style("stroke", "none");

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        // var select = document.getElementById("selectButton");

                        // // Add new options for the genes in selectedGeneData that are not already in the select element
                        // selectedGeneData.forEach(function (gene) {
                        //     if (!Array.from(select.options).some(option => option.value === gene)) {
                        //         var option = document.createElement("option");
                        //         option.value = gene;
                        //         option.text = gene;
                        //         select.appendChild(option);
                        //     }
                        // });
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        // synchronizeAnimations(this);
                        heatmap(heatmap_data)
                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        highlightHeatmapRows()
                    }
                    // miRNA_target()
                    highlightUpRows()
                    highlightDownRows()

                })


            // Update existing circles with transition
            circles.transition()
                .duration(750)
                .attr("cx", function (d) {
                    if (d.pval_adj !== null) {
                        return xScale(d.logFC)
                    }
                })
                .attr("cy", function (d) {
                    if (d.pval_adj !== null) {
                        return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                    }
                })
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .style("opacity", function (d) {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "1"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "1"; // Downregulated
                        } else {
                            return "0.5"; // Not significant
                        }
                    } else {
                        return "0.5"; // Not significant
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .attr("r", 2);

            // Exit old circles
            circles.exit()
                .transition()
                .duration(750)
                .attr("r", 0)
                .remove();

            // Variables to store the brush extents in the original data space
            let leftBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]
            let rightBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            let brushedGenesLeft = [];
            let brushedGenesRight = [];

            // Define brush for the left side (x < 0)
            var brushLeft = d3.brush()
                .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                .on("end", updateBrushLeft);

            // Define brush for the right side (x > 0)
            var brushRight = d3.brush()
                .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                .on("end", updateBrushRight);

            var brushLeftG
            var brushRightG
            // To get the current scale
            var currentXScale = xScale; // This will give you the reference to the xScale
            var currentYScale = yScale

            // Functions to handle brush events
            function updateBrushLeft() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for left brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    leftBrushExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d => {
                        return (
                            d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                            -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                        );
                    });
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesLeft.push(point.gene);
                        }
                    });
                    console.log("Brushed genes left", brushedGenesLeft)
                    highlightSelectedGenes(selectedPoints);
                } else {
                    console.log("Brushed genes left", brushedGenesLeft)
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }

                            }
                        });
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    if (ridge) {
                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    }
                    highlightUpRows()
                    highlightDownRows()

                    brushedGenesLeft = []
                    leftBrushExtent = null; // Reset if there's no selection
                }
            }

            function updateBrushRight() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for right brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    rightBrushExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d => {
                        return (
                            d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                            -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                        );
                    });
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesRight.push(point.gene);
                        }
                    });
                    console.log("Brushed genes right", brushedGenesRight)
                    highlightSelectedGenes(selectedPoints);
                } else {
                    console.log("Brushed genes right", brushedGenesRight)
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }

                            }
                        });
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    if (ridge) {
                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    }
                    highlightUpRows()
                    highlightDownRows()

                    brushedGenesRight = []
                    rightBrushExtent = null; // Reset if there's no selection
                }
            }


            // Function to highlight the selected genes based on the brush
            function highlightSelectedGenes(selectedPoints) {
                if (selectedGeneData.length > 0) {
                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                        .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .each(function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (!isHighlighted) {

                                scatter.selectAll("circle")
                                    .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                    .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")

                                console.log(d)


                            }
                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                        });


                }
                else {
                    scatter.selectAll("circle").style("opacity", d => {
                        return 0.3; // Not significant
                    })

                    // Select all circles and filter only those that are in the selected points
                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .each(function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // If not highlighted, apply the highlighting
                            selectedElement
                                .style("opacity", "1")
                                .attr("r", "4")

                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                        });
                }

                if (selectedPoints.length >= 1) {
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                }
                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }
                console.log(selectedGeneData)
                highlightUpRows()
                highlightDownRows()

            }

            // Set the zoom and pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart)
                .on("end", function () {
                })

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach click event to the reset button
            d3.select("#resetButton").on("click", resetZoom);

            // Attach click event to the toggle zoom button
            d3.select("#toggleZoomButton").on("click", function () {
                zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                if (zoomEnabled) {
                    document.getElementById("resetButton").style.cursor = "pointer"
                    document.getElementById("resetButton").style.opacity = 1
                    document.getElementById("resetButton").disabled = false
                    document.getElementById("switchButton").style.cursor = "pointer"
                    document.getElementById("switchButton").style.opacity = 1
                    document.getElementById("switchButton").disabled = false
                    document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                    svg.call(zoom); // Re-enable zooming

                    brushLeftG.remove();
                    brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    const indices = []

                    console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                    console.log(selectedGeneData)
                    d3.selectAll(".cell")
                        .filter(function () {
                            return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                        })
                        .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                    selectedGeneData.forEach(name => {
                        const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                        if (index !== -1) {
                            indices.push(index); // Add the index if found
                        }
                    });
                    console.log(indices); // Log the collected indices

                    // Highlight the corresponding rows
                    indices.forEach(index => {
                        var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                        d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                        // Highlight the row labels
                        var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                    });

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        d3.select(this).select("circle")
                            .style("stroke", null)
                            .attr("r", function (d) {
                                return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                            });
                    });

                } else {
                    document.getElementById("resetButton").style.cursor = "not-allowed"
                    document.getElementById("resetButton").style.opacity = 0.6
                    document.getElementById("resetButton").disabled = true
                    document.getElementById("switchButton").style.cursor = "not-allowed"
                    document.getElementById("switchButton").style.opacity = 0.6
                    document.getElementById("switchButton").disabled = true

                    document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                    svg.on(".zoom", null); // Disable zooming by removing the zoom event

                    // Remove the brushes from the SVG

                    // Optionally, you can update the brush extents
                    brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                    brushRight.extent([[currentXScale(0), 0], [width, height]]);

                    // Redraw brushes to reflect new zoom scale
                    brushLeftG = svg.append("g")
                        .attr("class", "brush-left")
                        .call(brushLeft);

                    brushRightG = svg.append("g")
                        .attr("class", "brush-right")
                        .call(brushRight);

                    brushedGenesLeft = []
                    brushedGenesRight = []

                }
            });
            // Updating the chart after zooming
            function updateChart() {
                if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                // Recover the new scale
                var t = d3.event.transform;
                newX = t.rescaleX(xScale);
                newY = t.rescaleY(yScale);
                currentXScale = newX; // Update the reference
                currentYScale = newY; // Update the reference

                // xScale = newX
                // yScale = newY

                // Update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                xAxis.selectAll("text").style("fill", "var(--text-color)");

                yAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                yAxis.selectAll("text").style("fill", "var(--text-color)");

                // Update circle position
                scatter.selectAll("circle")
                    .attr('cx', function (d) {
                        if (d.pval_adj !== null) return newX(d.logFC);
                    })
                    .attr('cy', function (d) {
                        if (d.pval_adj !== null) return newY(-Math.log10(d.pval_adj));
                    });

                // Update the brush extents
                brushLeft.extent([[0, 0], [newX(0), height]]);
                brushRight.extent([[newX(0), 0], [width, height]]);

                if (!zoomEnabled) {
                    // Redraw brushes to reflect new zoom scale
                    brushLeftG.call(brushLeft);
                    brushRightG.call(brushRight);
                }
            }

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);

                if (leftBrushExtent) {
                    brushLeftG.call(brushLeft.move, [
                        [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                        [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                    ]);
                }
                if (rightBrushExtent) {
                    brushRightG.call(brushRight.move, [
                        [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                        [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                    ]);
                }
            }

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Synchronize the current time of the animation with the target animation
                    if (currentAnimation) {
                        currentAnimation.currentTime = targetTime;
                    }
                });
            }

            function findAnimByName(targetElement, animationName) {
                // Retrieve all the animations associated with the target element
                const animations = targetElement.getAnimations();

                // Find the animation object for the 'pulse' animation
                return animations.find(animation => animation.animationName === animationName);
            }
            let brushScatterG
            let brushedGenesScatter = [];

            // Variables to store the brush extents in the original data space
            let brushScatterExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            // Define brush for the left side (x < 0)
            var brushScatter



            function SwitchingPlot(structure, choice) {
                // applyThemeToSVG()
                if (choice == "volcano") {
                    if (brushScatterG) brushScatterG.remove()
                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))]);

                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    brushLeft = d3.brush()
                        .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                        .on("end", updateBrushLeft);

                    brushRight = d3.brush()
                        .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                        .on("end", updateBrushRight);

                    var brushLeftG
                    var brushRightG

                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart1);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "var(--text-color)");


                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    // Remove existing circles
                    dot.exit().remove();


                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })


                    // Functions to handle brush events
                    function updateBrushLeft() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            leftBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesLeft.push(point.gene);
                                }
                            });
                            console.log("Brushed genes left", brushedGenesLeft)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes left", brushedGenesLeft)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.style("opacity") === "1";

                                    if (isHighlighted) {
                                        selectedElement.style("opacity", d => {
                                            return 0.3
                                        })
                                            .attr("r", 2)

                                        // .classed('pulse', false)
                                        // .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        if (selectedGeneData.length === 0) {
                                            scatter.selectAll("circle").style("opacity", d => {
                                                if (d.pval_adj < threshold) {
                                                    if (d.logFC >= log_thr_fc) {
                                                        return 1; // Upregulated
                                                    } else if (d.logFC <= -log_thr_fc) {
                                                        return 1; // Downregulated
                                                    } else {
                                                        return 0.5; // Not significant
                                                    }
                                                } else {
                                                    return 0.5; // Not significant
                                                }

                                            })
                                        }

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesLeft = []
                            leftBrushExtent = null; // Reset if there's no selection
                        }
                    }

                    function updateBrushRight() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for right brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            rightBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesRight.push(point.gene);
                                }
                            });
                            console.log("Brushed genes right", brushedGenesRight)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes right", brushedGenesRight)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.style("opacity") === "1";

                                    if (isHighlighted) {
                                        selectedElement.style("opacity", d => {
                                            return 0.3
                                        })
                                            .attr("r", 2)

                                        // .classed('pulse', false)
                                        // .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        if (selectedGeneData.length === 0) {
                                            scatter.selectAll("circle").style("opacity", d => {
                                                if (d.pval_adj < threshold) {
                                                    if (d.logFC >= log_thr_fc) {
                                                        return 1; // Upregulated
                                                    } else if (d.logFC <= -log_thr_fc) {
                                                        return 1; // Downregulated
                                                    } else {
                                                        return 0.5; // Not significant
                                                    }
                                                } else {
                                                    return 0.5; // Not significant
                                                }

                                            })
                                        }


                                    }
                                });
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesRight = []
                            rightBrushExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }


                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false
                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushLeftG.remove();
                            brushRightG.remove();
                            brushedGenesLeft = []
                            brushedGenesRight = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                            brushRight.extent([[currentXScale(0), 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushLeftG = svg.append("g")
                                .attr("class", "brush-left")
                                .call(brushLeft);

                            brushRightG = svg.append("g")
                                .attr("class", "brush-right")
                                .call(brushRight);

                            brushedGenesLeft = []
                            brushedGenesRight = []

                        }
                    });
                    // Updating the chart after zooming
                    function updateChart1() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                        // Recover the new scale
                        var t = d3.event.transform;
                        newX = t.rescaleX(xScale);
                        newY = t.rescaleY(yScale);
                        currentXScale = newX; // Update the reference
                        currentYScale = newY; // Update the reference

                        // xScale = newX
                        // yScale = newY

                        // Update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                        xAxis.selectAll("text").style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                        yAxis.selectAll("text").style("fill", "var(--text-color)");

                        // Update circle position
                        scatter.selectAll("circle")
                            .attr('cx', function (d) {
                                if (d.pval_adj !== null) return newX(d.logFC);
                            })
                            .attr('cy', function (d) {
                                if (d.pval_adj !== null) return newY(-Math.log10(d.pval_adj));
                            });

                        // Update the brush extents
                        brushLeft.extent([[0, 0], [newX(0), height]]);
                        brushRight.extent([[newX(0), 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            brushLeftG.call(brushLeft);
                            brushRightG.call(brushRight);
                        }

                    }

                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (leftBrushExtent) {
                        //     brushLeftG.call(brushLeft.move, [
                        //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                        //     ]);
                        // }
                        // if (rightBrushExtent) {
                        //     brushRightG.call(brushRight.move, [
                        //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                        //     ]);
                        // }
                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "var(--text-color)");
                }

                else if (choice == "scatter") {
                    if (brushLeftG) brushLeftG.remove()
                    if (brushRightG) brushRightG.remove()
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()
                    //console.log(yScale);

                    var currentXScale = xScale
                    var currentYScale = yScale
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart1);
                    svg.call(zoom)

                    // if (brushScatterExtent) {
                    //     brushScatterG.call(brushScatter.move, [
                    //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                    //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                    //     ]);
                    // }


                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "var(--text-color)");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                        .style("fill", "var(--text-color)");

                    //svg.select("#scatter").selectAll("*").remove();

                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);


                    // Remove existing circles
                    // dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                                    d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "#C14A82";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "#1A74D5";
                                            } else {
                                                return "lightgrey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }
                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });

                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart1() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        xAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        yAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.Normal); })
                            .attr('cy', function (d) { return newY(d.Case); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }



                } else {
                    if (brushLeftG) brushLeftG.remove();
                    if (brushRightG) brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    // Create x and y scales
                    xScale = d3.scaleLinear()
                        .domain([d3.min(data, d => d.meanExpr) - 0.5, d3.max(data, d => d.meanExpr) + 0.5])
                        .range([0, width]);

                    yScale = d3.scaleLinear()
                        .domain([d3.min(data, d => d.logFC) - 0.5, d3.max(data, d => d.logFC) + 0.5])
                        .range([height, 0]);

                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    //console.log(yScale);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })


                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("MA Plot")
                        .style("fill", "var(--text-color)");

                    xlab.html("")
                    ylab.html("")

                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("Mean Expression (Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>)</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>Fold Change</tspan>")
                        .style("fill", "var(--text-color)");


                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)

                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            return xScale(d.meanExpr);
                        })
                        .attr("cy", function (d) {
                            return yScale(d.logFC);
                        })
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })


                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.meanExpr >= brushScatterExtent[0][0] && d.meanExpr <= brushScatterExtent[1][0] &&
                                    d.logFC <= brushScatterExtent[0][1] && d.logFC >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "#C14A82";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "#1A74D5";
                                            } else {
                                                return "lightgrey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }
                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });
                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        xAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        yAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.meanExpr); })
                            .attr('cy', function (d) { return newY(d.logFC); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }





                }

                // applyThemeToSVG()
            }



            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else if (currentPlot === 'scatter') {
                    currentPlot = 'ma';
                    SwitchingPlot(data, currentPlot)
                }
                else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });

            //dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
            // applyThemeToSVG()
        }

        function updateMAPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;
                var A = logFCObj ? logFCObj.A : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type, meanExpr: A };
            });

            var margin = { top: 60, right: 40, bottom: 40, left: 50 };
            // var width = 1000 - margin.left - margin.right;
            // var height = 600 - margin.top - margin.bottom;

            var width = document.getElementById("scatterPlot").clientWidth - margin.left - margin.right;
            var height = document.getElementById("scatterPlot").clientHeight - margin.top - margin.bottom;


            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // Set the viewBox for scaling
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("preserveAspectRatio", "xMidYMin")
                .style("max-height", "650px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain([d3.min(data, d => d.meanExpr) - 0.5, d3.max(data, d => d.meanExpr) + 0.5])
                .range([0, width]);

            var yScale = d3.scaleLinear()
                .domain([d3.min(data, d => d.logFC) - 0.5, d3.max(data, d => d.logFC) + 0.5])
                .range([height, 0]);

            // Add X axis
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale));

            xAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            xAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale));

            yAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            yAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            // Customization

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Set the zoom and Pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")  // Set pointer-events to "all" here
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            // Attach click event to the reset button
            d3.select("#resetButton")
                .on("click", resetZoom);

            // Add X axis label
            var xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .html("Mean Expression (Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>)</tspan>");

            // Add Y axis label
            var ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>Fold Change</tspan>")
                .style("fill", "var(--text-color)");


            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("MA Plot")
                .style("fill", "var(--text-color)");


            console.log(averageExpressionsN.length)
            //console.log(data.length)

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + -(10) + "," + -(60) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "#C14A82")
                .classed("legend-circle", true);

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("LogFC > log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") and</tspan>");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(350," + 0 + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "#1A74D5")
                .classed("legend-circle", true);

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("LogFC < -log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") and</tspan>");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(165," + 0 + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "lightgrey")
                .style("opacity", "0.5")
                .classed("legend-circle", true);

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("|LogFC| < log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") or</tspan>");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj > " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            svg.select("#scatter").selectAll("*").remove();
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", function (d) {
                    return xScale(d.meanExpr);
                })
                .attr("cy", function (d) {
                    return yScale(d.logFC);
                })
                .attr("r", function (d) {
                    if (selectedGeneData.length > 0) {
                        return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                    }
                    else {
                        return "2";
                    }
                })
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .style("opacity", function (d) {
                    if (selectedGeneData.length > 0) {
                        return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                    }
                    else {
                        if (d.pval_adj < threshold) {
                            if (d.logFC >= log_thr_fc) {
                                return 1; // Upregulated
                            } else if (d.logFC <= -log_thr_fc) {
                                return 1; // Downregulated
                            } else {
                                return 0.5; // Not significant
                            }
                        } else {
                            return 0.5; // Not significant
                        }
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .on("mouseover", function (d) {
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", .9);

                    tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with lightgrey
                    if (currentFill === "lightgrey") {
                        return; // If lightgrey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                    if (isHighlighted) {
                        // If already highlighted, remove the highlighting
                        // selectedElement.style("fill", d => {
                        //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                        //         return "#C14A82";
                        //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                        //         return "#1A74D5";
                        //     } else {
                        //         return "lightgrey";
                        //     }
                        // })
                        selectedElement.style("opacity", d => {
                            return 0.3
                        })
                            .attr("r", 2)

                        // .classed('pulse', false)
                        // .classed("pulse1", false);

                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        if (selectedGeneData.length === 0) {
                            scatter.selectAll("circle").style("opacity", d => {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }

                            })
                        }

                        // Find and remove the corresponding option from the select element
                        // var select = document.getElementById("selectButton");
                        // var options = select.options;

                        // for (var i = 0; i < options.length; i++) {
                        //     if (!selectedGeneData.includes(options[i].value)) {
                        //         select.removeChild(options[i]);
                        //         break; // Exit the loop once the option is removed
                        //     }
                        // }
                        heatmap(heatmap_data)
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        dehighlightHeatmapRow(d.gene)
                    } else {
                        if (selectedGeneData.length === 0) {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3;
                            })
                        }
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("opacity", "1")
                            .attr("r", "4")
                        // .classed('pulse', true)
                        // .classed('pulse1', false)

                        console.log(d)

                        // Find the corresponding scatterplot circle and toggle its selection
                        // var correspondingSquare = square
                        //     .filter(function (squaredata) {
                        //         return squaredata.gene === d.gene;
                        //     });

                        // correspondingSquare.style("stroke", "none");

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        // var select = document.getElementById("selectButton");

                        // // Add new options for the genes in selectedGeneData that are not already in the select element
                        // selectedGeneData.forEach(function (gene) {
                        //     if (!Array.from(select.options).some(option => option.value === gene)) {
                        //         var option = document.createElement("option");
                        //         option.value = gene;
                        //         option.text = gene;
                        //         select.appendChild(option);
                        //     }
                        // });
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        // synchronizeAnimations(this);
                        heatmap(heatmap_data)
                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        highlightHeatmapRows()
                    }
                    // miRNA_target()
                    highlightUpRows()
                    highlightDownRows()

                })
            // Variables to store the brush extents in the original data space
            let brushScatterExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            let brushedGenesScatter = [];

            // Define brush for the left side (x < 0)
            var brushScatter = d3.brush()
                .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                .on("end", updateBrushScatter);

            var brushScatterG

            // To get the current scale
            var currentXScale = xScale; // This will give you the reference to the xScale
            var currentYScale = yScale

            // Functions to handle brush events
            function updateBrushScatter() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for left brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    brushScatterExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d => {
                        return (
                            d.meanExpr >= brushScatterExtent[0][0] && d.meanExpr <= brushScatterExtent[1][0] &&
                            d.logFC <= brushScatterExtent[0][1] && d.logFC >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                        );
                    });
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesScatter.push(point.gene);
                        }
                    });
                    console.log("Brushed genes scatter", brushedGenesScatter)
                    highlightSelectedGenes(selectedPoints);
                } else {
                    console.log("Brushed genes scatter", brushedGenesScatter)
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "#C14A82";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "#1A74D5";
                                    } else {
                                        return "lightgrey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }

                            }
                        });

                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    if (ridge) {
                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    }
                    highlightUpRows()
                    highlightDownRows()

                    brushedGenesScatter = []
                    brushScatterExtent = null; // Reset if there's no selection
                }
            }

            // Function to highlight the selected genes based on the brush
            function highlightSelectedGenes(selectedPoints) {
                if (selectedGeneData.length > 0) {
                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                        .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .each(function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (!isHighlighted) {

                                scatter.selectAll("circle")
                                    .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                    .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")

                                console.log(d)


                            }
                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                        });


                }
                else {
                    scatter.selectAll("circle").style("opacity", d => {
                        return 0.3; // Not significant
                    })

                    // Select all circles and filter only those that are in the selected points
                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .each(function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // If not highlighted, apply the highlighting
                            selectedElement
                                .style("opacity", "1")
                                .attr("r", "4")

                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                        });
                }

                if (selectedPoints.length >= 1) {
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                }
                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }
                highlightUpRows()
                highlightDownRows()

                console.log(selectedGeneData)
            }
            // Set the zoom and pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart)
                .on("end", function () {
                })

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach click event to the reset button
            d3.select("#resetButton").on("click", resetZoom);

            // Attach click event to the toggle zoom button
            d3.select("#toggleZoomButton").on("click", function () {
                zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                if (zoomEnabled) {
                    document.getElementById("resetButton").style.cursor = "pointer"
                    document.getElementById("resetButton").style.opacity = 1
                    document.getElementById("resetButton").disabled = false
                    document.getElementById("switchButton").style.cursor = "pointer"
                    document.getElementById("switchButton").style.opacity = 1
                    document.getElementById("switchButton").disabled = false

                    document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                    svg.call(zoom); // Re-enable zooming

                    brushScatterG.remove();
                    brushedGenesScatter = []

                    const indices = []

                    console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                    console.log(selectedGeneData)
                    d3.selectAll(".cell")
                        .filter(function () {
                            return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                        })
                        .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                    selectedGeneData.forEach(name => {
                        const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                        if (index !== -1) {
                            indices.push(index); // Add the index if found
                        }
                    });
                    console.log(indices); // Log the collected indices

                    // Highlight the corresponding rows
                    indices.forEach(index => {
                        var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                        d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                        // Highlight the row labels
                        var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                    });

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        d3.select(this).select("circle")
                            .style("stroke", null)
                            .attr("r", function (d) {
                                return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                            });
                    });

                } else {
                    document.getElementById("resetButton").style.cursor = "not-allowed"
                    document.getElementById("resetButton").style.opacity = 0.6
                    document.getElementById("resetButton").disabled = true
                    document.getElementById("switchButton").style.cursor = "not-allowed"
                    document.getElementById("switchButton").style.opacity = 0.6
                    document.getElementById("switchButton").disabled = true

                    document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                    svg.on(".zoom", null); // Disable zooming by removing the zoom event

                    // Remove the brushes from the SVG

                    // Optionally, you can update the brush extents
                    brushScatter.extent([[0, 0], [width, height]]);

                    // Redraw brushes to reflect new zoom scale
                    brushScatterG = svg.append("g")
                        .attr("class", "brush-scatter")
                        .call(brushScatter);


                    brushedGenesScatter = []

                }
            });

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);

                // if (brushScatterExtent) {
                //     brushScatterG.call(brushScatter.move, [
                //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                //     ]);
                // }
            }

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            function updateChart() {
                if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                // recover the new scale
                var newX = d3.event.transform.rescaleX(xScale);
                var newY = d3.event.transform.rescaleY(yScale);

                currentXScale = newX
                currentYScale = newY

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path")
                    .style("stroke", "var(--text-color)");

                xAxis.selectAll("text")
                    .style("fill", "var(--text-color)");

                yAxis.selectAll("line, path")
                    .style("stroke", "var(--text-color)");

                yAxis.selectAll("text")
                    .style("fill", "var(--text-color)");

                // update circle position
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return newX(d.meanExpr); })
                    .attr('cy', function (d) { return newY(d.logFC); });

                brushScatter.extent([[0, 0], [width, height]]);

                if (!zoomEnabled) {
                    // Redraw brushes to reflect new zoom scale
                    // brushScatterG.call(brushScatter);
                }

            }

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }
            let brushLeftG
            let brushRightG
            let brushedGenesLeft = [];
            let brushedGenesRight = [];

            function SwitchingPlot(structure, choice) {

                if (choice == "volcano") {
                    if (brushScatterG) brushScatterG.remove()
                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))]);

                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    brushLeft = d3.brush()
                        .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                        .on("end", updateBrushLeft);

                    brushRight = d3.brush()
                        .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                        .on("end", updateBrushRight);

                    var brushLeftG
                    var brushRightG

                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart1);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "var(--text-color)");


                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    // Remove existing circles
                    dot.exit().remove();


                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    // Functions to handle brush events
                    function updateBrushLeft() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            leftBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesLeft.push(point.gene);
                                }
                            });
                            console.log("Brushed genes left", brushedGenesLeft)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes left", brushedGenesLeft)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.style("opacity") === "1";

                                    if (isHighlighted) {
                                        selectedElement.style("opacity", d => {
                                            return 0.3
                                        })
                                            .attr("r", 2)

                                        // .classed('pulse', false)
                                        // .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        if (selectedGeneData.length === 0) {
                                            scatter.selectAll("circle").style("opacity", d => {
                                                if (d.pval_adj < threshold) {
                                                    if (d.logFC >= log_thr_fc) {
                                                        return 1; // Upregulated
                                                    } else if (d.logFC <= -log_thr_fc) {
                                                        return 1; // Downregulated
                                                    } else {
                                                        return 0.5; // Not significant
                                                    }
                                                } else {
                                                    return 0.5; // Not significant
                                                }

                                            })
                                        }

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesLeft = []
                            leftBrushExtent = null; // Reset if there's no selection
                        }
                    }
                    function updateBrushRight() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for right brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            rightBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesRight.push(point.gene);
                                }
                            });
                            console.log("Brushed genes right", brushedGenesRight)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes right", brushedGenesRight)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.style("opacity") === "1";

                                    if (isHighlighted) {
                                        selectedElement.style("opacity", d => {
                                            return 0.3
                                        })
                                            .attr("r", 2)

                                        // .classed('pulse', false)
                                        // .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        if (selectedGeneData.length === 0) {
                                            scatter.selectAll("circle").style("opacity", d => {
                                                if (d.pval_adj < threshold) {
                                                    if (d.logFC >= log_thr_fc) {
                                                        return 1; // Upregulated
                                                    } else if (d.logFC <= -log_thr_fc) {
                                                        return 1; // Downregulated
                                                    } else {
                                                        return 0.5; // Not significant
                                                    }
                                                } else {
                                                    return 0.5; // Not significant
                                                }

                                            })
                                        }

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesRight = []
                            rightBrushExtent = null; // Reset if there's no selection
                        }
                    }


                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }


                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false
                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushLeftG.remove();
                            brushRightG.remove();
                            brushedGenesLeft = []
                            brushedGenesRight = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                            brushRight.extent([[currentXScale(0), 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushLeftG = svg.append("g")
                                .attr("class", "brush-left")
                                .call(brushLeft);

                            brushRightG = svg.append("g")
                                .attr("class", "brush-right")
                                .call(brushRight);

                            brushedGenesLeft = []
                            brushedGenesRight = []

                        }
                    });
                    // Updating the chart after zooming
                    function updateChart1() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                        // Recover the new scale
                        var t = d3.event.transform;
                        newX = t.rescaleX(xScale);
                        newY = t.rescaleY(yScale);
                        currentXScale = newX; // Update the reference
                        currentYScale = newY; // Update the reference

                        // xScale = newX
                        // yScale = newY

                        // Update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                        xAxis.selectAll("text").style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                        yAxis.selectAll("text").style("fill", "var(--text-color)");

                        // Update circle position
                        scatter.selectAll("circle")
                            .attr('cx', function (d) {
                                if (d.pval_adj !== null) return newX(d.logFC);
                            })
                            .attr('cy', function (d) {
                                if (d.pval_adj !== null) return newY(-Math.log10(d.pval_adj));
                            });

                        // Update the brush extents
                        brushLeft.extent([[0, 0], [newX(0), height]]);
                        brushRight.extent([[newX(0), 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            brushLeftG.call(brushLeft);
                            brushRightG.call(brushRight);
                        }

                    }

                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (leftBrushExtent) {
                        //     brushLeftG.call(brushLeft.move, [
                        //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                        //     ]);
                        // }
                        // if (rightBrushExtent) {
                        //     brushRightG.call(brushRight.move, [
                        //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                        //     ]);
                        // }
                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "var(--text-color)");

                } else if (choice == "scatter") {
                    if (brushLeftG) brushLeftG.remove();
                    if (brushRightG) brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());


                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()

                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    //console.log(yScale);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })


                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "var(--text-color)");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                        .style("fill", "var(--text-color)");

                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)
                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                                    d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "#C14A82";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "#1A74D5";
                                            } else {
                                                return "lightgrey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }
                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });
                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        xAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        yAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.Normal); })
                            .attr('cy', function (d) { return newY(d.Case); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }

                }
                else {
                    if (brushLeftG) brushLeftG.remove();
                    if (brushRightG) brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    // Create x and y scales
                    xScale = d3.scaleLinear()
                        .domain([d3.min(data, d => d.meanExpr) - 0.5, d3.max(data, d => d.meanExpr) + 0.5])
                        .range([0, width]);

                    yScale = d3.scaleLinear()
                        .domain([d3.min(data, d => d.logFC) - 0.5, d3.max(data, d => d.logFC) + 0.5])
                        .range([height, 0]);

                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    //console.log(yScale);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })


                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("MA Plot")
                        .style("fill", "var(--text-color)");

                    xlab.html("")
                    ylab.html("")

                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("Mean Expression (Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>)</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>Fold Change</tspan>")
                        .style("fill", "var(--text-color)");


                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)

                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            return xScale(d.meanExpr);
                        })
                        .attr("cy", function (d) {
                            return yScale(d.logFC);
                        })
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.meanExpr >= brushScatterExtent[0][0] && d.meanExpr <= brushScatterExtent[1][0] &&
                                    d.logFC <= brushScatterExtent[0][1] && d.logFC >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "#C14A82";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "#1A74D5";
                                            } else {
                                                return "lightgrey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }
                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");; // Select only cells that do NOT have the 'selected' class
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });
                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        xAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        yAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.meanExpr); })
                            .attr('cy', function (d) { return newY(d.logFC); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }



                }
            }



            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else if (currentPlot === 'scatter') {
                    currentPlot = 'ma';
                    SwitchingPlot(data, currentPlot)
                }
                else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });
            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
            // applyThemeToSVG()

        }



        function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

            var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
                return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
            }, parsed[0]);

            var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
                return currentGene.logFC < minGene.logFC ? currentGene : minGene;
            }, parsed[0]);

            //console.log(mostUpregulatedGene)
            var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
            var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

            var margin = { top: 60, right: 40, bottom: 40, left: 50 };
            // var width = 1000 - margin.left - margin.right;
            // var height = 600 - margin.top - margin.bottom;

            var width = document.getElementById("scatterPlot").clientWidth - margin.left - margin.right;
            var height = document.getElementById("scatterPlot").clientHeight - margin.top - margin.bottom;


            // Create SVG container
            var svg = d3.select("#scatterPlot")
                .html("")  // Clear previous content
                .append("svg")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // Set the viewBox for scaling
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("preserveAspectRatio", "xMidYMin")
                .style("max-height", "650px")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Create x and y scales
            var xScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsN)))
                .range([0, width]);
            console.log("Domain:", xScale.domain());

            var yScale = d3.scaleLinear()
                .domain(d3.extent(Object.values(averageExpressionsC)))
                .range([height, 0])
                .nice()
            //console.log(yScale);

            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(xScale))

            xAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            xAxis.selectAll("text")
                .style("fill", "var(--text-color)");
            // Add Y axis
            var yAxis = svg.append("g")
                .call(d3.axisLeft(yScale))

            yAxis.selectAll("line, path")
                .style("stroke", "var(--text-color)");

            yAxis.selectAll("text")
                .style("fill", "var(--text-color)");

            // Customization

            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            svg.select("#scatter").selectAll("*").remove();
            scatter = svg.append('g')
                .attr("id", "scatter")
                .attr("clip-path", "url(#clip)");

            // Set the zoom and Pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")  // Set pointer-events to "all" here
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            // Attach click event to the reset button
            d3.select("#resetButton")
                .on("click", resetZoom);

            // Add X axis label
            xlab = svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "var(--text-color)")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

            // Add Y axis label
            ylab = svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                .style("fill", "var(--text-color)");

            // Add title
            svg.append("text")
                .attr("id", "plotTitle")
                .attr("x", width / 2)
                .attr("y", 15)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Scatter Plot")
                .style("fill", "var(--text-color)");

            // Create circles for each gene
            var data = Object.keys(averageExpressionsN).map(function (gene) {
                // Find the corresponding logFC value from parsedLogFC_origin
                var logFCObj = parsed.find(d => d.Gene === gene) || null;
                var logFC = logFCObj ? logFCObj.logFC : null;
                var A = logFCObj ? logFCObj.A : null;

                if (logFC <= log_thr_fc) {
                    var type = "down"
                }
                else {
                    var type = "up"
                }

                var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
                var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

                return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type, meanExpr: A };
            });


            console.log(averageExpressionsN.length)
            //console.log(data.length)

            // Create a legend
            var legend = svg.append("g")
                .attr("transform", "translate(" + -(10) + "," + -(60) + ")");

            // Add a filter for the shadow
            var defs = svg.append("defs");

            var filter = defs.append("filter")
                .attr("id", "legendShadow")
                .attr("height", "150%");

            filter.append("feGaussianBlur")
                .attr("in", "SourceAlpha")
                .attr("stdDeviation", 3)
                .attr("result", "blur");

            filter.append("feOffset")
                .attr("in", "blur")
                .attr("dx", 3)
                .attr("dy", 3)
                .attr("result", "offsetBlur");

            var feMerge = filter.append("feMerge");

            feMerge.append("feMergeNode")
                .attr("in", "offsetBlur");
            feMerge.append("feMergeNode")
                .attr("in", "SourceGraphic");

            // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
            var upregulatedLegend = legend.append("g")
                .attr("transform", "translate(0,0)");

            upregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "#C14A82")
                .classed("legend-circle", true);

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Upregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("LogFC > log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") and</tspan>");

            upregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Calculate the height of the first legend item
            var legendItemHeight = upregulatedLegend.node().getBBox().height;

            // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
            var downregulatedLegend = legend.append("g")
                .attr("transform", "translate(350," + 0 + ")");

            downregulatedLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "#1A74D5")
                .classed("legend-circle", true);

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Downregulated")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("LogFC < -log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") and</tspan>");

            downregulatedLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj < " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
            var notSignificantLegend = legend.append("g")
                .attr("transform", "translate(165," + 0 + ")");

            notSignificantLegend.append("circle")
                .attr("cx", 10)
                .attr("cy", 20)
                .attr("r", 6)
                .style("fill", "lightgrey")
                .style("opacity", "0.5")
                .classed("legend-circle", true);

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 20)
                .style("fill", "var(--text-color)")
                .style("font-size", "12px")
                .text("Not Significant")
                .append("tspan")
                .attr("x", 20)
                .attr("dy", 15) // Adjusted spacing for subtitle
                .style("font-size", "10px") // Smaller font size for subtitle
                .html("|LogFC| < log<tspan dy='5'>2</tspan> <tspan dy='-5'>(" + thr_fc + ") or</tspan>");

            notSignificantLegend.append("text")
                .attr("x", 20)
                .attr("y", 48)
                .style("fill", "var(--text-color)")
                .text("pval_adj > " + threshold)
                .style("font-size", "10px"); // Smaller font size for subtitle

            // Add circles to the scatter plot
            var tooltip = d3.select("#tooltip");
            //console.log(data)
            svg.select("#scatter").selectAll("*").remove();
            scatter.selectAll("circle")
                .data(data)
                .enter().append("circle")
                .attr("cx", d => {
                    // Log the value of d['Normal'] to inspect its format
                    if (isNaN(d['Normal'])) {
                        console.log("NaN value found in 'Normal':", d['Normal']);
                    }
                    // Convert the value to a number, assuming it's a string
                    return xScale(parseFloat(d['Normal']));
                })
                .attr("cy", d => yScale(d['Case']))
                .attr("r", function (d) {
                    if (selectedGeneData.length > 0) {
                        return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                    }
                    else {
                        return "2";
                    }
                })
                .style("fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .style("opacity", function (d) {
                    if (selectedGeneData.length > 0) {
                        return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                    }
                    else {
                        if (d.pval_adj < threshold) {
                            if (d.logFC >= log_thr_fc) {
                                return 1; // Upregulated
                            } else if (d.logFC <= -log_thr_fc) {
                                return 1; // Downregulated
                            } else {
                                return 0.5; // Not significant
                            }
                        } else {
                            return 0.5; // Not significant
                        }
                    }
                })
                .attr("data-initial-fill", d => {
                    if (d.pval_adj < threshold) {
                        if (d.logFC >= log_thr_fc) {
                            return "#C14A82"; // Upregulated
                        } else if (d.logFC <= -log_thr_fc) {
                            return "#1A74D5"; // Downregulated
                        } else {
                            return "lightgrey"; // Not significant
                        }
                    } else {
                        return "lightgrey"; // Not significant
                    }
                })
                .on("mouseover", function (d) {
                    d3.select(this)
                        .style("stroke", "black")
                        .style("stroke-width", 2);

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", .9);

                    tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                        .style("left", (d3.event.pageX + 15) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    // Remove the highlight and hide tooltip on mouseout
                    d3.select(this)
                        .style("stroke", "none");

                    tooltip.transition()
                        .duration(200) // Add transition duration for mouseout
                        .style("opacity", 0)
                        .style("visibility", "none")
                        .style("pointer-events", "none"); // Disable pointer events for the tooltip
                })
                .on("click", function (d) {
                    var selectedElement = d3.select(this);
                    var currentFill = selectedElement.style("fill");

                    // Check if the element is already filled with lightgrey
                    if (currentFill === "lightgrey") {
                        return; // If lightgrey, do nothing
                    }

                    // Check if the element is already highlighted
                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                    if (isHighlighted) {
                        // If already highlighted, remove the highlighting
                        // selectedElement.style("fill", d => {
                        //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                        //         return "#C14A82";
                        //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                        //         return "#1A74D5";
                        //     } else {
                        //         return "lightgrey";
                        //     }
                        // })
                        selectedElement.style("opacity", d => {
                            return 0.3
                        })
                            .attr("r", 2)

                        // .classed('pulse', false)
                        // .classed("pulse1", false);

                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                        if (selectedGeneData.length === 0) {
                            scatter.selectAll("circle").style("opacity", d => {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }

                            })
                        }

                        // Find and remove the corresponding option from the select element
                        // var select = document.getElementById("selectButton");
                        // var options = select.options;

                        // for (var i = 0; i < options.length; i++) {
                        //     if (!selectedGeneData.includes(options[i].value)) {
                        //         select.removeChild(options[i]);
                        //         break; // Exit the loop once the option is removed
                        //     }
                        // }
                        heatmap(heatmap_data)
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }

                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        dehighlightHeatmapRow(d.gene)
                    } else {
                        if (selectedGeneData.length === 0) {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3;
                            })
                        }
                        // If not highlighted, apply the highlighting
                        selectedElement
                            .style("opacity", "1")
                            .attr("r", "4")
                        // .classed('pulse', true)
                        // .classed('pulse1', false)

                        console.log(d)

                        // Find the corresponding scatterplot circle and toggle its selection
                        // var correspondingSquare = square
                        //     .filter(function (squaredata) {
                        //         return squaredata.gene === d.gene;
                        //     });

                        // correspondingSquare.style("stroke", "none");

                        // On click, filter data for the selected gene
                        selectedGeneData.push(d.gene);

                        // Get the select element
                        // var select = document.getElementById("selectButton");

                        // // Add new options for the genes in selectedGeneData that are not already in the select element
                        // selectedGeneData.forEach(function (gene) {
                        //     if (!Array.from(select.options).some(option => option.value === gene)) {
                        //         var option = document.createElement("option");
                        //         option.value = gene;
                        //         option.text = gene;
                        //         select.appendChild(option);
                        //     }
                        // });
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }

                        // synchronizeAnimations(this);
                        heatmap(heatmap_data)
                        // Call a function to create parallel coordinates plot using selectedGeneData
                        dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        highlightHeatmapRows()
                    }
                    // miRNA_target()
                    highlightUpRows()
                    highlightDownRows()

                })
            // Variables to store the brush extents in the original data space
            let brushScatterExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

            let brushedGenesScatter = [];

            // Define brush for the left side (x < 0)
            var brushScatter = d3.brush()
                .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                .on("end", updateBrushScatter);

            var brushScatterG

            // To get the current scale
            var currentXScale = xScale; // This will give you the reference to the xScale
            var currentYScale = yScale

            // Functions to handle brush events
            function updateBrushScatter() {
                const selection = d3.event.selection;  // Access event via d3.event in v4
                if (selection) {
                    var [x0, y0] = selection[0]; // Get coordinates for left brush
                    var [x1, y1] = selection[1];

                    // Store the selection in data space, including y extents
                    brushScatterExtent = [
                        [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                        [currentXScale.invert(x1), currentYScale.invert(y1)]
                    ];

                    // Filter selected points based on the stored extents
                    var selectedPoints = data.filter(d => {
                        return (
                            d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                            d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                        );
                    });
                    // Add genes to brushedGenes if they are not already present
                    selectedPoints.forEach(point => {
                        if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                            brushedGenesScatter.push(point.gene);
                        }
                    });
                    console.log("Brushed genes scatter", brushedGenesScatter)
                    highlightSelectedGenes(selectedPoints);
                } else {
                    console.log("Brushed genes scatter", brushedGenesScatter)
                    // Remove the 'pulse' class from the brushed genes
                    scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                        .each(function (d) {
                            console.log(d)
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedElement.classed('pulse');

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                selectedElement.style("fill", d => {
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "#C14A82";
                                    } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                        return "#1A74D5";
                                    } else {
                                        return "lightgrey";
                                    }
                                })
                                    .classed('pulse', false)
                                    .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }

                            }
                        });

                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                    if (ridge) {
                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    }
                    highlightUpRows()
                    highlightDownRows()

                    brushedGenesScatter = []
                    brushScatterExtent = null; // Reset if there's no selection
                }
            }

            // Function to highlight the selected genes based on the brush
            function highlightSelectedGenes(selectedPoints) {
                if (selectedGeneData.length > 0) {
                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                        .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .each(function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (!isHighlighted) {

                                scatter.selectAll("circle")
                                    .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                    .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")

                                console.log(d)


                            }
                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                        });


                }
                else {
                    scatter.selectAll("circle").style("opacity", d => {
                        return 0.3; // Not significant
                    })

                    // Select all circles and filter only those that are in the selected points
                    scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                        .each(function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // If not highlighted, apply the highlighting
                            selectedElement
                                .style("opacity", "1")
                                .attr("r", "4")

                            if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                        });
                }

                if (selectedPoints.length >= 1) {
                    heatmap(heatmap_data);
                    dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                }
                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }
                highlightUpRows()
                highlightDownRows()

                console.log(selectedGeneData)
            }
            // Set the zoom and pan features
            var zoom = d3.zoom()
                .scaleExtent([0.05, 20])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart)
                .on("end", function () {
                })

            // Add an invisible rect on top of the chart area
            svg.append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .lower();

            // Attach click event to the reset button
            d3.select("#resetButton").on("click", resetZoom);

            // Attach click event to the toggle zoom button
            d3.select("#toggleZoomButton").on("click", function () {
                zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                if (zoomEnabled) {
                    document.getElementById("resetButton").style.cursor = "pointer"
                    document.getElementById("resetButton").style.opacity = 1
                    document.getElementById("resetButton").disabled = false
                    document.getElementById("switchButton").style.cursor = "pointer"
                    document.getElementById("switchButton").style.opacity = 1
                    document.getElementById("switchButton").disabled = false

                    document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                    svg.call(zoom); // Re-enable zooming

                    brushScatterG.remove();
                    brushedGenesScatter = []

                    const indices = []

                    console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                    console.log(selectedGeneData)
                    d3.selectAll(".cell")
                        .filter(function () {
                            return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");; // Select only cells that do NOT have the 'selected' class
                        })
                        .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                    selectedGeneData.forEach(name => {
                        const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                        if (index !== -1) {
                            indices.push(index); // Add the index if found
                        }
                    });
                    console.log(indices); // Log the collected indices

                    // Highlight the corresponding rows
                    indices.forEach(index => {
                        var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                        d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                        // Highlight the row labels
                        var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                    });

                    d3.selectAll(".rnode").each(function (d) {
                        // console.log(d); // Log the current data object for debugging

                        d3.select(this).classed("selected", true)
                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                        d3.select(this).select("circle")
                            .style("stroke", null)
                            .attr("r", function (d) {
                                return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                            });
                    });


                } else {
                    document.getElementById("resetButton").style.cursor = "not-allowed"
                    document.getElementById("resetButton").style.opacity = 0.6
                    document.getElementById("resetButton").disabled = true
                    document.getElementById("switchButton").style.cursor = "not-allowed"
                    document.getElementById("switchButton").style.opacity = 0.6
                    document.getElementById("switchButton").disabled = true

                    document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                    svg.on(".zoom", null); // Disable zooming by removing the zoom event

                    // Remove the brushes from the SVG

                    // Optionally, you can update the brush extents
                    brushScatter.extent([[0, 0], [width, height]]);

                    // Redraw brushes to reflect new zoom scale
                    brushScatterG = svg.append("g")
                        .attr("class", "brush-scatter")
                        .call(brushScatter);


                    brushedGenesScatter = []

                }
            });

            // Define the resetZoom function
            function resetZoom() {
                // Reset the zoom transformation
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity);

                // if (brushScatterExtent) {
                //     brushScatterG.call(brushScatter.move, [
                //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                //     ]);
                // }
            }

            // Attach zoom behavior to the SVG
            svg.call(zoom);

            function updateChart() {
                if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                // recover the new scale
                var newX = d3.event.transform.rescaleX(xScale);
                var newY = d3.event.transform.rescaleY(yScale);

                currentXScale = newX
                currentYScale = newY

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX));
                yAxis.call(d3.axisLeft(newY));

                xAxis.selectAll("line, path")
                    .style("stroke", "var(--text-color)");

                xAxis.selectAll("text")
                    .style("fill", "var(--text-color)");

                yAxis.selectAll("line, path")
                    .style("stroke", "var(--text-color)");

                yAxis.selectAll("text")
                    .style("fill", "var(--text-color)");

                // update circle position
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return newX(d.Normal); })
                    .attr('cy', function (d) { return newY(d.Case); });

                brushScatter.extent([[0, 0], [width, height]]);

                if (!zoomEnabled) {
                    // Redraw brushes to reflect new zoom scale
                    // brushScatterG.call(brushScatter);
                }

            }

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }
            let brushLeftG
            let brushRightG
            let brushedGenesLeft = [];
            let brushedGenesRight = [];

            function SwitchingPlot(structure, choice) {

                if (choice == "volcano") {
                    if (brushScatterG) brushScatterG.remove()
                    // Create x and y scales
                    xScale.domain([
                        d3.min(data, d => d.logFC) - 0.5,
                        d3.max(data, d => d.logFC) + 0.5
                    ]);

                    yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20)))]);

                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    brushLeft = d3.brush()
                        .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
                        .on("end", updateBrushLeft);

                    brushRight = d3.brush()
                        .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
                        .on("end", updateBrushRight);

                    var brushLeftG
                    var brushRightG

                    // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
                    zoom.on("zoom", updateChart1);

                    // Apply zoom behavior to the svg
                    svg.call(zoom);

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Volcano Plot")
                        .style("fill", "var(--text-color)");


                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    // Remove existing circles
                    dot.exit().remove();


                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            if (d.pval_adj !== null) {
                                return xScale(d.logFC)
                            }
                        })
                        .attr("cy", function (d) {
                            if (d.pval_adj !== null) {
                                return yScale(-Math.log10(d.pval_adj.toExponential(20)))
                            }
                        })
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    // Functions to handle brush events
                    function updateBrushLeft() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            leftBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesLeft.push(point.gene);
                                }
                            });
                            console.log("Brushed genes left", brushedGenesLeft)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes left", brushedGenesLeft)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.style("opacity") === "1";

                                    if (isHighlighted) {
                                        selectedElement.style("opacity", d => {
                                            return 0.3
                                        })
                                            .attr("r", 2)

                                        // .classed('pulse', false)
                                        // .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        if (selectedGeneData.length === 0) {
                                            scatter.selectAll("circle").style("opacity", d => {
                                                if (d.pval_adj < threshold) {
                                                    if (d.logFC >= log_thr_fc) {
                                                        return 1; // Upregulated
                                                    } else if (d.logFC <= -log_thr_fc) {
                                                        return 1; // Downregulated
                                                    } else {
                                                        return 0.5; // Not significant
                                                    }
                                                } else {
                                                    return 0.5; // Not significant
                                                }

                                            })
                                        }

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesLeft = []
                            leftBrushExtent = null; // Reset if there's no selection
                        }
                    }

                    function updateBrushRight() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for right brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            rightBrushExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
                                    -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesRight.push(point.gene);
                                }
                            });
                            console.log("Brushed genes right", brushedGenesRight)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes right", brushedGenesRight)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.style("opacity") === "1";

                                    if (isHighlighted) {
                                        selectedElement.style("opacity", d => {
                                            return 0.3
                                        })
                                            .attr("r", 2)

                                        // .classed('pulse', false)
                                        // .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        if (selectedGeneData.length === 0) {
                                            scatter.selectAll("circle").style("opacity", d => {
                                                if (d.pval_adj < threshold) {
                                                    if (d.logFC >= log_thr_fc) {
                                                        return 1; // Upregulated
                                                    } else if (d.logFC <= -log_thr_fc) {
                                                        return 1; // Downregulated
                                                    } else {
                                                        return 0.5; // Not significant
                                                    }
                                                } else {
                                                    return 0.5; // Not significant
                                                }

                                            })
                                        }

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesRight = []
                            rightBrushExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }

                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false
                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushLeftG.remove();
                            brushRightG.remove();
                            brushedGenesLeft = []
                            brushedGenesRight = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");; // Select only cells that do NOT have the 'selected' class
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushLeft.extent([[0, 0], [currentXScale(0), height]]);
                            brushRight.extent([[currentXScale(0), 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushLeftG = svg.append("g")
                                .attr("class", "brush-left")
                                .call(brushLeft);

                            brushRightG = svg.append("g")
                                .attr("class", "brush-right")
                                .call(brushRight);

                            brushedGenesLeft = []
                            brushedGenesRight = []

                        }
                    });
                    // Updating the chart after zooming
                    function updateChart1() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

                        // Recover the new scale
                        var t = d3.event.transform;
                        newX = t.rescaleX(xScale);
                        newY = t.rescaleY(yScale);
                        currentXScale = newX; // Update the reference
                        currentYScale = newY; // Update the reference

                        // xScale = newX
                        // yScale = newY

                        // Update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                        xAxis.selectAll("text").style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path").style("stroke", "var(--text-color)");
                        yAxis.selectAll("text").style("fill", "var(--text-color)");

                        // Update circle position
                        scatter.selectAll("circle")
                            .attr('cx', function (d) {
                                if (d.pval_adj !== null) return newX(d.logFC);
                            })
                            .attr('cy', function (d) {
                                if (d.pval_adj !== null) return newY(-Math.log10(d.pval_adj));
                            });

                        // Update the brush extents
                        brushLeft.extent([[0, 0], [newX(0), height]]);
                        brushRight.extent([[newX(0), 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            brushLeftG.call(brushLeft);
                            brushRightG.call(brushRight);
                        }

                    }

                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (leftBrushExtent) {
                        //     brushLeftG.call(brushLeft.move, [
                        //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
                        //     ]);
                        // }
                        // if (rightBrushExtent) {
                        //     brushRightG.call(brushRight.move, [
                        //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
                        //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
                        //     ]);
                        // }
                    }
                    xlab.html("")
                    ylab.html("")

                    // Add X axis label with logarithmic notation
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

                    // Add Y axis label with logarithmic notation
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
                        .style("fill", "var(--text-color)");

                } else if (choice == "scatter") {
                    if (brushLeftG) brushLeftG.remove();
                    if (brushRightG) brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    xScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsN)))
                        .range([0, width]);
                    //console.log("Domain:", xScale.domain());


                    //console.log(averageExpressionsN);
                    //console.log(averageExpressionsC);
                    yScale = d3.scaleLinear()
                        .domain(d3.extent(Object.values(averageExpressionsC)))
                        .range([height, 0])
                        .nice()

                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    //console.log(yScale);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })


                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("Scatter Plot")
                        .style("fill", "var(--text-color)");

                    xlab.html("")
                    ylab.html("")
                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
                        .style("fill", "var(--text-color)");

                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)

                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                dehighlightHeatmapRow(d.gene)
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", d => {
                            // Log the value of d['Normal'] to inspect its format
                            if (isNaN(d['Normal'])) {
                                console.log("NaN value found in 'Normal':", d['Normal']);
                            }
                            // Convert the value to a number, assuming it's a string
                            return xScale(parseFloat(d['Normal']));
                        })
                        .attr("cy", d => yScale(d['Case']))
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
                                    d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "#C14A82";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "#1A74D5";
                                            } else {
                                                return "lightgrey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }
                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");; // Select only cells that do NOT have the 'selected' class
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });
                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        xAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        yAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.Normal); })
                            .attr('cy', function (d) { return newY(d.Case); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }

                }
                else {
                    if (brushLeftG) brushLeftG.remove();
                    if (brushRightG) brushRightG.remove();
                    brushedGenesLeft = []
                    brushedGenesRight = []
                    // Create x and y scales
                    xScale = d3.scaleLinear()
                        .domain([d3.min(data, d => d.meanExpr) - 0.5, d3.max(data, d => d.meanExpr) + 0.5])
                        .range([0, width]);

                    yScale = d3.scaleLinear()
                        .domain([d3.min(data, d => d.logFC) - 0.5, d3.max(data, d => d.logFC) + 0.5])
                        .range([height, 0]);

                    var currentXScale = xScale; // This will give you the reference to the xScale
                    var currentYScale = yScale

                    //console.log(yScale);

                    // Set the zoom and pan features
                    zoom = d3.zoom()
                        .scaleExtent([0.05, 20])
                        .extent([[0, 0], [width, height]])
                        .on("zoom", updateChart)
                        .on("end", function () {
                        })


                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity);

                    zoom.on("zoom", updateChart);
                    svg.call(zoom)

                    // Transition the axes
                    xAxis.transition().duration(1000)
                        .call(d3.axisBottom(xScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    xAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    yAxis.transition().duration(1000)
                        .call(d3.axisLeft(yScale))
                        .selectAll("line, path")
                        .style("stroke", "var(--text-color)");

                    yAxis.selectAll("text")
                        .style("fill", "var(--text-color)");

                    // Update title
                    svg.select("#plotTitle")
                        .text("MA Plot")
                        .style("fill", "var(--text-color)");

                    xlab.html("")
                    ylab.html("")

                    // Add X axis label
                    xlab = svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .style("fill", "var(--text-color)")
                        .html("Mean Expression (Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>)</tspan>");

                    // Add Y axis label
                    ylab = svg.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .attr("text-anchor", "middle")
                        .style("font-size", "14px")
                        .html("Log<tspan dy='5'>2</tspan> <tspan dy ='-5'>Fold Change</tspan>")
                        .style("fill", "var(--text-color)");


                    //svg.select("#scatter").selectAll("*").remove();

                    // Update dots
                    var dot = svg.selectAll('circle').filter(function () {
                        return !d3.select(this).classed('legend-circle');
                    }).data(structure);

                    dot.enter().append("circle").merge(dot)

                    // Remove existing circles
                    dot.exit().remove();

                    dot.enter().append("circle").merge(dot)
                        .on("mouseover", function (d) {
                            d3.select(this)
                                .style("stroke", "black")
                                .style("stroke-width", 2);

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", .9);

                            tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
                                .style("left", (d3.event.pageX + 15) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // Remove the highlight and hide tooltip on mouseout
                            d3.select(this)
                                .style("stroke", "none");

                            tooltip.transition()
                                .duration(200) // Add transition duration for mouseout
                                .style("opacity", 0)
                                .style("visibility", "none")
                                .style("pointer-events", "none"); // Disable pointer events for the tooltip
                        })
                        .on("click", function (d) {
                            var selectedElement = d3.select(this);
                            var currentFill = selectedElement.style("fill");

                            // Check if the element is already filled with lightgrey
                            if (currentFill === "lightgrey") {
                                return; // If lightgrey, do nothing
                            }

                            // Check if the element is already highlighted
                            var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                            if (isHighlighted) {
                                // If already highlighted, remove the highlighting
                                // selectedElement.style("fill", d => {
                                //     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#C14A82";
                                //     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                //         return "#1A74D5";
                                //     } else {
                                //         return "lightgrey";
                                //     }
                                // })
                                selectedElement.style("opacity", d => {
                                    return 0.3
                                })
                                    .attr("r", 2)

                                // .classed('pulse', false)
                                // .classed("pulse1", false);

                                selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        if (d.pval_adj < threshold) {
                                            if (d.logFC >= log_thr_fc) {
                                                return 1; // Upregulated
                                            } else if (d.logFC <= -log_thr_fc) {
                                                return 1; // Downregulated
                                            } else {
                                                return 0.5; // Not significant
                                            }
                                        } else {
                                            return 0.5; // Not significant
                                        }

                                    })
                                }

                                // Find and remove the corresponding option from the select element
                                // var select = document.getElementById("selectButton");
                                // var options = select.options;

                                // for (var i = 0; i < options.length; i++) {
                                //     if (!selectedGeneData.includes(options[i].value)) {
                                //         select.removeChild(options[i]);
                                //         break; // Exit the loop once the option is removed
                                //     }
                                // }
                                heatmap(heatmap_data)
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            } else {
                                if (selectedGeneData.length === 0) {
                                    scatter.selectAll("circle").style("opacity", d => {
                                        return 0.3;
                                    })
                                }
                                // If not highlighted, apply the highlighting
                                selectedElement
                                    .style("opacity", "1")
                                    .attr("r", "4")
                                // .classed('pulse', true)
                                // .classed('pulse1', false)

                                console.log(d)

                                // Find the corresponding scatterplot circle and toggle its selection
                                // var correspondingSquare = square
                                //     .filter(function (squaredata) {
                                //         return squaredata.gene === d.gene;
                                //     });

                                // correspondingSquare.style("stroke", "none");

                                // On click, filter data for the selected gene
                                selectedGeneData.push(d.gene);

                                // Get the select element
                                // var select = document.getElementById("selectButton");

                                // // Add new options for the genes in selectedGeneData that are not already in the select element
                                // selectedGeneData.forEach(function (gene) {
                                //     if (!Array.from(select.options).some(option => option.value === gene)) {
                                //         var option = document.createElement("option");
                                //         option.value = gene;
                                //         option.text = gene;
                                //         select.appendChild(option);
                                //     }
                                // });
                                if (ridge) {
                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                }
                                // synchronizeAnimations(this);
                                heatmap(heatmap_data)
                                // Call a function to create parallel coordinates plot using selectedGeneData
                                dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                                highlightHeatmapRows()
                            }
                            // miRNA_target()
                            highlightUpRows()
                            highlightDownRows()

                        })
                        .transition()
                        .duration(1000)
                        .attr("cx", function (d) {
                            return xScale(d.meanExpr);
                        })
                        .attr("cy", function (d) {
                            return yScale(d.logFC);
                        })
                        .attr("r", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? "4" : "2"
                            }
                            else {
                                return "2";
                            }
                        })
                        .style("fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })
                        .style("opacity", function (d) {
                            if (selectedGeneData.length > 0) {
                                return selectedGeneData.some(selectedGene => selectedGene === d.gene) ? 1 : 0.3
                            }
                            else {
                                if (d.pval_adj < threshold) {
                                    if (d.logFC >= log_thr_fc) {
                                        return 1; // Upregulated
                                    } else if (d.logFC <= -log_thr_fc) {
                                        return 1; // Downregulated
                                    } else {
                                        return 0.5; // Not significant
                                    }
                                } else {
                                    return 0.5; // Not significant
                                }
                            }
                        })
                        .attr("data-initial-fill", d => {
                            if (d.pval_adj < threshold) {
                                if (d.logFC >= log_thr_fc) {
                                    return "#C14A82"; // Upregulated
                                } else if (d.logFC <= -log_thr_fc) {
                                    return "#1A74D5"; // Downregulated
                                } else {
                                    return "lightgrey"; // Not significant
                                }
                            } else {
                                return "lightgrey"; // Not significant
                            }
                        })

                    brushScatter = d3.brush()
                        .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
                        .on("end", updateBrushScatter);

                    // Attach click event to the reset button
                    d3.select("#resetButton").on("click", resetZoom);

                    // Functions to handle brush events
                    function updateBrushScatter() {
                        const selection = d3.event.selection;  // Access event via d3.event in v4
                        if (selection) {
                            var [x0, y0] = selection[0]; // Get coordinates for left brush
                            var [x1, y1] = selection[1];

                            // Store the selection in data space, including y extents
                            brushScatterExtent = [
                                [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
                                [currentXScale.invert(x1), currentYScale.invert(y1)]
                            ];

                            // Filter selected points based on the stored extents
                            var selectedPoints = data.filter(d => {
                                return (
                                    d.meanExpr >= brushScatterExtent[0][0] && d.meanExpr <= brushScatterExtent[1][0] &&
                                    d.logFC <= brushScatterExtent[0][1] && d.logFC >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
                                );
                            });
                            // Add genes to brushedGenes if they are not already present
                            selectedPoints.forEach(point => {
                                if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
                                    brushedGenesScatter.push(point.gene);
                                }
                            });
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            highlightSelectedGenes(selectedPoints);
                        } else {
                            console.log("Brushed genes scatter", brushedGenesScatter)
                            // Remove the 'pulse' class from the brushed genes
                            scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
                                .each(function (d) {
                                    console.log(d)
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedElement.classed('pulse');

                                    if (isHighlighted) {
                                        // If already highlighted, remove the highlighting
                                        selectedElement.style("fill", d => {
                                            if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                                return "#C14A82";
                                            } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
                                                return "#1A74D5";
                                            } else {
                                                return "lightgrey";
                                            }
                                        })
                                            .classed('pulse', false)
                                            .classed("pulse1", false);

                                        selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

                                        // Find and remove the corresponding option from the select element
                                        // var select = document.getElementById("selectButton");
                                        // var options = select.options;

                                        // for (var i = 0; i < options.length; i++) {
                                        //     if (!selectedGeneData.includes(options[i].value)) {
                                        //         select.removeChild(options[i]);
                                        //         break; // Exit the loop once the option is removed
                                        //     }
                                        // }

                                    }
                                });

                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            highlightUpRows()
                            highlightDownRows()

                            brushedGenesScatter = []
                            brushScatterExtent = null; // Reset if there's no selection
                        }
                    }

                    // Function to highlight the selected genes based on the brush
                    function highlightSelectedGenes(selectedPoints) {
                        if (selectedGeneData.length > 0) {
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")

                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // Check if the element is already highlighted
                                    var isHighlighted = selectedGeneData.length > 0 && selectedElement.style("opacity") === "1";

                                    if (!isHighlighted) {

                                        scatter.selectAll("circle")
                                            .style("opacity", d => selectedPoints.some(p => p.gene === d.gene) ? "1" : 0.3)
                                            .attr("r", d => selectedPoints.some(p => p.gene === d.gene) ? "4" : "2")


                                        // If not highlighted, apply the highlighting
                                        selectedElement
                                            .style("opacity", "1")
                                            .attr("r", "4")

                                        console.log(d)


                                    }
                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);
                                });


                        }
                        else {
                            scatter.selectAll("circle").style("opacity", d => {
                                return 0.3; // Not significant
                            })

                            // Select all circles and filter only those that are in the selected points
                            scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
                                .each(function (d) {
                                    var selectedElement = d3.select(this);
                                    var currentFill = selectedElement.style("fill");

                                    // Check if the element is already filled with lightgrey
                                    if (currentFill === "lightgrey") {
                                        return; // If lightgrey, do nothing
                                    }

                                    // If not highlighted, apply the highlighting
                                    selectedElement
                                        .style("opacity", "1")
                                        .attr("r", "4")

                                    if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

                                });
                        }

                        if (selectedPoints.length >= 1) {
                            heatmap(heatmap_data);
                            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
                        }
                        if (ridge) {
                            updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                        }
                        highlightUpRows()
                        highlightDownRows()

                        console.log(selectedGeneData)
                    }
                    // Attach click event to the toggle zoom button
                    d3.select("#toggleZoomButton").on("click", function () {
                        zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

                        if (zoomEnabled) {
                            document.getElementById("resetButton").style.cursor = "pointer"
                            document.getElementById("resetButton").style.opacity = 1
                            document.getElementById("resetButton").disabled = false
                            document.getElementById("switchButton").style.cursor = "pointer"
                            document.getElementById("switchButton").style.opacity = 1
                            document.getElementById("switchButton").disabled = false

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
                            svg.call(zoom); // Re-enable zooming

                            brushScatterG.remove();
                            brushedGenesScatter = []

                            const indices = []

                            console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                            console.log(selectedGeneData)
                            d3.selectAll(".cell")
                                .filter(function () {
                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell");; // Select only cells that do NOT have the 'selected' class
                                })
                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                            selectedGeneData.forEach(name => {
                                const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                if (index !== -1) {
                                    indices.push(index); // Add the index if found
                                }
                            });
                            console.log(indices); // Log the collected indices

                            // Highlight the corresponding rows
                            indices.forEach(index => {
                                var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                // Highlight the row labels
                                var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                            });

                            d3.selectAll(".rnode").each(function (d) {
                                // console.log(d); // Log the current data object for debugging

                                d3.select(this).classed("selected", true)
                                // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                d3.select(this).select("circle")
                                    .style("stroke", null)
                                    .attr("r", function (d) {
                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                    });
                            });


                        } else {
                            document.getElementById("resetButton").style.cursor = "not-allowed"
                            document.getElementById("resetButton").style.opacity = 0.6
                            document.getElementById("resetButton").disabled = true
                            document.getElementById("switchButton").style.cursor = "not-allowed"
                            document.getElementById("switchButton").style.opacity = 0.6
                            document.getElementById("switchButton").disabled = true

                            document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
                            svg.on(".zoom", null); // Disable zooming by removing the zoom event

                            // Remove the brushes from the SVG

                            // Optionally, you can update the brush extents
                            brushScatter.extent([[0, 0], [width, height]]);

                            // Redraw brushes to reflect new zoom scale
                            brushScatterG = svg.append("g")
                                .attr("class", "brush-scatter")
                                .call(brushScatter);


                            brushedGenesScatter = []

                        }
                    });
                    // Define the resetZoom function
                    function resetZoom() {
                        // Reset the zoom transformation
                        svg.transition()
                            .duration(750)
                            .call(zoom.transform, d3.zoomIdentity);

                        // if (brushScatterExtent) {
                        //     brushScatterG.call(brushScatter.move, [
                        //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
                        //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
                        //     ]);
                        // }
                    }

                    function updateChart() {
                        if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
                        // recover the new scale
                        var newX = d3.event.transform.rescaleX(xScale);
                        var newY = d3.event.transform.rescaleY(yScale);

                        currentXScale = newX
                        currentYScale = newY

                        // update axes with these new boundaries
                        xAxis.call(d3.axisBottom(newX));
                        yAxis.call(d3.axisLeft(newY));

                        xAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        xAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        yAxis.selectAll("line, path")
                            .style("stroke", "var(--text-color)");

                        yAxis.selectAll("text")
                            .style("fill", "var(--text-color)");

                        // update circle position
                        scatter
                            .selectAll("circle")
                            .attr('cx', function (d) { return newX(d.meanExpr); })
                            .attr('cy', function (d) { return newY(d.logFC); });

                        brushScatter.extent([[0, 0], [width, height]]);

                        if (!zoomEnabled) {
                            // Redraw brushes to reflect new zoom scale
                            // brushScatterG.call(brushScatter);
                        }

                    }



                }
            }
            d3.select("#switchButton").on("click", function () {
                if (currentPlot === 'volcano') {
                    currentPlot = 'scatter';
                    SwitchingPlot(data, currentPlot)
                } else if (currentPlot === 'scatter') {
                    currentPlot = 'ma';
                    SwitchingPlot(data, currentPlot)
                }
                else {
                    currentPlot = 'volcano';
                    SwitchingPlot(data, currentPlot)
                }
            });
            dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
            // applyThemeToSVG()
        }




        // function updateScatterPlot(averageExpressionsN, averageExpressionsC, log_thr_fc, parsed, old_p_adj) {

        //     //console.log(parsed)

        //     var mostUpregulatedGene = parsed.reduce((maxGene, currentGene) => {
        //         return currentGene.logFC > maxGene.logFC ? currentGene : maxGene;
        //     }, parsed[0]);

        //     var mostDownregulatedGene = parsed.reduce((minGene, currentGene) => {
        //         return currentGene.logFC < minGene.logFC ? currentGene : minGene;
        //     }, parsed[0]);

        //     //console.log(mostUpregulatedGene)
        //     var mostUpregulatedGeneName = mostUpregulatedGene.Gene;
        //     var mostDownregulatedGeneName = mostDownregulatedGene.Gene;

        //     // Set up margin, width, and height
        //     var margin = { top: 10, right: 100, bottom: 40, left: 60 };
        //     var width = 1000 - margin.left - margin.right;
        //     var height = 600 - margin.top - margin.bottom;

        //     // Create SVG container
        //     var svg = d3.select("#scatterPlot")
        //         .html("")  // Clear previous content
        //         .append("svg")
        //         .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // Set the viewBox for scaling
        //         .attr("preserveAspectRatio", "xMidYMin") // Preserve aspect ratio
        //         .style("max-height", "580px")
        //         .append("g")
        //         .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        //     // Create x and y scales
        //     var xScale = d3.scaleLinear()
        //         .domain(d3.extent(Object.values(averageExpressionsN)))
        //         .range([0, width]);
        //     console.log("Domain:", xScale.domain());

        //     var yScale = d3.scaleLinear()
        //         .domain(d3.extent(Object.values(averageExpressionsC)))
        //         .range([height, 0])
        //         .nice()
        //     //console.log(yScale);

        //     var xAxis = svg.append("g")
        //         .attr("transform", "translate(0," + height + ")")
        //         .call(d3.axisBottom(xScale))

        //     xAxis.selectAll("line, path")
        //         .style("stroke", "var(--text-color)");

        //     xAxis.selectAll("text")
        //         .style("fill", "var(--text-color)");
        //     // Add Y axis
        //     var yAxis = svg.append("g")
        //         .call(d3.axisLeft(yScale))

        //     yAxis.selectAll("line, path")
        //         .style("stroke", "var(--text-color)");

        //     yAxis.selectAll("text")
        //         .style("fill", "var(--text-color)");

        //     // Customization

        //     var clip = svg.append("defs").append("SVG:clipPath")
        //         .attr("id", "clip")
        //         .append("SVG:rect")
        //         .attr("width", width)
        //         .attr("height", height)
        //         .attr("x", 0)
        //         .attr("y", 0);

        //     // Create the scatter variable: where both the circles and the brush take place
        //     svg.select("#scatter").selectAll("*").remove();
        //     scatter = svg.append('g')
        //         .attr("id", "scatter")
        //         .attr("clip-path", "url(#clip)");

        //     // Set the zoom and Pan features
        //     var zoom = d3.zoom()
        //         .scaleExtent([0.05, 20])
        //         .extent([[0, 0], [width, height]])
        //         .on("zoom", updateChart);

        //     // Add an invisible rect on top of the chart area
        //     svg.append("rect")
        //         .attr("width", width)
        //         .attr("height", height)
        //         .style("fill", "none")
        //         .style("pointer-events", "all")  // Set pointer-events to "all" here
        //         .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
        //         .lower();

        //     // Attach zoom behavior to the SVG
        //     svg.call(zoom);

        //     // Attach click event to the reset button
        //     d3.select("#resetButton")
        //         .on("click", resetZoom);

        //     // Add X axis label
        //     xlab = svg.append("text")
        //         .attr("x", width / 2)
        //         .attr("y", height + margin.bottom - 10)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "14px")
        //         .style("fill", "var(--text-color)")
        //         .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

        //     // Add Y axis label
        //     ylab = svg.append("text")
        //         .attr("transform", "rotate(-90)")
        //         .attr("x", -height / 2)
        //         .attr("y", -margin.left + 20)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "14px")
        //         .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
        //         .style("fill", "var(--text-color)");

        //     // Add title
        //     svg.append("text")
        //         .attr("id", "plotTitle")
        //         .attr("x", width / 2)
        //         .attr("y", 15)
        //         .attr("text-anchor", "middle")
        //         .style("font-size", "18px")
        //         .text("Scatter Plot")
        //         .style("fill", "var(--text-color)");

        //     // Create circles for each gene
        //     var data = Object.keys(averageExpressionsN).map(function (gene) {
        //         // Find the corresponding logFC value from parsedLogFC_origin
        //         var logFCObj = parsed.find(d => d.Gene === gene) || null;
        //         var logFC = logFCObj ? logFCObj.logFC : null;

        //         if (logFC <= log_thr_fc) {
        //             var type = "down"
        //         }
        //         else {
        //             var type = "up"
        //         }

        //         var pval_adjObj = old_p_adj.find(d => d.Gene === gene) || null;
        //         var pval_adj = pval_adjObj ? pval_adjObj.pval_adj : null;

        //         return { gene: gene, Normal: averageExpressionsN[gene], Case: averageExpressionsC[gene], logFC: logFC, pval_adj: pval_adj, type: type };
        //     });

        //     console.log(averageExpressionsN.length)
        //     //console.log(data.length)

        //     // Create a legend
        //     var legend = svg.append("g")
        //         .attr("transform", "translate(" + (width - 75) + "," + (height - 450) + ")");

        //     // Add a filter for the shadow
        //     var defs = svg.append("defs");

        //     var filter = defs.append("filter")
        //         .attr("id", "legendShadow")
        //         .attr("height", "150%");

        //     filter.append("feGaussianBlur")
        //         .attr("in", "SourceAlpha")
        //         .attr("stdDeviation", 3)
        //         .attr("result", "blur");

        //     filter.append("feOffset")
        //         .attr("in", "blur")
        //         .attr("dx", 3)
        //         .attr("dy", 3)
        //         .attr("result", "offsetBlur");

        //     var feMerge = filter.append("feMerge");

        //     feMerge.append("feMergeNode")
        //         .attr("in", "offsetBlur");
        //     feMerge.append("feMergeNode")
        //         .attr("in", "SourceGraphic");

        //     // Add a rectangle around the legend with shadow
        //     var legendRect = legend.append("rect")
        //         .attr("x", 0)
        //         .attr("y", 0)
        //         .attr("width", 160)
        //         .attr("height", 210)
        //         .style("stroke", "var(--text-color)")
        //         .style("fill", "none")
        //         .style("filter", "url(#legendShadow)")
        //         .style("pointer-events", "none");

        //     // Append legend for upregulated genes (LogFC > log2(thr_fc) and pval_adj < threshold)
        //     var upregulatedLegend = legend.append("g")
        //         .attr("transform", "translate(0,0)");

        //     upregulatedLegend.append("circle")
        //         .attr("cx", 10)
        //         .attr("cy", 20)
        //         .attr("r", 6)
        //         .style("fill", "#C14A82")
        //         .classed("legend-circle", true);

        //     upregulatedLegend.append("text")
        //         .attr("x", 20)
        //         .attr("y", 20)
        //         .style("fill", "var(--text-color)")
        //         .style("font-size", "12px")
        //         .text("Upregulated")
        //         .append("tspan")
        //         .attr("x", 20)
        //         .attr("dy", 15) // Adjusted spacing for subtitle
        //         .style("font-size", "12px") // Smaller font size for subtitle
        //         .text("LogFC > log2(" + thr_fc + ") and");

        //     upregulatedLegend.append("text")
        //         .attr("x", 20)
        //         .attr("y", 48)
        //         .style("fill", "var(--text-color)")
        //         .text("pval_adj < " + threshold)
        //         .style("font-size", "12px"); // Smaller font size for subtitle

        //     // Calculate the height of the first legend item
        //     var legendItemHeight = upregulatedLegend.node().getBBox().height;

        //     // Append legend for downregulated genes (LogFC < -log2(thr_fc) and pval_adj < threshold)
        //     var downregulatedLegend = legend.append("g")
        //         .attr("transform", "translate(0," + 58 + ")");

        //     downregulatedLegend.append("circle")
        //         .attr("cx", 10)
        //         .attr("cy", 65)
        //         .attr("r", 6)
        //         .style("fill", "#1A74D5")
        //         .classed("legend-circle", true);

        //     downregulatedLegend.append("text")
        //         .attr("x", 20)
        //         .attr("y", 68)
        //         .style("fill", "var(--text-color)")
        //         .style("font-size", "20px")
        //         .text("Downregulated")
        //         .append("tspan")
        //         .attr("x", 20)
        //         .attr("dy", 15) // Adjusted spacing for subtitle
        //         .style("font-size", "12px") // Smaller font size for subtitle
        //         .text("LogFC < -log2(" + thr_fc + ") and");

        //     downregulatedLegend.append("text")
        //         .attr("x", 20)
        //         .attr("y", 96)
        //         .style("fill", "var(--text-color)")
        //         .text("pval_adj < " + threshold)
        //         .style("font-size", "12px"); // Smaller font size for subtitle

        //     // Append legend for not significant genes (abs(LogFC) < log2(thr_fc) OR pval_adj > threshold)
        //     var notSignificantLegend = legend.append("g")
        //         .attr("transform", "translate(0," + 34+ ")");

        //     notSignificantLegend.append("circle")
        //         .attr("cx", 10)
        //         .attr("cy", 40)
        //         .attr("r", 6)
        //         .style("fill", "lightgrey")
        //         .style("opacity", "0.5")
        //         .classed("legend-circle", true);

        //     notSignificantLegend.append("text")
        //         .attr("x", 20)
        //         .attr("y", 40)
        //         .style("fill", "var(--text-color)")
        //         .style("font-size", "20px")
        //         .text("Not Significant")
        //         .append("tspan")
        //         .attr("x", 20)
        //         .attr("dy", 15) // Adjusted spacing for subtitle
        //         .style("font-size", "12px") // Smaller font size for subtitle
        //         .text("|LogFC| < log2(" + thr_fc + ") or");

        //     notSignificantLegend.append("text")
        //         .attr("x", 20)
        //         .attr("y", 68)
        //         .style("fill", "var(--text-color)")
        //         .text("pval_adj > " + threshold)
        //         .style("font-size", "12px"); // Smaller font size for subtitle

        //     // Add circles to the scatter plot
        //     var tooltip = d3.select("#tooltip");
        //     //console.log(data)
        //     svg.select("#scatter").selectAll("*").remove();
        //     scatter.selectAll("circle")
        //         .data(data)
        //         .enter().append("circle")
        //         .attr("cx", d => {
        //             // Log the value of d['Normal'] to inspect its format
        //             if (isNaN(d['Normal'])) {
        //                 console.log("NaN value found in 'Normal':", d['Normal']);
        //             }
        //             // Convert the value to a number, assuming it's a string
        //             return xScale(parseFloat(d['Normal']));
        //         })
        //         .attr("cy", d => yScale(d['Case']))
        //         .attr("r", d => {
        //             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                 return "2";
        //             }
        //             else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                 return "2";
        //             } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                 return "2";
        //             } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                 return "4"
        //             }
        //             else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
        //                 return "4"
        //             }
        //         })
        //         .style("fill", d => {

        //             // Check if logFC is greater than or equal to the threshold
        //             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

        //                 return "green";
        //             }
        //             else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

        //                 return "green";
        //             }
        //             else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

        //                 return "#C14A82";
        //             } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

        //                 return "#1A74D5";
        //             }
        //             else {
        //                 return "lightgrey";
        //             }
        //         })
        //         .style("opacity", function (d) {
        //             if (d.pval_adj < threshold) {
        //                 if (d.logFC >= log_thr_fc) {
        //                     return "1"; // Upregulated
        //                 } else if (d.logFC <= -log_thr_fc) {
        //                     return "1"; // Downregulated
        //                 } else {
        //                     return "0.5"; // Not significant
        //                 }
        //             } else {
        //                 return "0.5"; // Not significant
        //             }
        //         })
        //         .attr("data-initial-fill", d => {

        //             // Check if logFC is greater than or equal to the threshold
        //             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                 currentCircleFill = "green"
        //                 return "green";
        //             }
        //             else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                 currentCircleFill = "green"
        //                 return "green";
        //             }
        //             else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                 currentCircleFill = "#C14A82"
        //                 return "#C14A82";
        //             } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
        //                 currentCircleFill = "#1A74D5"
        //                 return "#1A74D5";
        //             }
        //         }

        //         )
        //         .classed('pulse', d => {
        //             // Check if logFC is greater than or equal to the threshold
        //             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                 return true;
        //             }
        //             else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                 return true;
        //             } else {
        //                 return false;
        //             }

        //         })
        //         .on("mouseover", function (d) {
        //             // Highlight the gene on mouseover
        //             d3.select(this)
        //                 .style("stroke", "black")
        //                 .style("stroke-width", 2);

        //             // Display tooltip on mouseover
        //             tooltip.transition()
        //                 .duration(200) // Add transition duration for mouseout
        //                 .style("opacity", .9);

        //             const parts = d.gene.split('|');
        //             // Use the first part as the gene name
        //             const geneName = parts[0];

        //             tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>${chosen_meta2}:</strong> ${d.Normal.toFixed(2)}<br><strong>${chosen_meta1}:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
        //                 .style("left", (d3.event.pageX + 15) + "px")
        //                 .style("top", (d3.event.pageY - 28) + "px");
        //         })
        //         .on("mouseout", function (d) {
        //             // Remove the highlight and hide tooltip on mouseout
        //             d3.select(this)
        //                 .style("stroke", "none");

        //             tooltip.transition()
        //                 .duration(200) // Add transition duration for mouseout
        //                 .style("opacity", 0)
        //                 .style("visibility", "none")
        //                 .style("pointer-events", "none"); // Disable pointer events for the tooltip
        //         })
        //         .on("click", function (d) {
        //             var selectedElement = d3.select(this);
        //             var currentFill = selectedElement.style("fill");

        //             // Check if the element is already filled with lightgrey
        //             if (currentFill === "lightgrey") {
        //                 return; // If lightgrey, do nothing
        //             }

        //             // Check if the element is already highlighted
        //             var isHighlighted = selectedElement.classed('pulse');

        //             if (isHighlighted) {
        //                 console.log("sono verde")
        //                 // If already highlighted, remove the highlighting
        //                 selectedElement.style("fill", d => {
        //                     // Check if logFC is greater than or equal to the threshold
        //                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                         return "#C14A82";
        //                     } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
        //                         return "#1A74D5";
        //                     } else {
        //                         return "lightgrey";
        //                     }

        //                 })
        //                     .classed('pulse', false)
        //                     .classed("pulse1", false);
        //                 selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                 // Find and remove the corresponding option from the select element
        //                 // var select = document.getElementById("selectButton");
        //                 // var options = select.options;

        //                 // for (var i = 0; i < options.length; i++) {
        //                 //     if (!selectedGeneData.includes(options[i].value)) {
        //                 //         select.removeChild(options[i]);
        //                 //         break; // Exit the loop once the option is removed
        //                 //     }
        //                 // }
        //                 heatmap(heatmap_data)
        //                 if (ridge) {
        //                     updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                 }
        //                 // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
        //             } else {
        //                 // If not highlighted, apply the highlighting
        //                 selectedElement
        //                     .style("fill", "green")
        //                     .style("stroke-width", 2)
        //                     .classed('pulse', true)
        //                     .classed('pulse1', false)

        //                 // On click, filter data for the selected gene
        //                 selectedGeneData.push(d.gene);

        //                 // Get the select element
        //                 // var select = document.getElementById("selectButton");

        //                 // // Add new options for the genes in selectedGeneData that are not already in the select element
        //                 // selectedGeneData.forEach(function (gene) {
        //                 //     if (!Array.from(select.options).some(option => option.value === gene)) {
        //                 //         var option = document.createElement("option");
        //                 //         option.value = gene;
        //                 //         option.text = gene;
        //                 //         select.appendChild(option);
        //                 //     }
        //                 // });

        //                 synchronizeAnimations(this);
        //                 heatmap(heatmap_data)
        //                 if (ridge) {
        //                     updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                 }
        //                 // Call a function to create parallel coordinates plot using selectedGeneData
        //                 // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
        //             }
        //         })

        //     // Variables to store the brush extents in the original data space
        //     let brushScatterExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

        //     let brushedGenesScatter = [];

        //     // Define brush for the left side (x < 0)
        //     var brushScatter = d3.brush()
        //         .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
        //         .on("end", updateBrushScatter);

        //     var brushScatterG

        //     // To get the current scale
        //     var currentXScale = xScale; // This will give you the reference to the xScale
        //     var currentYScale = yScale

        //     // Functions to handle brush events
        //     function updateBrushScatter() {
        //         const selection = d3.event.selection;  // Access event via d3.event in v4
        //         if (selection) {
        //             var [x0, y0] = selection[0]; // Get coordinates for left brush
        //             var [x1, y1] = selection[1];

        //             // Store the selection in data space, including y extents
        //             brushScatterExtent = [
        //                 [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
        //                 [currentXScale.invert(x1), currentYScale.invert(y1)]
        //             ];

        //             // Filter selected points based on the stored extents
        //             var selectedPoints = data.filter(d => {
        //                 return (
        //                     d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
        //                     d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
        //                 );
        //             });
        //             // Add genes to brushedGenes if they are not already present
        //             selectedPoints.forEach(point => {
        //                 if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
        //                     brushedGenesScatter.push(point.gene);
        //                 }
        //             });
        //             console.log("Brushed genes scatter", brushedGenesScatter)
        //             highlightSelectedGenes(selectedPoints);
        //         } else {
        //             console.log("Brushed genes scatter", brushedGenesScatter)
        //             // Remove the 'pulse' class from the brushed genes
        //             scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
        //                 .each(function (d) {
        //                     console.log(d)
        //                     var selectedElement = d3.select(this);
        //                     var currentFill = selectedElement.style("fill");

        //                     // Check if the element is already filled with lightgrey
        //                     if (currentFill === "lightgrey") {
        //                         return; // If lightgrey, do nothing
        //                     }

        //                     // Check if the element is already highlighted
        //                     var isHighlighted = selectedElement.classed('pulse');

        //                     if (isHighlighted) {
        //                         // If already highlighted, remove the highlighting
        //                         selectedElement.style("fill", d => {
        //                             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                                 return "#C14A82";
        //                             } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
        //                                 return "#1A74D5";
        //                             } else {
        //                                 return "lightgrey";
        //                             }
        //                         })
        //                             .classed('pulse', false)
        //                             .classed("pulse1", false);

        //                         selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                         // Find and remove the corresponding option from the select element
        //                         // var select = document.getElementById("selectButton");
        //                         // var options = select.options;

        //                         // for (var i = 0; i < options.length; i++) {
        //                         //     if (!selectedGeneData.includes(options[i].value)) {
        //                         //         select.removeChild(options[i]);
        //                         //         break; // Exit the loop once the option is removed
        //                         //     }
        //                         // }

        //                     }
        //                 });

        //             heatmap(heatmap_data);
        //             // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //             if (ridge) {
        //                 updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //             }
        //             brushedGenesScatter = []
        //             brushScatterExtent = null; // Reset if there's no selection
        //         }
        //     }

        //     // Function to highlight the selected genes based on the brush
        //     function highlightSelectedGenes(selectedPoints) {

        //         // Select all circles and filter only those that are in the selected points
        //         scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
        //             .each(function (d) {
        //                 var selectedElement = d3.select(this);
        //                 var currentFill = selectedElement.style("fill");

        //                 // Check if the element is already filled with lightgrey
        //                 if (currentFill === "lightgrey") {
        //                     return; // If lightgrey, do nothing
        //                 }

        //                 // Check if the element is already highlighted
        //                 var isHighlighted = selectedElement.classed('pulse');

        //                 if (!isHighlighted) {
        //                     // If not highlighted, apply the highlighting
        //                     selectedElement
        //                         .style("fill", "green")
        //                         .style("stroke-width", 2)
        //                         .classed('pulse', true)
        //                         .classed('pulse1', false)

        //                     if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

        //                     // Get the select element
        //                     // var select = document.getElementById("selectButton");

        //                     // // Add new options for the genes in selectedGeneData that are not already in the select element
        //                     // selectedGeneData.forEach(function (gene) {
        //                     //     if (!Array.from(select.options).some(option => option.value === gene)) {
        //                     //         var option = document.createElement("option");
        //                     //         option.value = gene;
        //                     //         option.text = gene;
        //                     //         select.appendChild(option);
        //                     //     }
        //                     // });

        //                     synchronizeAnimations(this);
        //                 }
        //             });

        //         if (selectedPoints.length >= 1) {
        //             heatmap(heatmap_data);
        //             if (ridge) {
        //                 updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //             }
        //             // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //         }
        //         scatter.selectAll("circle").each(function (d) {
        //             if (selectedGeneData.includes(d)) {
        //                 synchronizeAnimations(this)
        //             }
        //         })

        //     }

        //     // Set the zoom and pan features
        //     var zoom = d3.zoom()
        //         .scaleExtent([0.05, 20])
        //         .extent([[0, 0], [width, height]])
        //         .on("zoom", updateChart)
        //         .on("end", function () {
        //         })

        //     // Add an invisible rect on top of the chart area
        //     svg.append("rect")
        //         .attr("width", width)
        //         .attr("height", height)
        //         .style("fill", "none")
        //         .style("pointer-events", "all")
        //         .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
        //         .lower();

        //     // Attach click event to the reset button
        //     d3.select("#resetButton").on("click", resetZoom);

        //     // Attach click event to the toggle zoom button
        //     d3.select("#toggleZoomButton").on("click", function () {
        //         zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

        //         if (zoomEnabled) {
        //             document.getElementById("resetButton").style.cursor = "pointer"
        //             document.getElementById("resetButton").style.opacity = 1
        //             document.getElementById("resetButton").disabled = false
        //             document.getElementById("switchButton").style.cursor = "pointer"
        //             document.getElementById("switchButton").style.opacity = 1
        //             document.getElementById("switchButton").disabled = false

        //             document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
        //             svg.call(zoom); // Re-enable zooming

        //             brushScatterG.remove();
        //             brushedGenesScatter = []

        //         } else {
        //             document.getElementById("resetButton").style.cursor = "not-allowed"
        //             document.getElementById("resetButton").style.opacity = 0.6
        //             document.getElementById("resetButton").disabled = true
        //             document.getElementById("switchButton").style.cursor = "not-allowed"
        //             document.getElementById("switchButton").style.opacity = 0.6
        //             document.getElementById("switchButton").disabled = true

        //             document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
        //             svg.on(".zoom", null); // Disable zooming by removing the zoom event

        //             // Remove the brushes from the SVG

        //             // Optionally, you can update the brush extents
        //             brushScatter.extent([[0, 0], [width, height]]);

        //             // Redraw brushes to reflect new zoom scale
        //             brushScatterG = svg.append("g")
        //                 .attr("class", "brush-scatter")
        //                 .call(brushScatter);


        //             brushedGenesScatter = []

        //         }
        //     });

        //     // Define the resetZoom function
        //     function resetZoom() {
        //         // Reset the zoom transformation
        //         svg.transition()
        //             .duration(750)
        //             .call(zoom.transform, d3.zoomIdentity);

        //         // if (brushScatterExtent) {
        //         //     brushScatterG.call(brushScatter.move, [
        //         //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
        //         //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
        //         //     ]);
        //         // }
        //     }

        //     // Attach zoom behavior to the SVG
        //     svg.call(zoom);

        //     function updateChart() {
        //         if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
        //         // recover the new scale
        //         var newX = d3.event.transform.rescaleX(xScale);
        //         var newY = d3.event.transform.rescaleY(yScale);

        //         currentXScale = newX
        //         currentYScale = newY

        //         // update axes with these new boundaries
        //         xAxis.call(d3.axisBottom(newX));
        //         yAxis.call(d3.axisLeft(newY));

        //         xAxis.selectAll("line, path")
        //             .style("stroke", "var(--text-color)");

        //         xAxis.selectAll("text")
        //             .style("fill", "var(--text-color)");

        //         yAxis.selectAll("line, path")
        //             .style("stroke", "var(--text-color)");

        //         yAxis.selectAll("text")
        //             .style("fill", "var(--text-color)");

        //         // update circle position
        //         scatter
        //             .selectAll("circle")
        //             .attr('cx', function (d) { return newX(d.Normal); })
        //             .attr('cy', function (d) { return newY(d.Case); });

        //         brushScatter.extent([[0, 0], [width, height]]);

        //         if (!zoomEnabled) {
        //             // Redraw brushes to reflect new zoom scale
        //             // brushScatterG.call(brushScatter);
        //         }

        //     }

        //     function synchronizeAnimations(targetElement) {
        //         // Retrieve all elements with the class 'pulse'
        //         const elements = [
        //             ...document.querySelectorAll('.pulse'),
        //             ...document.querySelectorAll('.pulse1')
        //         ];

        //         // Retrieve the Animation object of the target element
        //         const targetAnimation = findAnimByName(targetElement, 'pulseAnimation');

        //         // Get the current time of the target animation
        //         const targetTime = targetAnimation.currentTime;

        //         // Loop through each element with the class 'pulse'
        //         elements.forEach(element => {
        //             let currentAnimation = findAnimByName(element, 'pulseAnimation');

        //             if (!currentAnimation) {
        //                 currentAnimation = findAnimByName(element, 'pulseAnimation1');
        //             }

        //             // Get the current time of the current animation
        //             const currentTime = currentAnimation.currentTime;

        //             // Calculate the time difference between the target animation and the current animation
        //             const timeDifference = targetTime - currentTime;

        //             // Adjust the playback position of the current animation to match the target animation
        //             currentAnimation.currentTime += timeDifference;
        //         });
        //     }

        //     // Simple helper to find an Animation by animationName
        //     function findAnimByName(elem, name) {
        //         // Get all the active animations on this element
        //         const anims = elem.getAnimations();

        //         // Return the first one with the expected animationName
        //         return anims.find((anim) => anim.animationName === name);
        //     }
        //     let brushLeftG
        //     let brushRightG
        //     let brushedGenesLeft = [];
        //     let brushedGenesRight = [];

        //     function SwitchingPlot(structure, choice) {

        //         if (choice == "volcano") {
        //             if (brushScatterG) brushScatterG.remove();
        //             brushedGenesScatter = []

        //             // Create x and y scales
        //             xScale.domain([
        //                 d3.min(data, d => d.logFC) - 0.5,
        //                 d3.max(data, d => d.logFC) + 0.5
        //             ]);

        //             yScale.domain([0, d3.max(data.filter(d => !isNaN(d.pval_adj) && d.pval_adj !== null), d => -Math.log10(d.pval_adj.toExponential(20))) + 1]);

        //             // Set the zoom and pan features
        //             zoom = d3.zoom()
        //                 .scaleExtent([0.05, 20])
        //                 .extent([[0, 0], [width, height]])
        //                 .on("zoom", updateChart)
        //                 .on("end", function () {
        //                 })

        //             // Reset zoom (assuming resetZoom is a function you have defined elsewhere)
        //             svg.transition()
        //                 .duration(750)
        //                 .call(zoom.transform, d3.zoomIdentity);


        //             // Variables to store the brush extents in the original data space
        //             let leftBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]
        //             let rightBrushExtent = null; // [ [logFC, -log10(pval_adj)], [logFC, -log10(pval_adj)] ]

        //             // if (leftBrushExtent) {
        //             //     brushLeftG.call(brushLeft.move, [
        //             //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
        //             //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
        //             //     ]);
        //             // }
        //             // if (rightBrushExtent) {
        //             //     brushRightG.call(brushRight.move, [
        //             //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
        //             //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
        //             //     ]);
        //             // }

        //             // Attach click event to the reset button
        //             d3.select("#resetButton")
        //                 .on("click", function () {
        //                     // Reset zoom (assuming resetZoom is a function you have defined elsewhere)
        //                     svg.transition()
        //                         .duration(750)
        //                         .call(zoom.transform, d3.zoomIdentity);

        //                     // if (leftBrushExtent) {
        //                     //     brushLeftG.call(brushLeft.move, [
        //                     //         [xScale(leftBrushExtent[0][0]), yScale(leftBrushExtent[0][1])], // Use original x and y extents
        //                     //         [xScale(leftBrushExtent[1][0]), yScale(leftBrushExtent[1][1])]
        //                     //     ]);
        //                     // }
        //                     // if (rightBrushExtent) {
        //                     //     brushRightG.call(brushRight.move, [
        //                     //         [xScale(rightBrushExtent[0][0]), yScale(rightBrushExtent[0][1])], // Use original x and y extents
        //                     //         [xScale(rightBrushExtent[1][0]), yScale(rightBrushExtent[1][1])]
        //                     //     ]);
        //                     // }

        //                 });



        //             // Update the zoom behavior to call updateChart1 (assuming updateChart1 is a function you have defined elsewhere)
        //             zoom.on("zoom", updateChart1);

        //             // Apply zoom behavior to the svg
        //             svg.call(zoom);

        //             // Transition the axes
        //             xAxis.transition().duration(1000)
        //                 .call(d3.axisBottom(xScale))
        //                 .selectAll("line, path")
        //                 .style("stroke", "var(--text-color)");

        //             xAxis.selectAll("text")
        //                 .style("fill", "var(--text-color)");

        //             yAxis.transition().duration(1000)
        //                 .call(d3.axisLeft(yScale))
        //                 .selectAll("line, path")
        //                 .style("stroke", "var(--text-color)");

        //             yAxis.selectAll("text")
        //                 .style("fill", "var(--text-color)");

        //             // Update title
        //             svg.select("#plotTitle")
        //                 .text("Volcano Plot")
        //                 .style("fill", "var(--text-color)");


        //             // Update dots
        //             var dot = svg.selectAll('circle').filter(function () {
        //                 return !d3.select(this).classed('legend-circle');
        //             }).data(structure);

        //             dot.enter().append("circle").merge(dot)
        //                 .classed('pulse', d => {
        //                     return selectedGeneData.some(selectedGene => selectedGene === d.gene);
        //                 })
        //             // Remove existing circles
        //             dot.exit().remove();

        //             dot.enter().append("circle").merge(dot)
        //                 .classed('pulse', d => {
        //                     return selectedGeneData.some(selectedGene => selectedGene === d.gene);
        //                 })
        //                 .on("mouseover", function (d) {
        //                     d3.select(this)
        //                         .style("stroke", "black")
        //                         .style("stroke-width", 2);

        //                     tooltip.transition()
        //                         .duration(200) // Add transition duration for mouseout
        //                         .style("opacity", .9);

        //                     tooltip.html(`<strong>Gene:</strong> ${d.gene}<br><strong>LogFC:</strong> ${parseFloat(d.logFC).toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? d.pval_adj.toExponential(2) : 'NA'}`)
        //                         .style("left", (d3.event.pageX + 15) + "px")
        //                         .style("top", (d3.event.pageY - 28) + "px");
        //                 })
        //                 .on("mouseout", function (d) {
        //                     // Remove the highlight and hide tooltip on mouseout
        //                     d3.select(this)
        //                         .style("stroke", "none");

        //                     tooltip.transition()
        //                         .duration(200) // Add transition duration for mouseout
        //                         .style("opacity", 0)
        //                         .style("visibility", "none")
        //                         .style("pointer-events", "none"); // Disable pointer events for the tooltip
        //                 })
        //                 .on("click", function (d) {
        //                     var selectedElement = d3.select(this);
        //                     var currentFill = selectedElement.style("fill");

        //                     // Check if the element is already filled with lightgrey
        //                     if (currentFill === "lightgrey") {
        //                         return; // If lightgrey, do nothing
        //                     }

        //                     // Check if the element is already highlighted
        //                     var isHighlighted = selectedElement.classed('pulse');

        //                     if (isHighlighted) {
        //                         // If already highlighted, remove the highlighting
        //                         selectedElement.style("fill", d => {
        //                             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                                 return "#C14A82";
        //                             } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
        //                                 return "#1A74D5";
        //                             } else {
        //                                 return "lightgrey";
        //                             }
        //                         })
        //                             .classed('pulse', false)
        //                             .classed("pulse1", false);

        //                         selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                         // Find and remove the corresponding option from the select element
        //                         // var select = document.getElementById("selectButton");
        //                         // var options = select.options;

        //                         // for (var i = 0; i < options.length; i++) {
        //                         //     if (!selectedGeneData.includes(options[i].value)) {
        //                         //         select.removeChild(options[i]);
        //                         //         break; // Exit the loop once the option is removed
        //                         //     }
        //                         // }
        //                         heatmap(heatmap_data)
        //                         if (ridge) {
        //                             updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                         }
        //                         // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                     } else {
        //                         // If not highlighted, apply the highlighting
        //                         selectedElement
        //                             .style("fill", "green")
        //                             .style("stroke-width", 2)
        //                             .classed('pulse', true)
        //                             .classed('pulse1', false)

        //                         // Find the corresponding scatterplot circle and toggle its selection
        //                         // var correspondingSquare = square
        //                         //     .filter(function (squaredata) {
        //                         //         return squaredata.gene === d.gene;
        //                         //     });

        //                         // correspondingSquare.style("stroke", "none");

        //                         // On click, filter data for the selected gene
        //                         selectedGeneData.push(d.gene);

        //                         // Get the select element
        //                         // var select = document.getElementById("selectButton");

        //                         // // Add new options for the genes in selectedGeneData that are not already in the select element
        //                         // selectedGeneData.forEach(function (gene) {
        //                         //     if (!Array.from(select.options).some(option => option.value === gene)) {
        //                         //         var option = document.createElement("option");
        //                         //         option.value = gene;
        //                         //         option.text = gene;
        //                         //         select.appendChild(option);
        //                         //     }
        //                         // });

        //                         synchronizeAnimations(this);
        //                         heatmap(heatmap_data)
        //                         if (ridge) {
        //                             updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                         }
        //                         // Call a function to create parallel coordinates plot using selectedGeneData
        //                         // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                     }
        //                 })
        //                 .transition()
        //                 .duration(1000)
        //                 .attr("cx", function (d) {
        //                     if (d.pval_adj !== null) {
        //                         return xScale(d.logFC)
        //                     }
        //                 })
        //                 .attr("cy", function (d) {
        //                     if (d.pval_adj !== null) {
        //                         return yScale(-Math.log10(d.pval_adj.toExponential(20)))
        //                     }
        //                 })
        //                 .attr("r", 2)
        //                 .style("fill", d => {
        //                     if (d.pval_adj < threshold) {
        //                         if (d.logFC >= log_thr_fc) {
        //                             return "#C14A82"; // Upregulated
        //                         } else if (d.logFC <= -log_thr_fc) {
        //                             return "#1A74D5"; // Downregulated
        //                         } else {
        //                             return "lightgrey"; // Not significant
        //                         }
        //                     } else {
        //                         return "lightgrey"; // Not significant
        //                     }
        //                 })
        //                 .style("opacity", function (d) {
        //                     if (d.pval_adj < threshold) {
        //                         if (d.logFC >= log_thr_fc) {
        //                             return "1"; // Upregulated
        //                         } else if (d.logFC <= -log_thr_fc) {
        //                             return "1"; // Downregulated
        //                         } else {
        //                             return "0.5"; // Not significant
        //                         }
        //                     } else {
        //                         return "0.5"; // Not significant
        //                     }
        //                 })
        //                 .attr("data-initial-fill", d => {
        //                     if (d.pval_adj < threshold) {
        //                         if (d.logFC >= log_thr_fc) {
        //                             return "#C14A82"; // Upregulated
        //                         } else if (d.logFC <= -log_thr_fc) {
        //                             return "#1A74D5"; // Downregulated
        //                         } else {
        //                             return "lightgrey"; // Not significant
        //                         }
        //                     } else {
        //                         return "lightgrey"; // Not significant
        //                     }
        //                 })


        //             // To get the current scale
        //             var currentXScale = xScale; // This will give you the reference to the xScale
        //             var currentYScale = yScale

        //             // Define brush for the left side (x < 0)
        //             var brushLeft = d3.brush()
        //                 .extent([[0, 0], [xScale(0), height]])  // Constrain the brush to the left side
        //                 .on("end", updateBrushLeft);

        //             // Define brush for the right side (x > 0)
        //             var brushRight = d3.brush()
        //                 .extent([[xScale(0), 0], [width, height]])  // Constrain the brush to the right side
        //                 .on("end", updateBrushRight);


        //             // Functions to handle brush events
        //             function updateBrushLeft() {
        //                 const selection = d3.event.selection;  // Access event via d3.event in v4
        //                 if (selection) {
        //                     var [x0, y0] = selection[0]; // Get coordinates for left brush
        //                     var [x1, y1] = selection[1];

        //                     // Store the selection in data space, including y extents
        //                     leftBrushExtent = [
        //                         [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
        //                         [currentXScale.invert(x1), currentYScale.invert(y1)]
        //                     ];

        //                     // Filter selected points based on the stored extents
        //                     var selectedPoints = data.filter(d => {
        //                         console.log(d.logFC)
        //                         console.log("X0>=log", leftBrushExtent[0][0], "X1<=log", leftBrushExtent[1][0])
        //                         console.log(-Math.log10(d.pval_adj))
        //                         console.log("Y0<=pval", leftBrushExtent[0][1], "Y0<=pval", leftBrushExtent[1][1])
        //                         return (
        //                             d.logFC >= leftBrushExtent[0][0] && d.logFC <= leftBrushExtent[1][0] &&
        //                             -Math.log10(d.pval_adj) <= leftBrushExtent[0][1] && -Math.log10(d.pval_adj) >= leftBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
        //                         );
        //                     });
        //                     // Add genes to brushedGenes if they are not already present
        //                     selectedPoints.forEach(point => {
        //                         if (!brushedGenesLeft.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
        //                             brushedGenesLeft.push(point.gene);
        //                         }
        //                     });
        //                     console.log("Brushed genes left", brushedGenesLeft)
        //                     highlightSelectedGenes(selectedPoints);
        //                 } else {
        //                     console.log("Brushed genes left", brushedGenesLeft)
        //                     // Remove the 'pulse' class from the brushed genes
        //                     scatter.selectAll("circle").filter(d => brushedGenesLeft.some(p => p === d.gene))
        //                         .each(function (d) {
        //                             console.log(d)
        //                             var selectedElement = d3.select(this);
        //                             var currentFill = selectedElement.style("fill");

        //                             // Check if the element is already filled with lightgrey
        //                             if (currentFill === "lightgrey") {
        //                                 return; // If lightgrey, do nothing
        //                             }

        //                             // Check if the element is already highlighted
        //                             var isHighlighted = selectedElement.classed('pulse');

        //                             if (isHighlighted) {
        //                                 // If already highlighted, remove the highlighting
        //                                 selectedElement.style("fill", d => {
        //                                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                                         return "#C14A82";
        //                                     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
        //                                         return "#1A74D5";
        //                                     } else {
        //                                         return "lightgrey";
        //                                     }
        //                                 })
        //                                     .classed('pulse', false)
        //                                     .classed("pulse1", false);

        //                                 selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                                 // Find and remove the corresponding option from the select element
        //                                 // var select = document.getElementById("selectButton");
        //                                 // var options = select.options;

        //                                 // for (var i = 0; i < options.length; i++) {
        //                                 //     if (!selectedGeneData.includes(options[i].value)) {
        //                                 //         select.removeChild(options[i]);
        //                                 //         break; // Exit the loop once the option is removed
        //                                 //     }
        //                                 // }

        //                             }
        //                         });

        //                     heatmap(heatmap_data);
        //                     // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                     if (ridge) {
        //                         updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                     }
        //                     brushedGenesLeft = []
        //                     leftBrushExtent = null; // Reset if there's no selection
        //                 }
        //             }

        //             function updateBrushRight() {
        //                 const selection = d3.event.selection;  // Access event via d3.event in v4
        //                 if (selection) {
        //                     var [x0, y0] = selection[0]; // Get coordinates for right brush
        //                     var [x1, y1] = selection[1];

        //                     // Store the selection in data space, including y extents
        //                     rightBrushExtent = [
        //                         [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
        //                         [currentXScale.invert(x1), currentYScale.invert(y1)]
        //                     ];

        //                     // Filter selected points based on the stored extents
        //                     var selectedPoints = data.filter(d =>
        //                         d.logFC >= rightBrushExtent[0][0] && d.logFC <= rightBrushExtent[1][0] &&
        //                         -Math.log10(d.pval_adj) <= rightBrushExtent[0][1] && -Math.log10(d.pval_adj) >= rightBrushExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
        //                     );
        //                     // Add genes to brushedGenes if they are not already present
        //                     selectedPoints.forEach(point => {
        //                         if (!brushedGenesRight.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
        //                             brushedGenesRight.push(point.gene);
        //                         }
        //                     });
        //                     highlightSelectedGenes(selectedPoints);
        //                 } else {
        //                     // Remove the 'pulse' class from the brushed genes
        //                     scatter.selectAll("circle").filter(d => brushedGenesRight.some(p => p === d.gene))
        //                         .each(function (d) {
        //                             console.log(d)
        //                             var selectedElement = d3.select(this);
        //                             var currentFill = selectedElement.style("fill");

        //                             // Check if the element is already filled with lightgrey
        //                             if (currentFill === "lightgrey") {
        //                                 return; // If lightgrey, do nothing
        //                             }

        //                             // Check if the element is already highlighted
        //                             var isHighlighted = selectedElement.classed('pulse');

        //                             if (isHighlighted) {
        //                                 // If already highlighted, remove the highlighting
        //                                 selectedElement.style("fill", d => {
        //                                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                                         return "#C14A82";
        //                                     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
        //                                         return "#1A74D5";
        //                                     } else {
        //                                         return "lightgrey";
        //                                     }
        //                                 })
        //                                     .classed('pulse', false)
        //                                     .classed("pulse1", false);

        //                                 selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                                 // Find and remove the corresponding option from the select element
        //                                 // var select = document.getElementById("selectButton");
        //                                 // var options = select.options;

        //                                 // for (var i = 0; i < options.length; i++) {
        //                                 //     if (!selectedGeneData.includes(options[i].value)) {
        //                                 //         select.removeChild(options[i]);
        //                                 //         break; // Exit the loop once the option is removed
        //                                 //     }
        //                                 // }

        //                             }
        //                         });

        //                     heatmap(heatmap_data);
        //                     // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                     if (ridge) {
        //                         updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                     }
        //                     brushedGenesRight = []
        //                     rightBrushExtent = null; // Reset if there's no selection
        //                 }
        //             }


        //             // Function to highlight the selected genes based on the brush
        //             function highlightSelectedGenes(selectedPoints) {

        //                 // Select all circles and filter only those that are in the selected points
        //                 scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
        //                     .each(function (d) {
        //                         var selectedElement = d3.select(this);
        //                         var currentFill = selectedElement.style("fill");

        //                         // Check if the element is already filled with lightgrey
        //                         if (currentFill === "lightgrey") {
        //                             return; // If lightgrey, do nothing
        //                         }

        //                         // Check if the element is already highlighted
        //                         var isHighlighted = selectedElement.classed('pulse');

        //                         if (!isHighlighted) {
        //                             // If not highlighted, apply the highlighting
        //                             selectedElement
        //                                 .style("fill", "green")
        //                                 .style("stroke-width", 2)
        //                                 .classed('pulse', true)
        //                                 .classed('pulse1', false)

        //                             if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

        //                             // Get the select element
        //                             // var select = document.getElementById("selectButton");

        //                             // // Add new options for the genes in selectedGeneData that are not already in the select element
        //                             // selectedGeneData.forEach(function (gene) {
        //                             //     if (!Array.from(select.options).some(option => option.value === gene)) {
        //                             //         var option = document.createElement("option");
        //                             //         option.value = gene;
        //                             //         option.text = gene;
        //                             //         select.appendChild(option);
        //                             //     }
        //                             // });

        //                             synchronizeAnimations(this);
        //                         }
        //                     });

        //                 if (selectedPoints.length >= 1) {
        //                     heatmap(heatmap_data);
        //                     if (ridge) {
        //                         updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                     }
        //                     // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                 }
        //                 scatter.selectAll("circle").each(function (d) {
        //                     if (selectedGeneData.includes(d)) {
        //                         synchronizeAnimations(this)
        //                     }
        //                 })

        //             }


        //             // Attach click event to the toggle zoom button
        //             d3.select("#toggleZoomButton").on("click", function () {

        //                 zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

        //                 if (zoomEnabled) {
        //                     document.getElementById("resetButton").style.cursor = "pointer"
        //                     document.getElementById("resetButton").style.opacity = 1
        //                     document.getElementById("resetButton").disabled = false
        //                     document.getElementById("switchButton").style.cursor = "pointer"
        //                     document.getElementById("switchButton").style.opacity = 1
        //                     document.getElementById("switchButton").disabled = false

        //                     document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
        //                     svg.call(zoom); // Re-enable zooming

        //                     brushLeftG.remove();
        //                     brushRightG.remove();
        //                     brushedGenesLeft = []
        //                     brushedGenesRight = []
        //                 } else {
        //                     document.getElementById("resetButton").style.cursor = "not-allowed"
        //                     document.getElementById("resetButton").style.opacity = 0.6
        //                     document.getElementById("resetButton").disabled = true
        //                     document.getElementById("switchButton").style.cursor = "not-allowed"
        //                     document.getElementById("switchButton").style.opacity = 0.6
        //                     document.getElementById("switchButton").disabled = true

        //                     document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
        //                     svg.on(".zoom", null); // Disable zooming by removing the zoom event

        //                     // Remove the brushes from the SVG

        //                     // Optionally, you can update the brush extents
        //                     brushLeft.extent([[0, 0], [currentXScale(0), height]]);
        //                     brushRight.extent([[currentXScale(0), 0], [width, height]]);

        //                     // Redraw brushes to reflect new zoom scale
        //                     brushLeftG = svg.append("g")
        //                         .attr("class", "brush-left")
        //                         .call(brushLeft);

        //                     brushRightG = svg.append("g")
        //                         .attr("class", "brush-right")
        //                         .call(brushRight);

        //                     brushedGenesLeft = []
        //                     brushedGenesRight = []

        //                 }
        //             });


        //             function updateChart1() {

        //                 if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled

        //                 // recover the new scale
        //                 var newX = d3.event.transform.rescaleX(xScale);
        //                 var newY = d3.event.transform.rescaleY(yScale);

        //                 currentXScale = newX
        //                 currentYScale = newY

        //                 // update axes with these new boundaries
        //                 xAxis.call(d3.axisBottom(newX));
        //                 yAxis.call(d3.axisLeft(newY));

        //                 xAxis.selectAll("line, path")
        //                     .style("stroke", "var(--text-color)");

        //                 xAxis.selectAll("text")
        //                     .style("fill", "var(--text-color)");

        //                 yAxis.selectAll("line, path")
        //                     .style("stroke", "var(--text-color)");

        //                 yAxis.selectAll("text")
        //                     .style("fill", "var(--text-color)");

        //                 // update circle position
        //                 scatter
        //                     .selectAll("circle")
        //                     .attr('cx', function (d) {
        //                         if (d.pval_adj !== null && !isNaN(d.pval_adj)) {
        //                             return newX(d.logFC);
        //                         } else {
        //                             return null;
        //                         }
        //                     })
        //                     .attr('cy', function (d) {
        //                         if (d.pval_adj !== null && !isNaN(d.pval_adj)) {
        //                             const pvalAdjLog = -Math.log10(d.pval_adj);
        //                             if (!isNaN(pvalAdjLog)) {
        //                                 return newY(pvalAdjLog);
        //                             }
        //                         }
        //                         return null;
        //                     });

        //                 // Update the brush extents
        //                 brushLeft.extent([[0, 0], [newX(0), height]]);
        //                 brushRight.extent([[newX(0), 0], [width, height]]);

        //                 if (!zoomEnabled) {
        //                     // Redraw brushes to reflect new zoom scale
        //                     brushLeftG.call(brushLeft);
        //                     brushRightG.call(brushRight);
        //                 }

        //             }
        //             xlab.html("")
        //             ylab.html("")

        //             // Add X axis label with logarithmic notation
        //             xlab = svg.append("text")
        //                 .attr("x", width / 2)
        //                 .attr("y", height + margin.bottom - 10)
        //                 .attr("text-anchor", "middle")
        //                 .style("font-size", "14px")
        //                 .style("fill", "var(--text-color)")
        //                 .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Fold Change)</tspan>");

        //             // Add Y axis label with logarithmic notation
        //             ylab = svg.append("text")
        //                 .attr("transform", "rotate(-90)")
        //                 .attr("x", -height / 2)
        //                 .attr("y", -margin.left + 20)
        //                 .attr("text-anchor", "middle")
        //                 .style("font-size", "14px")
        //                 .html("-log<tspan dy='5'>10</tspan> <tspan dy='-5'>(p-value)</tspan>")
        //                 .style("fill", "var(--text-color)");
        //         }

        //         else {
        //             if (brushLeftG) brushLeftG.remove();
        //             if (brushRightG) brushRightG.remove();
        //             brushedGenesLeft = []
        //             brushedGenesRight = []
        //             xScale = d3.scaleLinear()
        //                 .domain(d3.extent(Object.values(averageExpressionsN)))
        //                 .range([0, width]);
        //             //console.log("Domain:", xScale.domain());


        //             //console.log(averageExpressionsN);
        //             //console.log(averageExpressionsC);
        //             yScale = d3.scaleLinear()
        //                 .domain(d3.extent(Object.values(averageExpressionsC)))
        //                 .range([height, 0])
        //                 .nice()

        //             var currentXScale = xScale; // This will give you the reference to the xScale
        //             var currentYScale = yScale

        //             //console.log(yScale);

        //             // Set the zoom and pan features
        //             zoom = d3.zoom()
        //                 .scaleExtent([0.05, 20])
        //                 .extent([[0, 0], [width, height]])
        //                 .on("zoom", updateChart)
        //                 .on("end", function () {
        //                 })


        //             svg.transition()
        //                 .duration(750)
        //                 .call(zoom.transform, d3.zoomIdentity);

        //             // if (brushScatterExtent) {
        //             //     brushScatterG.call(brushScatter.move, [
        //             //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
        //             //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
        //             //     ]);
        //             // }
        //             zoom.on("zoom", updateChart);
        //             svg.call(zoom)

        //             // Transition the axes
        //             xAxis.transition().duration(1000)
        //                 .call(d3.axisBottom(xScale))
        //                 .selectAll("line, path")
        //                 .style("stroke", "var(--text-color)");

        //             xAxis.selectAll("text")
        //                 .style("fill", "var(--text-color)");

        //             yAxis.transition().duration(1000)
        //                 .call(d3.axisLeft(yScale))
        //                 .selectAll("line, path")
        //                 .style("stroke", "var(--text-color)");

        //             yAxis.selectAll("text")
        //                 .style("fill", "var(--text-color)");

        //             // Update title
        //             svg.select("#plotTitle")
        //                 .text("Scatter Plot")
        //                 .style("fill", "var(--text-color)");

        //             xlab.html("")
        //             ylab.html("")
        //             // Add X axis label
        //             xlab = svg.append("text")
        //                 .attr("x", width / 2)
        //                 .attr("y", height + margin.bottom - 10)
        //                 .attr("text-anchor", "middle")
        //                 .style("font-size", "14px")
        //                 .style("fill", "var(--text-color)")
        //                 .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta2 + "))</tspan>");

        //             // Add Y axis label
        //             ylab = svg.append("text")
        //                 .attr("transform", "rotate(-90)")
        //                 .attr("x", -height / 2)
        //                 .attr("y", -margin.left + 20)
        //                 .attr("text-anchor", "middle")
        //                 .style("font-size", "14px")
        //                 .html("log<tspan dy='5'>10</tspan> <tspan dy ='-5'>(Expression (" + chosen_meta1 + "))</tspan>")
        //                 .style("fill", "var(--text-color)");

        //             //svg.select("#scatter").selectAll("*").remove();

        //             // Update dots
        //             var dot = svg.selectAll('circle').filter(function () {
        //                 return !d3.select(this).classed('legend-circle');
        //             }).data(structure);

        //             dot.enter().append("circle").merge(dot)
        //                 .classed('pulse', d => {
        //                     return selectedGeneData.some(selectedGene => selectedGene === d.gene);
        //                 })

        //             // Remove existing circles
        //             dot.exit().remove();

        //             dot.enter().append("circle").merge(dot)
        //                 .classed('pulse', d => {
        //                     // Check if logFC is greater than or equal to the threshold
        //                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                         return true;
        //                     }
        //                     else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                         return true;
        //                     } else {
        //                         return false;
        //                     }

        //                 })
        //                 .on("mouseover", function (d) {
        //                     // Highlight the gene on mouseover
        //                     d3.select(this)
        //                         .style("stroke", "black")
        //                         .style("stroke-width", 2);

        //                     // Display tooltip on mouseover
        //                     tooltip.transition()
        //                         .duration(200) // Add transition duration for mouseout
        //                         .style("opacity", .9);

        //                     const parts = d.gene.split('|');
        //                     // Use the first part as the gene name
        //                     const geneName = parts[0];

        //                     tooltip.html(`<strong>Gene:</strong> ${geneName}<br><strong>${chosen_meta2}:</strong> ${d.Normal.toFixed(2)}<br><strong>${chosen_meta1}:</strong> ${d.Case.toFixed(2)}<br><strong>LogFC:</strong> ${d.logFC.toFixed(2)}<br><strong>pval-adj:</strong> ${d.pval_adj !== null ? formatPValue(d.pval_adj) : 'NA'}`)
        //                         .style("left", (d3.event.pageX + 15) + "px")
        //                         .style("top", (d3.event.pageY - 28) + "px");
        //                 })
        //                 .on("mouseout", function (d) {
        //                     // Remove the highlight and hide tooltip on mouseout
        //                     d3.select(this)
        //                         .style("stroke", "none");

        //                     tooltip.transition()
        //                         .duration(200) // Add transition duration for mouseout
        //                         .style("opacity", 0)
        //                         .style("visibility", "none")
        //                         .style("pointer-events", "none"); // Disable pointer events for the tooltip
        //                 })
        //                 .on("click", function (d) {
        //                     var selectedElement = d3.select(this);
        //                     var currentFill = selectedElement.style("fill");

        //                     // Check if the element is already filled with lightgrey
        //                     if (currentFill === "lightgrey") {
        //                         return; // If lightgrey, do nothing
        //                     }

        //                     // Check if the element is already highlighted
        //                     var isHighlighted = selectedElement.classed('pulse');

        //                     if (isHighlighted) {
        //                         console.log("sono verde")
        //                         // If already highlighted, remove the highlighting
        //                         selectedElement.style("fill", d => {
        //                             // Check if logFC is greater than or equal to the threshold
        //                             if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                                 return "#C14A82";
        //                             } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
        //                                 return "#1A74D5";
        //                             } else {
        //                                 return "lightgrey";
        //                             }

        //                         })
        //                             .classed('pulse', false)
        //                             .classed("pulse1", false);
        //                         selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                         // Find and remove the corresponding option from the select element
        //                         // var select = document.getElementById("selectButton");
        //                         // var options = select.options;

        //                         // for (var i = 0; i < options.length; i++) {
        //                         //     if (!selectedGeneData.includes(options[i].value)) {
        //                         //         select.removeChild(options[i]);
        //                         //         break; // Exit the loop once the option is removed
        //                         //     }
        //                         // }
        //                         heatmap(heatmap_data)
        //                         if (ridge) {
        //                             updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                         }
        //                         // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
        //                     } else {
        //                         // If not highlighted, apply the highlighting
        //                         selectedElement
        //                             .style("fill", "green")
        //                             .style("stroke-width", 2)
        //                             .classed('pulse', true)
        //                             .classed('pulse1', false)

        //                         // On click, filter data for the selected gene
        //                         selectedGeneData.push(d.gene);

        //                         // Get the select element
        //                         // var select = document.getElementById("selectButton");

        //                         // // Add new options for the genes in selectedGeneData that are not already in the select element
        //                         // selectedGeneData.forEach(function (gene) {
        //                         //     if (!Array.from(select.options).some(option => option.value === gene)) {
        //                         //         var option = document.createElement("option");
        //                         //         option.value = gene;
        //                         //         option.text = gene;
        //                         //         select.appendChild(option);
        //                         //     }
        //                         // });

        //                         synchronizeAnimations(this);
        //                         heatmap(heatmap_data)
        //                         if (ridge) {
        //                             updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                         }
        //                         // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
        //                     }
        //                 })
        //                 .transition()
        //                 .duration(1000)
        //                 .attr("cx", d => {
        //                     // Log the value of d['Normal'] to inspect its format
        //                     if (isNaN(d['Normal'])) {
        //                         console.log("NaN value found in 'Normal':", d['Normal']);
        //                     }
        //                     // Convert the value to a number, assuming it's a string
        //                     return xScale(parseFloat(d['Normal']));
        //                 })
        //                 .attr("cy", d => yScale(d['Case']))
        //                 .attr("r", d => {
        //                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                         return "2";
        //                     }
        //                     else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                         return "2";
        //                     } else if (d.gene != mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                         return "2";
        //                     } else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && d.gene == mostUpregulatedGeneName && d.gene != mostDownregulatedGeneName) {
        //                         return "4"
        //                     }
        //                     else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && d.gene != mostUpregulatedGeneName && d.gene == mostDownregulatedGeneName) {
        //                         return "4"
        //                     }
        //                 })
        //                 .style("fill", d => {

        //                     // Check if logFC is greater than or equal to the threshold
        //                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

        //                         return "green";
        //                     }
        //                     else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {

        //                         return "green";
        //                     }
        //                     else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {

        //                         return "#C14A82";
        //                     } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {

        //                         return "#1A74D5";
        //                     }
        //                     else {
        //                         return "lightgrey";
        //                     }
        //                 })
        //                 .style("opacity", function (d) {
        //                     if (d.pval_adj < threshold) {
        //                         if (d.logFC >= log_thr_fc) {
        //                             return "1"; // Upregulated
        //                         } else if (d.logFC <= -log_thr_fc) {
        //                             return "1"; // Downregulated
        //                         } else {
        //                             return "0.5"; // Not significant
        //                         }
        //                     } else {
        //                         return "0.5"; // Not significant
        //                     }
        //                 })

        //                 .attr("data-initial-fill", d => {

        //                     // Check if logFC is greater than or equal to the threshold
        //                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                         currentCircleFill = "green"
        //                         return "green";
        //                     }
        //                     else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold && selectedGeneData.some(selectedGene => selectedGene === d.gene)) {
        //                         currentCircleFill = "green"
        //                         return "green";
        //                     }
        //                     else if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                         currentCircleFill = "#C14A82"
        //                         return "#C14A82";
        //                     } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
        //                         currentCircleFill = "#1A74D5"
        //                         return "#1A74D5";
        //                     }
        //                 })

        //             brushScatter = d3.brush()
        //                 .extent([[0, 0], [width, height]])  // Constrain the brush to the left side
        //                 .on("end", updateBrushScatter);

        //             // Attach click event to the reset button
        //             d3.select("#resetButton").on("click", resetZoom);

        //             // Functions to handle brush events
        //             function updateBrushScatter() {
        //                 const selection = d3.event.selection;  // Access event via d3.event in v4
        //                 if (selection) {
        //                     var [x0, y0] = selection[0]; // Get coordinates for left brush
        //                     var [x1, y1] = selection[1];

        //                     // Store the selection in data space, including y extents
        //                     brushScatterExtent = [
        //                         [currentXScale.invert(x0), currentYScale.invert(y0)], // [logFC, -log10(pval_adj)]
        //                         [currentXScale.invert(x1), currentYScale.invert(y1)]
        //                     ];

        //                     // Filter selected points based on the stored extents
        //                     var selectedPoints = data.filter(d => {
        //                         return (
        //                             d.Normal >= brushScatterExtent[0][0] && d.Normal <= brushScatterExtent[1][0] &&
        //                             d.Case <= brushScatterExtent[0][1] && d.Case >= brushScatterExtent[1][1] && d.pval_adj < threshold && Math.abs(d.logFC) > (log_thr_fc)
        //                         );
        //                     });
        //                     // Add genes to brushedGenes if they are not already present
        //                     selectedPoints.forEach(point => {
        //                         if (!brushedGenesScatter.includes(point.gene) && !selectedGeneData.includes(point.gene)) {
        //                             brushedGenesScatter.push(point.gene);
        //                         }
        //                     });
        //                     console.log("Brushed genes scatter", brushedGenesScatter)
        //                     highlightSelectedGenes(selectedPoints);
        //                 } else {
        //                     console.log("Brushed genes scatter", brushedGenesScatter)
        //                     // Remove the 'pulse' class from the brushed genes
        //                     scatter.selectAll("circle").filter(d => brushedGenesScatter.some(p => p === d.gene))
        //                         .each(function (d) {
        //                             console.log(d)
        //                             var selectedElement = d3.select(this);
        //                             var currentFill = selectedElement.style("fill");

        //                             // Check if the element is already filled with lightgrey
        //                             if (currentFill === "lightgrey") {
        //                                 return; // If lightgrey, do nothing
        //                             }

        //                             // Check if the element is already highlighted
        //                             var isHighlighted = selectedElement.classed('pulse');

        //                             if (isHighlighted) {
        //                                 // If already highlighted, remove the highlighting
        //                                 selectedElement.style("fill", d => {
        //                                     if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
        //                                         return "#C14A82";
        //                                     } else if (d.logFC <= -log_thr_fc && d.pval_adj <= threshold) {
        //                                         return "#1A74D5";
        //                                     } else {
        //                                         return "lightgrey";
        //                                     }
        //                                 })
        //                                     .classed('pulse', false)
        //                                     .classed("pulse1", false);

        //                                 selectedGeneData = selectedGeneData.filter(gene => gene !== d.gene);

        //                                 // Find and remove the corresponding option from the select element
        //                                 // var select = document.getElementById("selectButton");
        //                                 // var options = select.options;

        //                                 // for (var i = 0; i < options.length; i++) {
        //                                 //     if (!selectedGeneData.includes(options[i].value)) {
        //                                 //         select.removeChild(options[i]);
        //                                 //         break; // Exit the loop once the option is removed
        //                                 //     }
        //                                 // }

        //                             }
        //                         });

        //                     heatmap(heatmap_data);
        //                     // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                     if (ridge) {
        //                         updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                     }
        //                     brushedGenesScatter = []
        //                     brushScatterExtent = null; // Reset if there's no selection
        //                 }
        //             }

        //             // Function to highlight the selected genes based on the brush
        //             function highlightSelectedGenes(selectedPoints) {

        //                 // Select all circles and filter only those that are in the selected points
        //                 scatter.selectAll("circle").filter(d => selectedPoints.some(p => p.gene === d.gene))
        //                     .each(function (d) {
        //                         var selectedElement = d3.select(this);
        //                         var currentFill = selectedElement.style("fill");

        //                         // Check if the element is already filled with lightgrey
        //                         if (currentFill === "lightgrey") {
        //                             return; // If lightgrey, do nothing
        //                         }

        //                         // Check if the element is already highlighted
        //                         var isHighlighted = selectedElement.classed('pulse');

        //                         if (!isHighlighted) {
        //                             // If not highlighted, apply the highlighting
        //                             selectedElement
        //                                 .style("fill", "green")
        //                                 .style("stroke-width", 2)
        //                                 .classed('pulse', true)
        //                                 .classed('pulse1', false)

        //                             if (!selectedGeneData.includes(d.gene)) selectedGeneData.push(d.gene);

        //                             // Get the select element
        //                             // var select = document.getElementById("selectButton");

        //                             // // Add new options for the genes in selectedGeneData that are not already in the select element
        //                             // selectedGeneData.forEach(function (gene) {
        //                             //     if (!Array.from(select.options).some(option => option.value === gene)) {
        //                             //         var option = document.createElement("option");
        //                             //         option.value = gene;
        //                             //         option.text = gene;
        //                             //         select.appendChild(option);
        //                             //     }
        //                             // });

        //                             synchronizeAnimations(this);
        //                         }
        //                     });

        //                 if (selectedPoints.length >= 1) {
        //                     heatmap(heatmap_data);
        //                     if (ridge) {
        //                         updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
        //                     }
        //                     // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims);
        //                 }
        //                 scatter.selectAll("circle").each(function (d) {
        //                     if (selectedGeneData.includes(d)) {
        //                         synchronizeAnimations(this)
        //                     }
        //                 })

        //             }

        //             // Attach click event to the toggle zoom button
        //             d3.select("#toggleZoomButton").on("click", function () {
        //                 zoomEnabled = !zoomEnabled; // Toggle the zoomEnabled flag

        //                 if (zoomEnabled) {
        //                     document.getElementById("resetButton").style.cursor = "pointer"
        //                     document.getElementById("resetButton").style.opacity = 1
        //                     document.getElementById("resetButton").disabled = false
        //                     document.getElementById("switchButton").style.cursor = "pointer"
        //                     document.getElementById("switchButton").style.opacity = 1
        //                     document.getElementById("switchButton").disabled = false

        //                     document.getElementById("toggleZoomButton").innerHTML = '<i class="fa fa-brush"></i> Toggle Zoom/Brush Mode'
        //                     svg.call(zoom); // Re-enable zooming

        //                     brushScatterG.remove();
        //                     brushedGenesScatter = []

        //                 } else {
        //                     document.getElementById("resetButton").style.cursor = "not-allowed"
        //                     document.getElementById("resetButton").style.opacity = 0.6
        //                     document.getElementById("resetButton").disabled = true
        //                     document.getElementById("switchButton").style.cursor = "not-allowed"
        //                     document.getElementById("switchButton").style.opacity = 0.6
        //                     document.getElementById("switchButton").disabled = true

        //                     document.getElementById("toggleZoomButton").innerHTML = '<i class="fas fa-save"></i> Toggle Zoom/Save Brushed Genes';
        //                     svg.on(".zoom", null); // Disable zooming by removing the zoom event

        //                     // Remove the brushes from the SVG

        //                     // Optionally, you can update the brush extents
        //                     brushScatter.extent([[0, 0], [width, height]]);

        //                     // Redraw brushes to reflect new zoom scale
        //                     brushScatterG = svg.append("g")
        //                         .attr("class", "brush-scatter")
        //                         .call(brushScatter);


        //                     brushedGenesScatter = []

        //                 }
        //             });
        //             // Define the resetZoom function
        //             function resetZoom() {
        //                 // Reset the zoom transformation
        //                 svg.transition()
        //                     .duration(750)
        //                     .call(zoom.transform, d3.zoomIdentity);

        //                 // if (brushScatterExtent) {
        //                 //     brushScatterG.call(brushScatter.move, [
        //                 //         [xScale(brushScatterExtent[0][0]), yScale(brushScatterExtent[0][1])], // Use original x and y extents
        //                 //         [xScale(brushScatterExtent[1][0]), yScale(brushScatterExtent[1][1])]
        //                 //     ]);
        //                 // }
        //             }

        //             function updateChart() {
        //                 if (!zoomEnabled) return; // Prevent zoom updates if zoom is disabled
        //                 // recover the new scale
        //                 var newX = d3.event.transform.rescaleX(xScale);
        //                 var newY = d3.event.transform.rescaleY(yScale);

        //                 currentXScale = newX
        //                 currentYScale = newY

        //                 // update axes with these new boundaries
        //                 xAxis.call(d3.axisBottom(newX));
        //                 yAxis.call(d3.axisLeft(newY));

        //                 xAxis.selectAll("line, path")
        //                     .style("stroke", "var(--text-color)");

        //                 xAxis.selectAll("text")
        //                     .style("fill", "var(--text-color)");

        //                 yAxis.selectAll("line, path")
        //                     .style("stroke", "var(--text-color)");

        //                 yAxis.selectAll("text")
        //                     .style("fill", "var(--text-color)");

        //                 // update circle position
        //                 scatter
        //                     .selectAll("circle")
        //                     .attr('cx', function (d) { return newX(d.Normal); })
        //                     .attr('cy', function (d) { return newY(d.Case); });

        //                 brushScatter.extent([[0, 0], [width, height]]);

        //                 if (!zoomEnabled) {
        //                     // Redraw brushes to reflect new zoom scale
        //                     // brushScatterG.call(brushScatter);
        //                 }

        //             }



        //         }
        //     }



        //     d3.select("#switchButton").on("click", function () {
        //         if (currentPlot === 'volcano') {
        //             currentPlot = 'scatter';
        //             SwitchingPlot(data, currentPlot)
        //         } else {
        //             currentPlot = 'volcano';
        //             SwitchingPlot(data, currentPlot)
        //         }
        //     });
        //     // dynamicParallel(selectedGeneData, data_copy, dataC_copy, dataN_copy, first_dims)
        //     applyThemeToSVG()
        // }


        function formatPValue(pval) {
            // Check if the p-value is too small to be displayed without scientific notation
            if (pval < 0.01) {
                // Use toExponential to format the p-value in scientific notation with two decimal places
                return pval.toExponential(3);
            } else {
                // Otherwise, use toFixed to format the p-value with two decimal places
                return pval.toFixed(2);
            }
        }


        let last_box = ""
        var svgBox
        function updateBoxPlot(genename, parsedLogFC, dataN, dataC) {
            console.log(genename)
            // Define histogram parameters
            var svgWidth = 600;
            var svgHeight = 350;
            var margin = { top: 30, right: 20, bottom: 40, left: 50 };
            var width = svgWidth - margin.left - margin.right;
            var height = svgHeight - 20;
            if (combinedData.length == 0) {
                last_box = genename
                geneNameUP = genename;

                console.log(dataN_copy_pval[0])


                var geneDataN = dataN_copy.filter(d => d.gene === geneNameUP)
                var geneDataC = dataC_copy.filter(d => d.gene === geneNameUP)


                console.log(geneDataC)

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => !key.startsWith('gene'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => !key.startsWith('gene'));


                function computeBoxPlotStatistics(data1) {
                    var expressionValues = data1.map(entry => entry.expression);

                    // Sort the data for calculating quartiles
                    expressionValues.sort((a, b) => a - b);

                    // Calculate quartiles and median
                    var q1 = d3.quantile(expressionValues, 0.25);
                    var q3 = d3.quantile(expressionValues, 0.75);
                    var median = d3.median(expressionValues);

                    // Calculate interquartile range (IQR)
                    var iqr = q3 - q1;


                    var min = q1 - 1.5 * iqr
                    var max = q3 + 1.5 * iqr

                    return {
                        q1: q1,
                        median: median,
                        q3: q3,
                        iqr: iqr,
                        min: min,
                        max: max
                    };
                }

                let expressionValuesC
                geneDataC.forEach(entry => {
                    expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })

                //console.log(expressionValuesC)

                let expressionValuesN
                geneDataN.forEach(entry => {
                    expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));

                })
                // Assuming you have expressionValuesC and expressionValuesN

                // Create a new array to store the combined data
                //combinedData;

                // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: chosen_meta1 });
                });

                // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: chosen_meta2 });
                });

                console.log(combinedData)

                var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                sumstat = d3.nest()
                    .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                    .rollup(function (d) {
                        q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                        median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                        q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                        interQuantileRange = q3 - q1;
                        min = q1 - 1.5 * interQuantileRange;
                        max = q3 + 1.5 * interQuantileRange;

                        return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                    })
                    .entries(combinedData);


                svgBox = d3.select("#boxPlot")
                    .html("")  // Clear previous content
                    .append("svg")
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`) // Set the viewBox for scaling
                    .append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + 0 + ")");


                var x = d3.scaleBand()
                    .range([0, width])
                    .domain([chosen_meta2, chosen_meta1])
                    .paddingInner(1)
                    .paddingOuter(.5)

                var xAxis = svgBox.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x))
                xAxis.selectAll("line, path")
                    .style("stroke", "var(--text-color)");
                xAxis.selectAll("text")
                    .style("fill", "var(--text-color)");

                // Calculate min and max from sumstat
                const minSumStat = d3.min(sumstat, d => d.value.min);
                const maxSumStat = d3.max(sumstat, d => d.value.max);

                // Calculate min and max from expressionValuesC and expressionValuesN
                const minExpressionC = d3.min(expressionValuesC);
                const maxExpressionC = d3.max(expressionValuesC);
                const minExpressionN = d3.min(expressionValuesN);
                const maxExpressionN = d3.max(expressionValuesN);

                // Determine the overall min and max for the y-axis
                const overallMin = Math.min(minSumStat, minExpressionC, minExpressionN);
                const overallMax = Math.max(maxSumStat, maxExpressionC, maxExpressionN);

                // Set the y-axis scale
                var y = d3.scaleLinear()
                    .domain([overallMin - 4, overallMax + 4]) // Adding padding of 4
                    .range([height, 0]);

                var yAxisGroup = svgBox.append("g")
                    .attr("class", "y-axis") // Assign a class to the group element
                    .call(d3.axisLeft(y));

                // Append the y-axis label
                yAxisGroup.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", -40)  // Adjust the position as needed
                    .attr("x", -height / 2)
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .style("fill", "var(--text-color)")
                    .style("font-size", "14px")
                    .html("log<tspan dy='5'>2</tspan> <tspan dy ='-5'>(Expression)");


                // You can further customize the appearance of the axis elements if needed
                yAxisGroup.selectAll("line, path")
                    .style("stroke", "var(--text-color)");

                yAxisGroup.selectAll("text")
                    .style("fill", "var(--text-color)");

                // Add a title
                var title = svgBox.append("text")
                    .attr("class", "title")
                    .attr("x", width / 2)
                    .attr("y", margin.top)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .text("Gene " + geneNameUP)
                    .style("fill", "var(--text-color)");

                svgBox.selectAll(".vertLines")
                    .data(sumstat)
                    .transition()
                    .duration(1000)

                var line1 = svgBox
                    .selectAll(".vertLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "vertLines")
                    .attr("x1", function (d) { return (x(d.key)) })
                    .attr("x2", function (d) { return (x(d.key)) })
                    .attr("y1", function (d) { return (y(d.value.min)) })
                    .attr("y2", function (d) { return (y(d.value.max)) })
                    .attr("stroke", "black")
                    .style("width", 40)


                // rectangle for the main box
                var boxWidth = 100
                var box1 = svgBox
                    .selectAll(".boxes")
                    .data(sumstat)
                    .enter()
                    .append("rect")
                    .attr("class", "boxes")
                    .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("y", function (d) { return (y(d.value.q3)) })
                    .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                    .attr("width", boxWidth)
                    .attr("stroke", "black")
                    .style("fill", function (d) {
                        if (d.key === chosen_meta1) {
                            return "#a05853"
                        }
                        else {
                            return "#118e91"
                        }
                    })
                var line2 = svgBox
                    .selectAll(".medianLines")
                    .data(sumstat)
                    .enter()
                    .append("line")
                    .attr("class", "medianLines")
                    .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                    .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                    .attr("y1", function (d) { return (y(d.value.median)) })
                    .attr("y2", function (d) { return (y(d.value.median)) })
                    .attr("stroke", "black")
                    .style("width", 80)

                var jitterWidth = 50
                var jitter = svgBox
                    .selectAll(".indPoints")
                    .data(combinedData)
                    .enter()
                    .append("circle")
                    .attr("class", function (d) {
                        // Add the pulse-red class if the GSM is in the gsmList
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                    .attr("cx", function (d) { return (x(d.type) - jitterWidth / 2 + Math.random() * jitterWidth) })
                    .attr("cy", function (d) { return (y(d.expression)) })
                    .attr("r", 2)
                    .style("fill", "white")
                    .attr("stroke", function (d) {

                        return gsmList.includes(d.GSM) ? "black" : "black";

                    })
                    .attr("stroke-width", function (d) {
                        // Set stroke width based on presence in gsmList
                        return gsmList.includes(d.GSM) ? 3 : 1;
                    })
                    .on("click", function (d) {
                        // On click, select the circle and add the GSM value to the list
                        var selectedGSM = d.GSM;
                        var isSelected = gsmList.includes(selectedGSM);
                        // console.log(isSelected);

                        // Toggle selection state
                        if (!isSelected) {
                            gsmList.push(selectedGSM);

                        } else {
                            gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                        }

                        // Update class, stroke, and stroke-width
                        d3.select(this)
                            .classed("pulse-red", !isSelected)
                            .attr("stroke", isSelected ? "black" : "black")
                            .attr("stroke-width", isSelected ? 1 : 2);

                        synchronizeAnimations();

                        // Call necessary update functions
                        // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy, dataN_copy, first_dims, ordering);
                        console.log("PCA DATA IN BOXPLOT", pca_data)
                        pca(pca_data);


                    });


                // Determine the X positions for each group (left and right rectangles)
                const leftBoxX = x(chosen_meta2) - boxWidth / 2;
                const rightBoxX = x(chosen_meta1) - boxWidth / 2;

                // Set the extent of the brush for the left box (chosen_meta2)
                const brushLeft = d3.brush()
                    .extent([[leftBoxX, 0], [leftBoxX + boxWidth, height]]) // Constrain to the left box
                    .on("end", brushended);

                // Set the extent of the brush for the right box (chosen_meta1)
                const brushRight = d3.brush()
                    .extent([[rightBoxX, 0], [rightBoxX + boxWidth, height]]) // Constrain to the right box
                    .on("end", brushended);

                // Function to handle brushing for both sides
                function brushended() {
                    var selection = d3.event.selection; // Get the brush selection
                    var isLeftBrush = d3.select(this).attr("class").includes("brush-left"); // Check if it's the left brush
                    var isRightBrush = d3.select(this).attr("class").includes("brush-right"); // Check if it's the right brush

                    // Define brush regions (left or right)
                    const leftBoxX = x(chosen_meta2) - boxWidth / 2;
                    const rightBoxX = x(chosen_meta1) - boxWidth / 2;

                    // Handle deselection when no selection is made
                    if (!selection) {
                        svgBox.selectAll(".indPoints")
                            .filter(function (d) {
                                const cx = d3.select(this).attr("cx");

                                // Filter only for the left or right points depending on the brush
                                if (isLeftBrush) {
                                    return cx >= leftBoxX && cx <= leftBoxX + boxWidth;
                                } else if (isRightBrush) {
                                    return cx >= rightBoxX && cx <= rightBoxX + boxWidth;
                                }
                            })
                            .each(function (d) {
                                // Clear selection for these points
                                d3.select(this)
                                    .classed("pulse-red", false)
                                    .attr("stroke", "black")
                                    .attr("stroke-width", 1);

                                // Clear GSM list for this region
                                gsmList = gsmList.filter(gsm => gsm !== d.GSM);
                            });
                    } else {
                        // Handle the case when there is a selection
                        svgBox.selectAll(".indPoints")
                            .filter(function (d) {
                                const cx = d3.select(this).attr("cx");
                                const cy = d3.select(this).attr("cy");

                                // Apply filtering for the respective region
                                if (isLeftBrush) {
                                    return cx >= leftBoxX && cx <= leftBoxX + boxWidth &&
                                        selection[0][0] <= cx && cx <= selection[1][0] &&
                                        selection[0][1] <= cy && cy <= selection[1][1];
                                } else if (isRightBrush) {
                                    return cx >= rightBoxX && cx <= rightBoxX + boxWidth &&
                                        selection[0][0] <= cx && cx <= selection[1][0] &&
                                        selection[0][1] <= cy && cy <= selection[1][1];
                                }
                            })
                            .each(function (d) {
                                // On click, select the circle and add the GSM value to the list
                                var selectedGSM = d.GSM;
                                var isSelected = gsmList.includes(selectedGSM);

                                if (!isSelected) {
                                    gsmList.push(selectedGSM);
                                }

                                // Update class, stroke, and stroke-width
                                d3.select(this)
                                    .classed("pulse-red", gsmList.includes(selectedGSM))
                                    .attr("stroke", isSelected ? "black" : "black")
                                    .attr("stroke-width", !gsmList.includes(selectedGSM) ? 1 : 2);
                            });
                    }

                    // Call necessary update functions
                    synchronizeAnimations();
                    // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy, dataN_copy, first_dims, ordering);
                    pca(pca_data);
                }

                // Append the left brush (for left rectangle)
                svgBox.append("g")
                    .attr("class", "brush-left")
                    .call(brushLeft);

                // Append the right brush (for right rectangle)
                svgBox.append("g")
                    .attr("class", "brush-right")
                    .call(brushRight);


            } else {

                if (genename !== last_box) {
                    console.log(last_box)
                    last_box = genename
                    combinedData = []
                    geneNameUP = genename;
                    console.log(genename)

                    var geneDataN = dataN_copy.filter(d => d.gene === geneNameUP)
                    var geneDataC = dataC_copy.filter(d => d.gene === geneNameUP)



                    // Extract GSM values for each gene
                    console.log(geneDataC[0])
                    var gsmValuesC = Object.keys(geneDataC[0]).filter(key => !key.startsWith('gene'));
                    var gsmValuesN = Object.keys(geneDataN[0]).filter(key => !key.startsWith('gene'));
                    console.log(gsmValuesN)


                    function computeBoxPlotStatistics(data1) {
                        var expressionValues = data1.map(entry => entry.expression);

                        // Sort the data for calculating quartiles
                        expressionValues.sort((a, b) => a - b);

                        // Calculate quartiles and median
                        var q1 = d3.quantile(expressionValues, 0.25);
                        var q3 = d3.quantile(expressionValues, 0.75);
                        var median = d3.median(expressionValues);

                        // Calculate interquartile range (IQR)
                        var iqr = q3 - q1;


                        var min = q1 - 1.5 * iqr
                        var max = q3 + 1.5 * iqr

                        return {
                            q1: q1,
                            median: median,
                            q3: q3,
                            iqr: iqr,
                            min: min,
                            max: max
                        };
                    }

                    let expressionValuesC
                    geneDataC.forEach(entry => {
                        expressionValuesC = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })

                    //console.log(expressionValuesC)

                    let expressionValuesN
                    geneDataN.forEach(entry => {
                        expressionValuesN = Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val));
                    })
                    // Assuming you have expressionValuesC and expressionValuesN

                    // Create a new array to store the combined data
                    //combinedData;

                    // Iterate over expressionValuesC and add objects to combinedData with type 'case'
                    expressionValuesC.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: chosen_meta1 });
                    });

                    // Iterate over expressionValuesN and add objects to combinedData with type 'normal'
                    expressionValuesN.forEach((expression, i) => {
                        combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: chosen_meta2 });
                    });

                    console.log(combinedData)

                    var boxPlotStatisticsC = computeBoxPlotStatistics(combinedData);


                    sumstat = d3.nest()
                        .key(function (d) { return d.type; }) // Assuming 'type' is the property indicating 'normal' or 'case'
                        .rollup(function (d) {
                            q1 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.25);
                            median = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.5);
                            q3 = d3.quantile(d.map(function (g) { return g.expression; }).sort(d3.ascending), 0.75);
                            interQuantileRange = q3 - q1;
                            min = q1 - 1.5 * interQuantileRange;
                            max = q3 + 1.5 * interQuantileRange;

                            return { q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max };
                        })
                        .entries(combinedData);
                    var margin = { top: 10, right: 30, bottom: 30, left: 50 },
                        width = 500,
                        height = 330;


                    // // Select the SVG element
                    // var svg = d3.select("#boxPlot").select("svg")
                    //     .attr("width", "100%")
                    //     .attr("height", "100%")
                    //     .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`) // Set the viewBox for scaling
                    //     .select("g");

                    var x = d3.scaleBand()
                        .range([0, width])
                        .domain([chosen_meta2, chosen_meta1])
                        .paddingInner(1)
                        .paddingOuter(.5)

                    // Calculate min and max from sumstat
                    const minSumStat = d3.min(sumstat, d => d.value.min);
                    const maxSumStat = d3.max(sumstat, d => d.value.max);

                    // Calculate min and max from expressionValuesC and expressionValuesN
                    const minExpressionC = d3.min(expressionValuesC);
                    const maxExpressionC = d3.max(expressionValuesC);
                    const minExpressionN = d3.min(expressionValuesN);
                    const maxExpressionN = d3.max(expressionValuesN);

                    // Determine the overall min and max for the y-axis
                    const overallMin = Math.min(minSumStat, minExpressionC, minExpressionN);
                    const overallMax = Math.max(maxSumStat, maxExpressionC, maxExpressionN);

                    // Set the y-axis scale
                    var y = d3.scaleLinear()
                        .domain([overallMin - 4, overallMax + 4]) // Adding padding of 4
                        .range([height, 0]);

                    // Update y-axis
                    svgBox.select(".y-axis")
                        .transition()
                        .duration(1000)
                        .call(d3.axisLeft(y));

                    // Update axis styles
                    svgBox.selectAll(".y-axis line, .y-axis path")
                        .style("stroke", "var(--text-color)");

                    svgBox.selectAll(".y-axis text")
                        .style("fill", "var(--text-color)");


                    // Select the existing title element
                    var title = svgBox.select(".title");

                    // Update the title text and transition its position
                    title.text("Gene " + geneNameUP)

                    var line1 = svgBox.selectAll(".vertLines")
                        .data(sumstat);

                    // Remove old lines
                    line1.exit().remove();

                    // Update existing lines
                    line1.transition()
                        .duration(1000)
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    // Append new lines
                    line1.enter()
                        .append("line")
                        .attr("class", "vertLines")
                        .attr("y1", function (d) { return y(d.value.min); })
                        .attr("y2", function (d) { return y(d.value.max); })
                        .attr("stroke", "black")
                        .style("width", 40);

                    boxWidth = 100

                    // Define the initial position and size of the boxes
                    var box1 = svgBox.selectAll(".boxes")
                        .data(sumstat);

                    // Remove old boxes
                    box1.exit().remove();

                    // Update existing boxes
                    box1.transition()
                        .duration(1000)
                        .attr("y", function (d) {
                            return y(d.value.q3);
                        })
                        .attr("height", function (d) {
                            return y(d.value.q1) - y(d.value.q3);
                        })
                        .attr("width", boxWidth) // Keep width constant
                        .style("fill", function (d) {
                            return d.key === chosen_meta1 ? "#a05853" : "#118e91";
                        });

                    // Append new boxes and smoothly transition them to their new positions
                    box1.enter()
                        .append("rect")
                        .attr("class", "boxes")
                        .attr("stroke", "black")
                        .style("fill", function (d) {
                            return d.key === chosen_meta1 ? "#a05853" : "#118e91";
                        })
                        .attr("y", function (d) { return y(d.value.q3); }) // Set initial position
                        .attr("height", 0) // Set initial height to 0
                        .attr("width", boxWidth) // Keep width constant
                        .transition() // Transition to new position and size
                        .duration(1000)
                        .attr("y", function (d) { return y(d.value.q3); }) // Transition to new y position
                        .attr("height", function (d) { return y(d.value.q1) - y(d.value.q3); }); // Transition to new height

                    // Select existing median lines and smoothly update them
                    var medianLines = svgBox.selectAll(".medianLines")
                        .data(sumstat);

                    // Remove old median lines
                    medianLines.exit().remove();

                    // Update existing median lines
                    medianLines.transition()
                        .duration(1000)
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Append new median lines
                    medianLines.enter()
                        .append("line")
                        .attr("class", "medianLines")
                        .attr("stroke", "black")
                        .style("width", 80)
                        .attr("y1", function (d) { return y(d.value.median); })
                        .attr("y2", function (d) { return y(d.value.median); });

                    // Select the existing title or append a new one if it doesn't exist
                    var title = svgBox.selectAll(".title")
                        .data([0]); // Use dummy data to ensure only one title is selected or appended

                    // Update existing title text
                    title.text("Gene " + geneNameUP);

                    // Append new title if it doesn't exist
                    title.enter()
                        .append("text")
                        .attr("class", "title")
                        .attr("text-anchor", "middle")
                        .style("font-size", "18px")
                        .style("fill", "var(--text-color)")
                        .text("Gene " + geneNameUP);

                    // Smoothly transition the title position
                    title.transition()

                    // Update jitter points
                    var jitterWidth = 50;
                    var jitter = svgBox.selectAll(".indPoints")
                        .data(combinedData);

                    jitter.enter()
                        .append("circle")
                        .attr("class", ".indPoints")
                        .attr("stroke", "black")
                        .style("fill", "white")
                        .attr("r", 2)
                        .merge(jitter)
                        .transition()
                        .duration(1000)
                        .attr("cy", function (d) { return y(d.expression); });

                    jitter.exit().remove();

                } else {
                    console.log(dataN_copy_pval[0])

                    console.log("Sono update box, gene ricevuto " + genename)

                    // // Select the SVG element
                    // var svg = d3.select("#boxPlot").select("svg")
                    //     .attr("width", "100%")
                    //     .attr("height", "100%")
                    //     .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`) // Set the viewBox for scaling
                    //     .select("g");


                    var jitterWidth = 50
                    // Define the update selection for the jitter circles
                    var jitterUpdate = svgBox.selectAll(".indPoints")
                        .data(combinedData);

                    console.log(combinedData)

                    // Update the class, stroke, and stroke width based on the GSM list
                    jitterUpdate.attr("class", function (d) {
                        // console.log(gsmList.includes(d.GSM));
                        if (gsmList.includes(d.GSM)) {
                            // this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                        }
                        return gsmList.includes(d.GSM) ? "indPoints pulse-red" : "indPoints";
                    })
                        .attr("stroke", function (d) {
                            return gsmList.includes(d.GSM) ? "black" : "black";
                        })
                        .attr("stroke-width", function (d) {
                            return gsmList.includes(d.GSM) ? 3 : 1;
                        })
                        .on("click", function (d) {
                            console.log(d)
                            var selectedGSM = d.GSM;
                            var isSelected = gsmList.includes(selectedGSM);
                            // console.log(isSelected);

                            // Toggle selection state
                            if (!isSelected) {
                                gsmList.push(selectedGSM);
                            } else {
                                gsmList = gsmList.filter(gsm => gsm !== selectedGSM);
                            }

                            // Update class, stroke, and stroke-width
                            d3.select(this)
                                .classed("pulse-red", !isSelected)
                                .attr("stroke", isSelected ? "black" : "black")
                                .attr("stroke-width", isSelected ? 1 : 2);
                            synchronizeAnimations()
                            // Call necessary update functions
                            // dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy, dataN_copy, first_dims, ordering);
                            console.log("PCA DATA IN BOXPLOT", pca_data)
                            pca(pca_data);
                        });

                    // Enter selection: No need to append new circles, as we're only updating existing ones

                    // Remove old circles
                    jitterUpdate.exit().remove();
                }
            }
            d3.select("#selectButton").on("change", function (d) {

                // recover the option that has been chosen
                var selectedOption = d3.select(this).property("value")
                console.log(selectedOption)
                updateBoxPlot(selectedOption, parsedLogFC, dataN_copy, dataC_copy)
            })

            synchronizeAnimations()


            function synchronizeAnimations() {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")
                console.log(elements)
                if (elements.length === 0) {
                    return
                }

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(elements[0], 'pulseRedAnimation');

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }
            applyThemeToSVG()
        }


        function updateRidgePlot(selectedGenes, parsedLogFC, dataN, dataC) {
            console.log(selectedGenes);

            // Check if no genes are selected
            if (selectedGenes.length === 0) {
                // Clear the SVG container and show the message
                const svgRidge = d3.select("#boxPlot")
                    .html("") // Clear any previous content

                // Add a message in the center of the container
                svgRidge.append("text")
                    .attr("x", "50%")
                    .attr("y", "50%")
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "middle")
                    .style("font-size", "18px")
                    .style("fill", "#000")
                    .text("Please, select at least one gene to show miRNAs/genes distributions");

                return;  // Exit the function as no plot needs to be drawn
            }

            // Separate up and down regulated genes
            const upRegulated = parsedLogFC.filter(gene => gene.logFC > 0 && selectedGenes.includes(gene.Gene));
            const downRegulated = parsedLogFC.filter(gene => gene.logFC < 0 && selectedGenes.includes(gene.Gene));

            const sortedUpGenes = upRegulated.map(gene => gene.Gene);
            const sortedDownGenes = downRegulated.map(gene => gene.Gene);

            // Calculate proportions for up- and down-regulated sections
            const totalGenes = upRegulated.length + downRegulated.length;
            const upHeightRatio = upRegulated.length / totalGenes;
            const downHeightRatio = downRegulated.length / totalGenes;

            // Set up ridge plot parameters
            // var svgWidth = 510;
            // var svgHeight = 600;
            var margin = { top: 70, right: 20, bottom: 120, left: 50 };
            // var width = svgWidth - margin.left - margin.right;
            // var height = svgHeight - margin.top - margin.bottom; //460

            var width = document.getElementById("boxPlot").clientWidth - margin.left - margin.right;
            var height = document.getElementById("boxPlot").clientHeight - margin.top - margin.bottom;


            var svgRidge = d3.select("#boxPlot")
                .html("")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr("preserveAspectRatio", "xMidYMin meet")
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Define x scale (same for both groups)
            var x = d3.scaleLinear()
                .domain([0, d3.max([...sortedUpGenes, ...sortedDownGenes], gene => {
                    let geneDataN = dataN.filter(d => d.gene === gene);
                    let geneDataC = dataC.filter(d => d.gene === gene);
                    let expressionValuesC = geneDataC.map(entry => Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val))).flat();
                    let expressionValuesN = geneDataN.map(entry => Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val))).flat();
                    return d3.max([...expressionValuesC, ...expressionValuesN]) + 10;
                })])
                .range([0, width]);

            // Define y scales for up-regulated and down-regulated genes
            const paddingBetweenGroups = 40;
            // var yUp = d3.scaleBand()
            //     .domain(sortedUpGenes)
            //     .range([0, (height / 2) - paddingBetweenGroups / 2])
            //     .paddingInner(0.1);

            // var yDown = d3.scaleBand()
            //     .domain(sortedDownGenes)
            //     .range([(height / 2) + paddingBetweenGroups / 2, height])
            //     .paddingInner(0.1);

            // Proportioned heights:

            // Define the y scales for up- and down-regulated genes
            // Conditional y scale setup for up-regulated genes
            var yUp;
            if (upRegulated.length > 0) {
                yUp = d3.scaleBand()
                    .domain(sortedUpGenes)
                    .range([0, height * upHeightRatio - paddingBetweenGroups / 2])
                    .paddingInner(0.1);
            }

            // Conditional y scale setup for down-regulated genes
            var yDown;
            if (downRegulated.length > 0) {
                yDown = d3.scaleBand()
                    .domain(sortedDownGenes)
                    .range([height * (1 - downHeightRatio) + paddingBetweenGroups / 2, height])
                    .paddingInner(0.1);
            }


            if (only_miRNAs) {
                // Title
                svgRidge.append("text")
                    .attr("x", width / 2)
                    .attr("y", -(margin.top / 2) - 10)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "16px")
                    .text("Ridge Plot for Selected miRNAs");
            } else {
                // Title
                svgRidge.append("text")
                    .attr("x", width / 2)
                    .attr("y", -(margin.top / 2) - 10)
                    .attr("text-anchor", "middle")
                    .attr("font-size", "16px")
                    .text("Ridge Plot for Selected genes");
            }
            // Kernel density estimation
            var kde = kernelDensityEstimator(kernelEpanechnikov(4), x.ticks(40));
            var allDensity = [];

            [...sortedUpGenes, ...sortedDownGenes].forEach(gene => {
                let geneDataN = dataN.filter(d => d.gene === gene);
                let geneDataC = dataC.filter(d => d.gene === gene);
                let expressionValuesC = geneDataC.map(entry => Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val))).flat();
                let expressionValuesN = geneDataN.map(entry => Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val))).flat();
                const densityDataC = kde(expressionValuesC);
                const densityDataN = kde(expressionValuesN);
                allDensity.push({ key: gene, densityC: densityDataC, densityN: densityDataN });
            });

            var overlap = 1.5;

            if (selectedGenes.length > 10) {
                overlap = 2
            }

            const z = d3.scaleLinear()
                .domain([0, d3.max(allDensity, d => Math.max(d3.max(d.densityC, d => d[1]), d3.max(d.densityN, d => d[1])))])
                .nice()
                .range([0, -overlap * Math.min(yUp?.step() || 1000, yDown?.step() || 1000)]);

            function calculateStats(expressionValues) {
                const mean = d3.mean(expressionValues);
                const median = d3.median(expressionValues);
                const stdev = d3.deviation(expressionValues);
                const min = d3.min(expressionValues);
                const max = d3.max(expressionValues);

                return {
                    mean: mean ? mean.toFixed(2) : "N/A",
                    median: median ? median.toFixed(2) : "N/A",
                    stdev: stdev ? stdev.toFixed(2) : "N/A",
                    min: min ? min.toFixed(2) : "N/A",
                    max: max ? max.toFixed(2) : "N/A",
                };
            }

            // Draw density areas
            allDensity.forEach(d => {
                const yScale = sortedUpGenes.includes(d.key) ? yUp : yDown;

                // Retrieve the expression values for the gene
                const geneDataC = dataC.filter(entry => entry.gene === d.key);
                const geneDataN = dataN.filter(entry => entry.gene === d.key);
                const expressionValuesC = geneDataC.map(entry => Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val))).flat();
                const expressionValuesN = geneDataN.map(entry => Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val))).flat();

                // Function to highlight the density area and show the tooltip
                function highlightDensity(path, color, expressionValues, otherPath) {
                    path
                        .on("mouseover", function () {
                            // Set opacity of the other path to 0.1
                            otherPath.attr("opacity", 0.1);

                            d3.select(this)
                                .attr("opacity", 1) // Full opacity when hovered
                                .style("stroke", color) // Optional: add a border to the highlighted area
                                .style("stroke-width", 2);

                            // Show the tooltip with relevant stats (mean and median)
                            const stats = calculateStats(expressionValues); // Pass the correct expression values

                            tooltip.style("visibility", "visible")
                                .style("top", (d3.event.pageY - 28) + "px")
                                .style("left", (d3.event.pageX + 15) + "px")
                                .html(`<strong>${d.key}</strong><br>
                    <strong>Mean:</strong> ${stats.mean}<br>
                    <strong>Median:</strong> ${stats.median}<br>
                    <strong>Standard deviation:</strong> ${stats.stdev}<br>
                    <strong>Min:</strong> ${stats.min}<br>
                    <strong>Max:</strong> ${stats.max}<br>`);
                        })
                        .on("mousemove", function () {
                            tooltip.style("top", (d3.event.pageY - 28) + "px")
                                .style("left", (d3.event.pageX + 15) + "px");
                        })
                        .on("mouseout", function () {
                            // Reset opacity of both paths
                            d3.select(this).attr("opacity", 0.3);
                            otherPath.attr("opacity", 0.3);

                            d3.select(this)
                                .style("stroke", "color") // Optional: add a border to the highlighted area
                                .style("stroke-width", 2)
                                .style("stroke-opacity", 1)

                            tooltip.style("visibility", "hidden"); // Hide the tooltip
                        });
                }

                // Case: Up-regulated genes density
                const upDensity = svgRidge.append("path")
                    .datum(d.densityC)
                    .attr("class", "case") // Add class to identify up-density
                    .attr("fill", "#F4B653")
                    .attr("opacity", 0.3)
                    .style("stroke", "#da972b") // Optional: add a border to the highlighted area
                    .style("stroke-width", 2)
                    .style("stroke-opacity", 1)
                    .attr("transform", "translate(0," + (yScale(d.key) + yScale.bandwidth()) + ")")
                    .attr("d", d3.area()
                        .x(d => x(d[0]))
                        .y0(0)
                        .y1(d => z(d[1]))
                    );

                // Normal: Down-regulated genes density
                const downDensity = svgRidge.append("path")
                    .datum(d.densityN)
                    .attr("class", "normal") // Add class to identify down-density
                    .attr("fill", "#53D16E")
                    .attr("opacity", 0.3)
                    .style("stroke", "#3fab56") // Optional: add a border to the highlighted area
                    .style("stroke-width", 2)
                    .style("stroke-opacity", 1)
                    .attr("transform", "translate(0," + (yScale(d.key) + yScale.bandwidth()) + ")")
                    .attr("d", d3.area()
                        .x(d => x(d[0]))
                        .y0(0)
                        .y1(d => z(d[1]))
                    );

                // Apply highlight function to each path, passing the other path for opacity control
                highlightDensity(upDensity, "#da972b", expressionValuesC, downDensity);
                highlightDensity(downDensity, "#3fab56", expressionValuesN, upDensity);
            });

            // Append x-axis
            svgRidge.append("g")
                .attr("class", "x-axis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            // Tooltip setup
            var tooltip = d3.select("body").append("div")
                .style("position", "absolute")
                .style("background-color", "#fff")
                .style("border", "1px solid #ccc")
                .style("border-radius", "4px")
                .style("pointer-events", "none")
                .style("visibility", "hidden")
                .style("font-size", "12px");

            // Add y-axis with gene names and separate truncation
            const formatTick = d => d.length > 8 ? d.substring(0, 6) + "..." : d;

            // Conditional rendering for y-axes
            if (yUp) {
                svgRidge.append("g")
                    .attr("class", "y-axis-up")
                    .call(d3.axisLeft(yUp).tickFormat(formatTick))
                    .selectAll(".tick text")
                    .on("mouseover", function (d) {
                        tooltip.style("visibility", "visible").text(d);
                    })
                    .on("mousemove", function () {
                        tooltip.style("top", (d3.event.pageY - 28) + "px").style("left", (d3.event.pageX + 15) + "px");
                    })
                    .on("mouseout", function () {
                        tooltip.style("visibility", "hidden");
                    });
            }

            if (yDown) {
                svgRidge.append("g")
                    .attr("class", "y-axis-down")
                    .call(d3.axisLeft(yDown).tickFormat(formatTick))
                    .selectAll(".tick text")
                    .on("mouseover", function (d) {
                        tooltip.style("visibility", "visible").text(d);
                    })
                    .on("mousemove", function () {
                        tooltip.style("top", (d3.event.pageY - 28) + "px").style("left", (d3.event.pageX + 15) + "px");
                    })
                    .on("mouseout", function () {
                        tooltip.style("visibility", "hidden");
                    });
            }

            svgRidge.select(".x-axis .domain").style("display", "none");

            svgRidge.append("text")
                .attr("x", width / 2)
                .attr("y", height + 30)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .html("log<tspan dy='5'>2</tspan> <tspan dy='-5'>(Gene Expressions)</tspan>");

            var stringmir = "miRNAs"
            if (!only_miRNAs) {
                stringmir = "genes"
            }

            if (yUp) {
                // Group for "UpRegulated miRNAs"
                const upLegendGroup = svgRidge.append("g")
                    .attr("transform", `translate(${width - 140}, 0)`); // Position the group

                // Add the text
                upLegendGroup.append("text")
                    .attr("x", 8) // Slightly offset to the right of the circle
                    .attr("y", 5)
                    .attr("text-anchor", "start") // Align text to start near the circle
                    .attr("font-size", "12px")
                    .text("UpRegulated " + stringmir);

                // Add the circle
                upLegendGroup.append("circle")
                    .attr("cx", 0) // Circle position
                    .attr("cy", 0)
                    .attr("r", 6)
                    .style("fill", "#C14A82")
                    .classed("legend-circle", true);

                if (downRegulated.length > 0) {
                    // Group for "DownRegulated miRNAs"
                    const downLegendGroup = svgRidge.append("g")
                        .attr("transform", `translate(${width - 140}, ${height * upHeightRatio + 10})`); // Position the group

                    // Add the text
                    downLegendGroup.append("text")
                        .attr("x", 8) // Slightly offset to the right of the circle
                        .attr("y", 5)
                        .attr("text-anchor", "start") // Align text to start near the circle
                        .attr("font-size", "12px")
                        .text("DownRegulated " + stringmir);

                    // Add the circle
                    downLegendGroup.append("circle")
                        .attr("cx", 0) // Circle position
                        .attr("cy", 0)
                        .attr("r", 6)
                        .style("fill", "#1A74D5")
                        .classed("legend-circle", true);
                }
            } else if (yDown) {
                // Group for "DownRegulated miRNAs" only
                const downLegendGroup = svgRidge.append("g")
                    .attr("transform", `translate(${width - 140}, 0)`); // Position the group

                // Add the text
                downLegendGroup.append("text")
                    .attr("x", 8) // Slightly offset to the right of the circle
                    .attr("y", 5)
                    .attr("text-anchor", "start") // Align text to start near the circle
                    .attr("font-size", "12px")
                    .text("DownRegulated " + stringmir);

                // Add the circle
                downLegendGroup.append("circle")
                    .attr("cx", 0) // Circle position
                    .attr("cy", 0)
                    .attr("r", 6)
                    .style("fill", "#1A74D5")
                    .classed("legend-circle", true);
            }

            // Append the legend to the right of the plot
            const legendWidth = 20;
            const legendHeight = 5;
            const legendSpacing = 5;

            const legendGroup = svgRidge.append("g")
                .attr("transform", `translate(${width - 100}, ${-(margin.top / 2) - 10})`);

            // Helper function to truncate text if it exceeds 8 characters
            function truncateText(text, maxLength) {
                return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
            }

            // Up-regulated legend
            legendGroup.append("rect")
                .attr("x", 0)
                .attr("y", 0)
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .attr("fill", "#F4B653"); // Color for case

            legendGroup.append("text")
                .attr("x", legendWidth + 5)
                .attr("y", legendHeight / 2)
                .text(truncateText(chosen_meta1, 15)) // Truncate if longer than 8 characters
                .style("font-size", "10px")
                .attr("alignment-baseline", "middle")
                .on("mouseover", function () {
                    tooltip.style("visibility", "visible").text(chosen_meta1);
                })
                .on("mousemove", function () {
                    tooltip.style("top", (d3.event.pageY - 28) + "px").style("left", (d3.event.pageX + 15) + "px");
                })
                .on("mouseout", function () {
                    tooltip.style("visibility", "hidden");
                });

            // Down-regulated legend
            legendGroup.append("rect")
                .attr("x", 0)
                .attr("y", legendHeight + legendSpacing)
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .attr("fill", "#53D16E"); // Color for normal

            legendGroup.append("text")
                .attr("x", legendWidth + 5)
                .attr("y", legendHeight + legendSpacing + legendHeight / 2)
                .text(truncateText(chosen_meta2, 15)) // Truncate if longer than 8 characters
                .style("font-size", "10px")
                .attr("alignment-baseline", "middle")
                .on("mouseover", function () {
                    tooltip.style("visibility", "visible").text(chosen_meta2);
                })
                .on("mousemove", function () {
                    tooltip.style("top", (d3.event.pageY - 28) + "px").style("left", (d3.event.pageX + 15) + "px");
                })
                .on("mouseout", function () {
                    tooltip.style("visibility", "hidden");
                });
        }

        // Kernel density estimation functions
        function kernelDensityEstimator(kernel, X) {
            return function (V) {
                return X.map(function (x) {
                    return [x, d3.mean(V, function (v) { return kernel(x - v); })];
                });
            };
        }

        function kernelEpanechnikov(k) {
            return function (v) {
                return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
            };
        }



        function dynamicParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {

            let structureCombinedData = [];

            console.log(geneselected)

            console.log(dataN)

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);
                console.log(geneDataN)
                console.log(geneDataC)
                if (geneDataN.length == 0) {
                    selectedGeneData = [];
                    geneselected = [];
                    return;
                }

                // Extract sample names for each gene
                var sampleKeysC = Object.keys(geneDataC[0]).filter(key => key !== "gene");
                var sampleKeysN = Object.keys(geneDataN[0]).filter(key => key !== "gene");

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ sample: sampleKeysC[i], expression: expression, type: chosen_meta2, index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ sample: sampleKeysN[i], expression: expression, type: chosen_meta1, index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 }
            // Use the container's size to calculate width and height dynamically
            var width = document.getElementById("parallel").clientWidth - margin.left - margin.right;
            var height = document.getElementById("parallel").clientHeight - margin.top - margin.bottom;

            // Append the SVG object to the parallel container
            var svg = d3.select("#parallel")
                .html("")  // Clear previous content
                .append("svg")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // Set the viewBox for scaling
                .style("width", "100%") // Set to 100% width
                .style("height", "100%") // Set to 100% height
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain([chosen_meta1, chosen_meta2])
                    .range(["#0d0887", "#fddb6d"]);
            }

            // Extract metadata categories from the values of the first column
            var metadataCategories = Object.values(metadata).map(row => row[Object.keys(row)[0]]);
            console.log("Metadata categories:", metadataCategories);
            var orderedCategories = Object.keys(colorScaleValues);
            console.log("Ordered categories:", orderedCategories);

            // Initialize y scale object
            var y = {};

            // Iterate through ordered categories to create y scales
            metadataCategories.forEach((category, i) => {
                if (colorScaleValues[category]) {
                    var values = Object.keys(colorScaleValues[category]); // Extract values for the current category
                    console.log("Values for", category, ":", values);
                    y[category] = d3.scaleOrdinal()
                        .domain(values) // Use unique values for the current category
                        .range([...Array(values.length).keys()].map(i => i * (height / (values.length - 1))));
                } else {
                    console.log("No colorscalevalues");
                    var values = Object.values(metadata[i]); // Extract values for the current category
                    values.shift(); // Remove the first value (Sample_source_name_ch1)
                    var uniqueValues = [...new Set(values)]; // Filter out duplicates
                    uniqueValues.sort((a, b) => a - b); // Sort numerically
                    console.log("Values for", category, ":", uniqueValues);

                    // Check if all unique values are numeric
                    const allNumeric = uniqueValues.every(value => !isNaN(value) && value !== null && value !== '');

                    console.log(allNumeric)

                    if (allNumeric) {
                        // If all values are numeric, use a linear scale
                        const min = d3.min(uniqueValues.map(Number));
                        const max = d3.max(uniqueValues.map(Number));
                        console.log(min)
                        console.log(max)

                        y[category] = d3.scaleLinear()
                            .domain([max, min]) // Set domain from min to max
                            .range([0, height]); // Adjust the range
                    } else {
                        // If there are non-numeric values, create an ordinal scale
                        uniqueValues.sort((a, b) => b - a); // Sort in reverse order
                        console.log("Non-numeric values found. Using ordinal scale.");
                        var stepSize = height / (uniqueValues.length + 1); // Adjust +1 to leave some space at the top
                        y[category] = d3.scaleOrdinal()
                            .domain(uniqueValues) // Use unique values for the current category
                            .range([...Array(uniqueValues.length).keys()].map(i => (i + 1) * stepSize)); // Adjust the range
                    }
                }
            });

            // Now y scales are ordered according to colorScaleValues
            console.log("Y scales:", y);


            // Iterate through metadata categories to create y scales
            // metadataCategories.forEach((category, i) => {
            //     var values = Object.values(metadata[i]); // Extract values for the current category
            //     values.shift(); // Remove the first value (Sample_source_name_ch1)
            //     var uniqueValues = [...new Set(values)]; // Filter out duplicate
            //     console.log("Values for", category, ":", uniqueValues);
            //     y[category] = d3.scaleOrdinal()
            //         .domain(uniqueValues) // Use unique values for the current category
            //         .range([...Array(uniqueValues.length).keys()].map(i => height - i * (height / (uniqueValues.length - 1))));
            // });

            // Step 1: Find the global maximum expression value across all selected genes
            var globalMax = d3.max(geneselected, function (geneName) {
                var geneData = structureCombinedData.find(d => d.gene === geneName);
                var expressionValues = geneData.expressions.map(d => d.expression);
                return d3.max(expressionValues) + 3; // Get the max expression value for this gene
            });

            // Step 2: Define the Y-scale for all genes using the same domain (0 to globalMax)
            for (var i in geneselected) {
                var name = geneselected[i];

                // Define the Y-scale for the current gene with a domain of [0, globalMax]
                y[name] = d3.scaleLinear()
                    .domain([0, globalMax]) // Set the domain to 0 and the global max value
                    .range([height, 0]); // Map the domain to the visual height
            } console.log("Y scales:", y);

            // Initialize transposedData array
            var transposedData = [];

            // Iterate over each metadata category
            metadataCategories.forEach((category, index) => {
                // Skip the first category (Sample_geo_accession)
                if (index === 0) return;

                // Iterate over each sample in the metadata
                Object.keys(metadata[index]).forEach((sampleKey, sampleIndex) => {
                    // Skip the first key (Sample_geo_accession)
                    if (sampleIndex === 0) return;

                    // If transposedData is not initialized for this sample, initialize it
                    if (!transposedData[sampleKey]) {
                        transposedData[sampleKey] = { [metadataCategories[0]]: metadata[0][sampleKey] };
                    }

                    // Add metadata values for each category to the transposedData
                    transposedData[sampleKey][category] = metadata[index][sampleKey];
                });
            });

            // Extract gene names from structureCombinedData
            var geneNames = structureCombinedData.map(d => d.gene);

            // Combine metadata categories and gene names
            var allCategories = [...metadataCategories, ...geneNames];
            console.log("All Categories " + allCategories)

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var colorScale
            console.log(selectedVariable)

            function getColorScale(selectedVariable) {
                // Retrieve the predefined colors for the selected variable
                var variableColors = colorScaleValues[selectedVariable];

                // Get the unique values (keys) and their corresponding colors
                var uniqueValues = Object.keys(variableColors);
                var colors = uniqueValues.map(value => variableColors[value]);

                // Generate a color scale using the predefined colors
                colorScale = d3.scaleOrdinal()
                    .domain(uniqueValues)
                    .range(colors);

                // Log the domain and range of the color scale
                console.log("Color scale domain (unique values):", colorScale.domain());
                console.log("Color scale range (assigned colors):", colorScale.range());

                return colorScale;
            }


            getColorScale(selectedVariable)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 45;
            var legendX = 20;
            var legendY = 10;


            var legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("viewBox", `0 0 ${legendWidth} ${legendHeight}`)
                .attr("preserveAspectRatio", "xMinYMin meet")
                .style("width", "100%") // Set to 100% width
                .style("height", "100%") // Set to 100% height
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(colorScale);

            // Append legend to the SVG
            legend.call(legendColor);

            // Truncate labels and add tooltips for full text
            legend.selectAll(".label")
                .each(function (d) {
                    var self = d3.select(this);
                    var textNode = self.node().childNodes[0]; // Get the text node
                    var text = textNode.textContent; // Get the text content
                    console.log(text)
                    var maxLength = 7; // Set the maximum length for the label before truncating
                    if (this.textContent.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                        self.append("title").text(d); // Add full text as a tooltip
                    }
                });

            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "var(--text-color)") // Set label color to var(--text-color)
                .style("font-size", "14px")  // Adjust font size
                .style("var(--text-color)-space", "pre")

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            legend.selectAll(".cell")
                .classed("legend-cell", true); // Add the 'legend-cell' class to all existing cells

            console.log(dimensions)

            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            // Iterate over each gene in structureCombinedData
            structureCombinedData.forEach(geneData => {
                // Loop through each sample in the gene's expression data
                geneData.expressions.forEach(sampleData => {
                    const sampleKey = sampleData.sample;

                    // If transposedData is not initialized for this sample, initialize it
                    if (!transposedData[sampleKey]) {
                        transposedData[sampleKey] = { [metadataCategories[0]]: metadata[0][sampleKey] };
                    }

                    // Add gene expression values for each gene to the transposedData
                    transposedData[sampleKey][geneData.gene] = sampleData.expression;
                });
            });


            // Log transposedData
            console.log("Transposed Data:", transposedData);
            var test = 0;
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(Object.keys(transposedData))
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d) ? "gsm-path selected" : "gsm-path";
                })
                .attr("d", function (d) {
                    // Construct the path string using the order of dimensions specified by metadataCategories
                    return pathString(transposedData[d]);
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    var selectedValue = transposedData[d][selectedVariable];
                    return colorScale(selectedValue);
                })
                .style("opacity", function (d) {
                    if (gsmList.length >= 1) {
                        return gsmList.includes(d) ? "1" : "0.2";
                    }
                    else {
                        return "1"
                    }
                })
                .style("stroke-width", function (d) {
                    if (gsmList.length >= 1) {
                        return gsmList.includes(d) ? "2" : "1";
                    }
                    else {
                        return "1"
                    }
                })

            // Function to construct the path string
            // Initialize an empty array to store coordinates
            function pathString(sampleData) {
                // Initialize an empty array to store coordinates
                var coordinates = [];
                // Loop through each dimension in metadataCategories
                dimensions.forEach(function (category) {
                    // Push the x and y coordinates to the coordinates array
                    coordinates.push([x(category), y[category](sampleData[category])]);
                });
                // Use D3's line generator to generate the path string
                return d3.line()(coordinates);
            }

            gsmPaths.on("click", function (d) {
                console.log(d)
                var clickedGSM = d; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }
                console.log(gsmList)

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("selected", gsmList.includes(clickedGSM));

                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));

                console.log("PCA DATA IN PARRALLEL", pca_data)

                pca(pca_data)

                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                } else {
                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }
                heatmap(heatmap_data)
                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }
                // Determine the value to highlight based on the selected variable
                var selected_reg = transposedData[d][selectedVariable];

                // First, every group turns lightgrey and reduces opacity
                d3.selectAll(".gsm-path")
                    .style("stroke", function (data) {
                        return colorScale(transposedData[data][selectedVariable])
                    })
                    .style("opacity", function (data) {
                        if (gsmList.length >= 1) {
                            if (gsmList.includes(data)) {
                                return "1"
                            }
                            else {
                                return transposedData[data][selectedVariable] === selected_reg ? "1" : "0.2";
                            }
                        } else {
                            // Highlight only the selected category, reduce opacity for others
                            return transposedData[data][selectedVariable] === selected_reg ? "1" : "0.2";
                        }
                    })
                    .style("stroke-width", function (d) {
                        if (gsmList.length >= 1) {
                            return gsmList.includes(d) ? "2" : "1";
                        }
                        else {
                            return "1"
                        }
                    })

            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }

            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum();
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")

                console.log(elements)

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseRedAnimation');

                if (!targetAnimation) {
                    return
                }

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }


            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]));
                });

            // Add axis labels and truncate if necessary
            axis.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    var maxLength = 5; // Max length before truncating
                    return d.length > maxLength ? d.slice(0, maxLength) + '...' : d;
                })
                .style("fill", "var(--text-color)")
                .append("title")
                .text(function (d) { return d; }); // Add full text as a tooltip

            axis.selectAll(".domain")
                .attr("stroke", "var(--text-color)");

            axis.selectAll(".tick text")
                .style("fill", "var(--text-color)");
            axis.selectAll(".tick line")
                .attr("stroke", "var(--text-color)");

            // Add truncated y-axis labels with tooltips
            axis.selectAll(".tick text")
                .each(function (d) {
                    var self = d3.select(this);
                    var text = d; // Full label text from the data bound
                    var maxLength = 5; // Set the maximum length for the label before truncating

                    // Add tooltip
                    self.append("title").text(text); // Add full text as a tooltip

                    // Truncate text if necessary
                    if (text.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                    }
                });


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    d3.select(this).call(d3.axisLeft().scale(y[d]));
                })
                .call(drag); // Apply drag behavior to each axis group;

            // Add axis labels and truncate if necessary
            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    var maxLength = 5; // Max length before truncating
                    return d.length > maxLength ? d.slice(0, maxLength) + '...' : d;
                })
                .style("fill", "var(--text-color)")
                .append("title")
                .text(function (d) { return d; }); // Add full text as a tooltip

            axisGroups.selectAll(".domain")
                .attr("stroke", "var(--text-color)");

            axisGroups.selectAll(".tick text")
                .style("fill", "var(--text-color)");

            axisGroups.selectAll(".tick line")
                .attr("stroke", "var(--text-color)");

            // Add truncated y-axis labels with tooltips
            axisGroups.selectAll(".tick text")
                .each(function (d) {
                    var self = d3.select(this);
                    var text = d; // Full label text from the data bound
                    var maxLength = 5; // Set the maximum length for the label before truncating

                    // Add tooltip
                    self.append("title").text(text); // Add full text as a tooltip

                    // Truncate text if necessary
                    if (text.length > maxLength) {
                        var truncatedText = text.slice(0, maxLength) + '...';
                        self.text(truncatedText);
                    }
                });


            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });
                console.log(totalOrder)

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            dehighlightHeatmapRow(d.dimension)
                            // Remove highlighting color in the scatter plot
                        }
                    }
                });

                // Remove corresponding data from transposedData
                // transposedData = transposedData.filter(function (d) {
                //     return !removedDimensions.includes(d.gene);
                // });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                // var select = document.getElementById("selectButton");
                // var options = select.options;

                // for (var i = 0; i < options.length; i++) {
                //     if (removedDimensions[0] === options[i].value) {
                //         select.removeChild(options[i]);
                //         break; // Exit the loop once the option is removed
                //     }
                // }
                heatmap(heatmap_data)
                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }

                first_dims = metadataOrder

                ordering = totalOrder

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                dynamicParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else if (currentPlot === 'scatter') {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                }
                d3.selectAll(".axis-label").classed("dragging", false);

            }

            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg = transposedData[d][selectedVariable];

                // First, every group turns lightgrey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        return colorScale(transposedData[data][selectedVariable])
                    })
                    .style("opacity", function (data) {
                        if (gsmList.length >= 1) {
                            if (gsmList.includes(data)) {
                                return "1"
                            }
                            else {
                                return transposedData[data][selectedVariable] === selected_reg ? "1" : "0.2";
                            }
                        } else {
                            // Highlight only the selected category, reduce opacity for others
                            return transposedData[data][selectedVariable] === selected_reg ? "1" : "0.2";
                        }
                    })
                    .style("stroke-width", function (d) {
                        if (gsmList.length >= 1) {
                            return gsmList.includes(d) ? "2" : "1";
                        }
                        else {
                            return "1"
                        }
                    })


                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (d) {
                        var selectedValue = transposedData[d][selectedVariable];
                        return colorScale(selectedValue);
                    })
                    .style("opacity", function (d) {
                        if (gsmList.length >= 1) {
                            return gsmList.includes(d) ? "1" : "0.2";
                        } else {
                            return "1";
                        }
                    })
                    .style("stroke-width", function (d) {
                        if (gsmList.length >= 1) {
                            return gsmList.includes(d) ? "2" : "1";
                        }
                        else {
                            return "1"
                        }
                    })


                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);

            // applyThemeToSVG()


        }

        function updateParallel(geneselected, data, dataC, dataN, first_dims, totalOrder) {
            let structureCombinedData = [];

            geneselected.forEach(geneName => {
                var geneDataN = dataN.filter(d => d.gene === geneName);
                var geneDataC = dataC.filter(d => d.gene === geneName);

                // Extract GSM values for each gene
                var gsmValuesC = Object.keys(geneDataC[0]).filter(key => key.startsWith('GSM'));
                var gsmValuesN = Object.keys(geneDataN[0]).filter(key => key.startsWith('GSM'));

                let expressionValuesC = [];
                geneDataC.forEach(entry => {
                    expressionValuesC.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                let expressionValuesN = [];
                geneDataN.forEach(entry => {
                    expressionValuesN.push(...Object.values(entry).filter(val => typeof val === 'number' && !isNaN(val)));
                });

                var combinedData = [];
                expressionValuesC.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesC[i], expression: expression, type: 'Case', index: i });
                });
                expressionValuesN.forEach((expression, i) => {
                    combinedData.push({ GSM: gsmValuesN[i], expression: expression, type: 'Normal', index: i });
                });

                structureCombinedData.push({
                    gene: geneName,
                    expressions: combinedData
                });
            });

            //console.log(structureCombinedData);

            // set the dimensions and margins of the graph
            var margin = { top: 30, right: 50, bottom: 10, left: 50 },
                width = 1000 - margin.left - margin.right,
                height = 320 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#parallel")
                .html("")  // Clear previous content
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            //var selectedVariable = document.querySelector('input[name="variable"]:checked').value;


            var color;
            if (selectedVariable === "case") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "Case"])
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Smoker") {
                color = d3.scaleOrdinal()
                    .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                    .range(["#0d0887", "#bd3786", "#fddb6d"]);
            } else if (selectedVariable === "Gender") {
                color = d3.scaleOrdinal()
                    .domain(["Male", "Female"]) // Set the domain based on the age data
                    .range(["#0d0887", "#fddb6d"]);
            } else if (selectedVariable === "Stage") {
                color = d3.scaleOrdinal()
                    .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                    .range(["#0d0887", "#46039f", "#7201a8", "#9c179e", "#bd3786", "#d8576b", "#ed7953", "#fddb6d"]);
            }

            var ageAtDiagnosisValues = metadata['Age at Diagnosis:ch1'];

            if (totalOrder !== undefined) {
                dimensions = totalOrder
            } else {
                dimensions = first_dims.concat(geneselected);

            }

            var y = {};
            for (var i in dimensions) {
                var name = dimensions[i];
                y[name] = d3.scaleLinear()
                    .domain([0, 20])
                    .range([height, 0]);
            }
            // Extract age data from metadata
            var ageData = metadata["Age at Diagnosis:ch1"];
            var genderData = metadata["Gender:ch1"];
            var smokerData = metadata["Cigarette Smoking Status:ch1"];
            var stageData = metadata["Stage:ch1"];

            // Convert age data to numbers
            ageData = ageData.map(function (age) {
                return parseFloat(age);
            });

            // Determine the age domain
            var ageDomain = d3.extent(ageData);

            // Update the y-scale for the age dimension
            y["Age at Diagnosis"] = d3.scaleLinear()
                .domain([30, 90]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for the age dimension
            y["Gender"] = d3.scaleOrdinal()
                .domain(["Male", "Female"]) // Set the domain based on the age data
                .range([height, 0]);

            // Update the y-scale for Cigarette Smoking Status
            y["Smoking Status"] = d3.scaleOrdinal()
                .domain(["Never Smoked", "Former Smoker", "Current Smoker"])
                .range([height, height / 2, 0])

            var interval = height / 7;

            y["Stage"] = d3.scaleOrdinal()
                .domain(["Normal", "IA", "IB", "IIA", "IIB", "IIIA", "IIIB", "IV"])
                .range([height, height - interval, height - 2 * interval, height - 3 * interval, height - 4 * interval, height - 5 * interval, height - 6 * interval, 0]);

            // Update the y-scale for type
            y["type"] = d3.scaleOrdinal()
                .domain(["Normal", "Case"])
                .range([height, 0])


            // Build the X scale -> it finds the best position for each Y axis
            var x = d3.scalePoint()
                .range([0, width])
                .domain(dimensions);

            //console.log(metadata)

            var legend = d3.select("#parallelLegend");
            legend.html(""); // Clear previous legend content

            // Define legend dimensions and position
            var legendWidth = 550;
            var legendHeight = 60;
            var legendX = 20;
            var legendY = 10;


            // Create legend
            legend = d3.select("#parallelLegend")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("viewBox", `0 0 ${legendWidth} ${legendHeight}`) // Set the viewBox for scaling
                .append("g")
                .attr("class", "legendOrdinal")
                .attr("transform", "translate(" + legendX + "," + legendY + ")");

            // Define legend color scale
            var legendColor = d3.legendColor()
                .shapeWidth(60) // Adjust shape width as needed
                .orient('horizontal')
                .labelWrap(30)
                .scale(color);

            // Append legend to the SVG
            legend.call(legendColor);

            // Set legend label color and style
            legend.selectAll(".label")
                .style("fill", "var(--text-color)") // Set label color to var(--text-color)
                .style("font-size", "14px")  // Adjust font size

            // Adjust label position
            legend.selectAll("text")
                .attr("dy", "-0.35em"); // Adjust vertical alignment

            // Transpose the structureCombinedData
            transposedData = [];
            if (geneselected.length > 0) {
                // Use geneselected when it's not empty
                geneselected.forEach(function (geneName) {
                    var geneData = structureCombinedData.find(d => d.gene === geneName);
                    geneData.expressions.forEach(function (expression, i) {
                        if (!transposedData[i]) transposedData[i] = { GSM: expression.GSM }; // Use GSM value from expression
                        transposedData[i][geneName] = expression.expression;
                        transposedData[i].type = expression.type; // Add the type property to each observation
                        // Find the index of the GSM in the metadata's geo_accession array
                        var gsmIndex = metadata.geo_accession.findIndex(item => item === expression.GSM);
                        if (gsmIndex !== -1) {
                            // If the GSM is found in metadata, insert the corresponding Age at Diagnosis
                            transposedData[i]['Age at Diagnosis'] = metadata['Age at Diagnosis:ch1'][gsmIndex];
                            transposedData[i]['Gender'] = metadata['Gender:ch1'][gsmIndex];
                            transposedData[i]['Smoking Status'] = metadata['Cigarette Smoking Status:ch1'][gsmIndex];
                            transposedData[i]['Stage'] = metadata['Stage:ch1'][gsmIndex];
                        }
                    });
                });
            } else {
                // Use first_dims when geneselected is empty
                transposedData = metadata.geo_accession.map((gsm, i) => ({
                    GSM: gsm,
                    'Age at Diagnosis': metadata['Age at Diagnosis:ch1'][i],
                    'Gender': metadata['Gender:ch1'][i],
                    'Smoking Status': metadata['Cigarette Smoking Status:ch1'][i],
                    'Stage': metadata['Stage:ch1'][i],
                    type: metadata['Stage:ch1'][i] === "Normal" ? "Normal" : "Case"
                }));
            }
            //console.log(transposedData);
            // Select all paths with the class "gsm-path"
            var gsmPaths = svg.selectAll(".gsm-path")
                .data(transposedData)
                .enter()
                .append("path")
                .attr("class", function (d) {
                    // Add the pulse-red class if the GSM is in the gsmList
                    return gsmList.includes(d.GSM) ? "gsm-path pulse-red" : "gsm-path";
                })
                .attr("d", function (d) {
                    var pathString = path(d);
                    return pathString;
                })
                .style("fill", "none")
                .style("stroke", function (d) {
                    if (selectedVariable === "case") {
                        return color(d.type);
                    } else if (selectedVariable === "Smoker") {
                        return color(d['Smoking Status']);
                    } else if (selectedVariable === "Gender") {
                        return color(d['Gender']);
                    } else if (selectedVariable === "Stage") {
                        return color(d['Stage']);
                    }
                })

            gsmPaths.on("click", function (d) {
                var clickedGSM = d.GSM; // Get the GSM value of the clicked path

                // Check if the clicked GSM is already in gsmList
                var index = gsmList.indexOf(clickedGSM);
                if (index === -1) {
                    // If not in the list, add it
                    gsmList.push(clickedGSM);
                    synchronizeAnimations(this)
                } else {
                    // If already in the list, remove it
                    gsmList.splice(index, 1);
                }

                // Update the class of the clicked path based on its presence in gsmList
                d3.select(this)
                    .classed("pulse-red", gsmList.includes(clickedGSM));


                pca(pca_data)

                if (ridge) {
                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                } else {
                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                }

                heatmap(heatmap_data)

                console.log("GSM List:", gsmList);
            });

            function path(d) {
                return d3.line()(dimensions.map(function (geneName) { return [x(geneName), y[geneName](d[geneName])]; }));
            }

            svg.selectAll(".gsm-path").each(function (data, i) {
                // Reorder the SVG elements to bring paths with selected GSM to the front
                gsmPaths.each(function () {
                    var selectedGSM = d3.select(this).datum().GSM;
                    if (gsmList.includes(selectedGSM)) {
                        this.parentNode.appendChild(this); // Append to the parent node to bring it to the front
                    }
                });

                //console.log("Data bound to path " + (i + 1) + ":", data);
            });

            function synchronizeAnimations(targetElement) {
                // Retrieve all elements with the class 'pulse'
                const elements = document.querySelectorAll(".pulse-red")


                console.log(elements)

                // Retrieve the Animation object of the target element
                const targetAnimation = findAnimByName(targetElement, 'pulseRedAnimation');

                if (!targetAnimation) {
                    return
                }

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseRedAnimation');

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }




            // Draw the axis:
            var axis = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                });

            axis.append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "var(--text-color)");

            axis.selectAll(".domain")
                .attr("stroke", "var(--text-color)");

            axis.selectAll(".tick text")
                .style("fill", "var(--text-color)");
            axis.selectAll(".tick line")
                .attr("stroke", "var(--text-color)");


            // Define drag behavior
            var drag = d3.drag()
                .on("start", dragstart)
                .on("drag", dragmove)
                .on("end", dragend);

            // Draw the axis:
            var axisGroups = svg.selectAll("myAxis")
                .data(dimensions)
                .enter()
                .append("g")
                .attr("class", "axis-group")
                .attr("transform", function (d) { return "translate(" + x(d) + ")"; })
                .each(function (d) {
                    if (d === "Smoking Status") {
                        // For "Smoking Status" dimension, customize the tick format
                        d3.select(this).call(d3.axisLeft().scale(y[d]).tickFormat(function (d) {
                            // Customize the tick format here
                            return d === "Never Smoked" ? "Never" : d === "Former Smoker" ? "Former" : "Current";
                        }));
                    } else {
                        d3.select(this).call(d3.axisLeft().scale(y[d]));
                    }
                })
                .call(drag); // Apply drag behavior to each axis group;

            axisGroups.append("text")
                .attr("class", "dragging") // Add the axis-label class
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(function (d) {
                    // Set the label text for "Type" axis
                    return d === "type" ? "Type" : d;
                })
                .style("fill", "var(--text-color)");

            axisGroups.selectAll(".domain")
                .attr("stroke", "var(--text-color)");

            axisGroups.selectAll(".tick text")
                .style("fill", "var(--text-color)");
            axisGroups.selectAll(".tick line")
                .attr("stroke", "var(--text-color)");



            // Drag start function
            function dragstart(d) {
                // Raise the dragged axis to the front
                d3.select(this).classed("active", true);
                d3.select(this).classed("dragging", true);

            }

            // Drag move function
            function dragmove(d) {
                // Update the position of the dragged axis
                var newPosition = d3.event.x;
                d3.select(this).attr("transform", "translate(" + newPosition + ")");
            }

            function dragend(d) {
                // Get the new positions of the axis groups
                var newPositions = [];
                svg.selectAll(".axis-group").each(function (d) {
                    var transform = d3.select(this).attr("transform");
                    var translateX = +transform.split("(")[1].split(")")[0];
                    console.log(translateX)
                    newPositions.push({ dimension: d, position: translateX });
                });

                // Sort newPositions array based on position
                newPositions.sort(function (a, b) {
                    return a.position - b.position;
                });

                // Separate dimensions into geneselected, metadata (first_dims), and total ordering
                var geneselectedOrder = [];
                var metadataOrder = [];
                totalOrder = [];
                newPositions.forEach(function (d) {
                    if (geneselected.includes(d.dimension)) {
                        geneselectedOrder.push(d.dimension);
                    } else if (first_dims.includes(d.dimension)) {
                        metadataOrder.push(d.dimension);
                    }
                    totalOrder.push(d.dimension);
                });

                // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
                var removedDimensions = [];
                newPositions.forEach(function (d) {
                    console.log(d.position)
                    if ((d.position < -100 || d.position > 1000) && geneselected.includes(d.dimension)) {
                        var index = geneselectedOrder.indexOf(d.dimension);
                        if (index !== -1) {
                            removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                            // Remove highlighting color in the scatter plot
                            scatter.selectAll("circle")
                                .filter(circleData => circleData.gene === d.dimension)
                                .style("fill", d => {
                                    // Check if logFC is greater than or equal to the threshold
                                    if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                        return "#C14A82";
                                    } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                        return "#1A74D5";
                                    } else {
                                        return "lightgrey";
                                    }
                                });
                        }
                    }
                });

                // Remove corresponding data from transposedData
                transposedData = transposedData.filter(function (d) {
                    return !removedDimensions.includes(d.gene);
                });

                // Update totalOrder by removing removedDimensions
                totalOrder = totalOrder.filter(function (d) {
                    return !removedDimensions.includes(d);
                });

                console.log("Geneselected order:", geneselectedOrder);
                console.log("Metadata order:", metadataOrder);
                console.log("Total order:", totalOrder);
                console.log("Removed dimensions:", removedDimensions);

                selectedGeneData = geneselectedOrder

                selectedGeneData = geneselectedOrder
                // Find and remove the corresponding option from the select element
                var select = document.getElementById("selectButton");
                var options = select.options;

                for (var i = 0; i < options.length; i++) {
                    if (removedDimensions[0] === options[i].value) {
                        select.removeChild(options[i]);
                        break; // Exit the loop once the option is removed
                    }
                }


                first_dims = metadataOrder

                ordering = totalOrder

                // Update dimensions with new order

                // Redraw the parallel coordinates plot
                // Call updateParallel or relevant function here with updated dimensions
                updateParallel(geneselectedOrder, data, dataC, dataN, metadataOrder, totalOrder);
                if (currentPlot === 'volcano') {
                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else if (currentPlot === 'scatter') {
                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                } else {
                    updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                }
                d3.selectAll(".axis-label").classed("dragging", false);

            }
            var newPositions = [];
            svg.selectAll(".axis-group").each(function (d) {
                var transform = d3.select(this).attr("transform");
                var translateX = +transform.split("(")[1].split(")")[0];
                console.log(translateX)
                newPositions.push({ dimension: d, position: translateX });
            });
            console.log(newPositions)

            // Sort newPositions array based on position
            newPositions.sort(function (a, b) {
                return a.position - b.position;
            });

            // Separate dimensions into geneselected, metadata (first_dims), and total ordering
            var geneselectedOrder = [];
            var metadataOrder = [];
            totalOrder = [];
            newPositions.forEach(function (d) {
                if (geneselected.includes(d.dimension)) {
                    geneselectedOrder.push(d.dimension);
                } else if (first_dims.includes(d.dimension)) {
                    metadataOrder.push(d.dimension);
                }
                totalOrder.push(d.dimension);
            });

            // Check if any dimension was dragged too far to the left and remove it from geneselectedOrder if it belongs to geneselected
            var removedDimensions = [];
            newPositions.forEach(function (d) {
                if (d.position < -100 && geneselected.includes(d.dimension)) {
                    var index = geneselectedOrder.indexOf(d.dimension);
                    if (index !== -1) {
                        removedDimensions.push(geneselectedOrder.splice(index, 1)[0]);
                        // Remove highlighting color in the scatter plot
                        scatter.selectAll("circle")
                            .filter(circleData => circleData.gene === d.dimension)
                            .style("fill", d => {
                                // Check if logFC is greater than or equal to the threshold
                                if (d.logFC >= log_thr_fc && d.pval_adj <= threshold) {
                                    return "#C14A82";
                                } else if (d.logFC <= -(log_thr_fc) && d.pval_adj <= threshold) {
                                    return "#1A74D5";
                                } else {
                                    return "lightgrey";
                                }
                            });
                    }
                }
            });

            // Remove corresponding data from transposedData
            transposedData = transposedData.filter(function (d) {
                return !removedDimensions.includes(d.gene);
            });

            // Update totalOrder by removing removedDimensions
            totalOrder = totalOrder.filter(function (d) {
                return !removedDimensions.includes(d);
            });

            console.log("Geneselected order:", geneselectedOrder);
            console.log("Metadata order:", metadataOrder);
            console.log("Total order:", totalOrder);
            console.log("Removed dimensions:", removedDimensions);

            selectedGeneData = geneselectedOrder


            first_dims = metadataOrder

            ordering = totalOrder
            // Function to handle mouseover event
            function highlight(d) {
                // Determine the value to highlight based on the selected variable
                var selected_reg;
                if (selectedVariable === "case") {
                    selected_reg = d.type;
                } else if (selectedVariable === "Smoker") {
                    selected_reg = d['Smoking Status'];
                } else if (selectedVariable === "Gender") {
                    selected_reg = d['Gender'];
                } else if (selectedVariable === "Stage") {
                    selected_reg = d['Stage']; // Set default value
                }

                // First, every group turns lightgrey and reduces opacity
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Highlight only the selected category, reduce opacity for others
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? color(selected_reg) : "lightgrey";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? color(selected_reg) : "lightgrey";
                        }
                    })
                    .style("opacity", function (data) {
                        // Set opacity based on whether it's the selected category or not
                        if (selectedVariable === "case") {
                            return data.type === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Smoker") {
                            return data['Smoking Status'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Gender") {
                            return data['Gender'] === selected_reg ? "1" : "0.2";
                        } else if (selectedVariable === "Stage") {
                            return data['Stage'] === selected_reg ? "1" : "0.2";
                        }
                    });

                // Apply pulsing effect directly to the hovered element
                d3.select(this)
                    .classed("pulse-red", true);
                this.parentNode.appendChild(this); // Append to the parent node to bring it to the front

            }

            // Function to handle mouseout event
            function doNotHighlight() {
                // Reset stroke color and opacity for all lines
                d3.selectAll(".gsm-path")
                    .transition().duration(200)
                    .style("stroke", function (data) {
                        // Set stroke color based on the selected variable
                        if (selectedVariable === "case") {
                            return color(data.type);
                        } else if (selectedVariable === "Smoker") {
                            return color(data['Smoking Status']);
                        } else if (selectedVariable === "Gender") {
                            return color(data['Gender']);
                        } else if (selectedVariable === "Stage") {
                            return color(data['Stage']);
                        }
                    })
                    .style("opacity", "1"); // Reset opacity to 1

                // Pulsing effect for paths with GSM in gsmList
                d3.selectAll(".gsm-path")
                    .filter(function (data) {
                        return !gsmList.includes(data.GSM);
                    })
                    .classed("pulse-red", false);
            }

            // Bind mouseover and mouseleave events to all lines
            svg.selectAll(".gsm-path")
                .on("mouseover", highlight)
                .on("mouseleave", doNotHighlight);


        }

        function heatmap(heatmap_data) {
            console.log(heatmap_data)

            var heatmap_data_subset = heatmap_data.slice(0, displayed_rows);
            console.log(heatmap_data_subset)
            if (heatmap_data_subset.length <= 1) return;
            // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
            var myGroups = heatmap_data_subset.map(d => d.gene);
            var myVars = Object.keys(heatmap_data_subset[0]).filter(d => d !== "gene");
            // set the dimensions and margins of the graph

            // Set the dimensions and margins of the graph
            var margin = { top: 50, right: 180, bottom: 10, left: 130 };
            var container = document.getElementById("heatmap");
            var width = container.clientWidth - margin.left - margin.right;
            var height = container.clientHeight - margin.top - margin.bottom;

            // Calculate total width and height including margins
            var totalWidth = width + margin.left + margin.right;
            var totalHeight = height + margin.top + margin.bottom;

            // Append the svg object to the heatmap container
            var svg = d3.select("#heatmap")
                .html("")
                .append("svg")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`) // Set the viewBox for responsive scaling
                // .style("width", "100%") // Make it responsive to the container
                // .style("height", "100%") // Make it responsive to the container
                .append("g")
                .attr("transform", "translate(" + (margin.left + 46) + "," + margin.top + ")");

            // Build X scales and axis:
            var x = d3.scaleBand()
                .range([0, width])
                .domain(myVars)
                .padding(0.05);

            svg.append("g")
                .style("font-size", 15)
                .attr("transform", "translate(0,0)")
                .call(d3.axisTop(x).tickSize(0))
                .select(".domain").remove();

            // Add click event listener to the X-axis tick texts
            svg.selectAll(".tick text")
                .style("fill", "var(--text-color)")
                .style("text-transform", "uppercase")

            // Build Y scales and axis:
            var y = d3.scaleBand()
                .range([0, height])
                .domain(myGroups)
                .padding(0.05);

            // Add title text
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -25)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .text("Heatmap")
                .style("fill", "var(--text-color)");
            // Build color scale
            var myColor = d3.scaleSequential()
                .interpolator(d3.interpolateInferno)
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))]);

            // create a tooltip
            var tooltip = d3.select("#heatmap")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px");

            // Three functions that change the tooltip when user hover / move / leave a cell
            var mouseover = function (d) {
                tooltip
                    .style("opacity", 1);

                if (d3.select(this).style("stroke") === "none") {
                    d3.select(this)
                        .style("stroke", "yellow")
                        .style("opacity", 1);
                }

            };

            var mousemove = function (d) {
                var valueString;
                if (d.value < 0.01) {
                    valueString = d.value.toExponential(2) + "%";
                } else {
                    valueString = (d.value).toFixed(2) + "%";
                }
                // Calculate the position of the tooltip
                var xPosition = d3.event.pageX + 10; // 10 pixels to the right of the mouse pointer
                var yPosition = d3.event.pageY - 10; // 10 pixels above the mouse pointer

                var variableUppercase = d.variable.toUpperCase();

                tooltip
                    .html("The contribution percentage of<br>" + d.gene + " in " + variableUppercase + " is: " + valueString)
                    .style("left", xPosition + "px")
                    .style("top", yPosition + "px");
            };

            var mouseleave = function (d) {
                tooltip
                    .style("opacity", 0)
                    .style("pointer-events", "none"); // Disable pointer events for the tooltip

                if (d3.select(this).style("stroke") === "yellow") {

                    d3.select(this).style("stroke", "none")
                        .style("opacity", 0.8)

                }

                // Highlight the corresponding heatmap squares
                square
                    .filter(function (heatmapData) {

                        return selectedGeneData.includes(heatmapData.gene);
                    })
                    .style("opacity", 1) // Change opacity to highlight
                    .style("stroke", "yellow") // Change stroke color to highlight (optional)
                    .style("stroke-width", 2); // Increase stroke width (optional)



            };

            // add the squares
            square = svg.selectAll(".heatmap-rect")
                .data(heatmap_data_subset.flatMap(d => myVars.map(v => ({ gene: d.gene, variable: v, value: d[v] }))))
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.variable); })
                .attr("y", function (d) { return y(d.gene); })
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return myColor(d.value); })
                .style("stroke-width", 4)
                .style("stroke", "none")
                .style("opacity", 0.8)
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseout", mouseleave)
                .on("click", function (d) {
                    // var selectedElement = d3.select(this);

                    // // Check if the rectangle is already stroked
                    // var isRectangleStroked = selectedElement.style("stroke") === "red";

                    // // Find the corresponding scatterplot circle and toggle its selection
                    // var correspondingCircle = scatter.selectAll("circle")
                    //     .filter(function (circleData) {
                    //         return circleData.gene === d.gene;
                    //     });

                    // // Store the selected rectangle's variable
                    // var selectedVariable = d.variable;

                    // // Remove stroke from all rectangles of the current gene
                    // svg.selectAll("rect")
                    //     .filter(function (rectData) {
                    //         if (rectData !== undefined) {
                    //             return rectData.gene === d.gene;
                    //         }
                    //     })
                    //     .style("stroke", "none");

                    // // Toggle the stroke of the selected rectangle
                    // selectedElement.style("stroke", "red");

                    // // If the rectangle is already stroked, remove the stroke and revert circle's fill color
                    // if (isRectangleStroked) {
                    //     var initialCircleFill = correspondingCircle.attr("data-initial-fill"); // Retrieve the initial fill color
                    //     selectedElement.style("stroke", "none");
                    //     correspondingCircle.style("fill", initialCircleFill)
                    //         .classed("pulse1", false)
                    //     synchronizeAnimations(correspondingCircle.node(), true)
                    // } else {
                    //     // If the rectangle is not stroked, toggle the stroke and set circle's fill color
                    //     currentCircleFill = correspondingCircle.attr("data-initial-fill");
                    //     console.log(correspondingCircle)
                    //     console.log(currentCircleFill)
                    //     correspondingCircle.attr("data-initial-fill", currentCircleFill); // Save the initial fill color
                    //     selectedElement.style("stroke", "red");
                    //     correspondingCircle.style("fill", myColor(d.value)).classed("pulse1", true);
                    //     console.log(correspondingCircle)
                    //     synchronizeAnimations(correspondingCircle.node(), false)
                    // }
                });


            // Highlight the corresponding heatmap squares
            square
                .filter(function (heatmapData) {
                    // console.log(heatmapData)

                    return selectedGeneData.includes(heatmapData.gene);
                })
                .style("opacity", 1) // Change opacity to highlight
                .style("stroke", "yellow") // Change stroke color to highlight (optional)
                .style("stroke-width", 2); // Increase stroke width (optional)


            // Define the color scale for the legend
            var legendScale = d3.scaleLinear()
                .domain([d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])),
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v]))])
                .range([0, 150]); // Adjust the range according to the height of the heatmap

            // Specify the tick values based on desired intervals
            var tickValues = [
                d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v])), // Minimum value
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) / 4, // 1/4 of maximum
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) / 2, // 2/4 of maximum
                (d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) - d3.min(heatmap_data_subset, d => d3.min(myVars, v => d[v]))) * 3 / 4, // 3/4 of maximum
                d3.max(heatmap_data_subset, d => d3.max(myVars, v => d[v])) // Maximum value
            ];

            // Create a separate SVG element for the legend
            var legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", "translate(" + (width + 20) + "," + 10 + ")"); // Adjust this based on your layout

            // Create color gradient for legend
            var defs = legend.append("defs");
            var linearGradient = defs.append("linearGradient")
                .attr("id", "linear-gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%");

            // Add color stops based on the heatmap color scale
            myColor.ticks(10).forEach(function (t, i, n) {
                linearGradient.append("stop")
                    .attr("offset", (100 * i / n.length) + "%")
                    .attr("stop-color", myColor(t));
            });

            // Draw rectangle to display the legend
            legend.append("rect")
                .attr("width", 10)
                .attr("height", 150)
                .style("fill", "url(#linear-gradient)");

            legendAxis = d3.axisRight(legendScale)
                .tickValues(tickValues)
                .tickFormat(function (d) { return (d).toFixed(2) + "%"; }); // Format tick values with three digits after the comma and add a percentage symbol
            var axis = legend.append("g")
                .attr("class", "legend-axis")
                .attr("transform", "translate(20,0)")
                .call(legendAxis);

            // Apply style to axis ticks to make them white
            axis.selectAll("text").style("fill", "var(--text-color)").style("font-size", "13px")
            axis.selectAll("line").style("stroke", "var(--text-color)");


            svg.append("g")
                .style("font-size", 15)
                .style("fill", "var(--text-color)")
                .call(d3.axisLeft(y).tickSize(0))
                .select(".domain").remove();

            // Select and style the tick text for the Y axis
            svg.selectAll(".tick text")
                .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                .style("fill", function (d) {
                    console.log(d)
                    if (selectedGeneData.includes(d)) {
                        const geneData = parsedLogFC.find(item => item.Gene === d);
                        console.log(geneData)
                        if (geneData) {
                            console.log(geneData.logFC)
                            return geneData.logFC > 0 ? "#C14A82" : "#1A74D5"; // Color based on logFC value
                        }
                    } else {
                        return "var(--text-color)"
                    }
                }) // Set the default color to white
                .classed("pulse", function (d) {
                    // Check if d (the current tick value) exists in selectedGeneData
                    return false; // d should be the gene identifier
                })
                .style("cursor", "pointer") // Change cursor to pointer on hover
                .style("font-size", function () {
                    // Dynamically set font size based on displayed_rows
                    if (displayed_rows > 20) {
                        return Math.max(6, 15 - (displayed_rows - 20) * 0.4) + "px"; // Reduce font size as displayed_rows increases
                    }
                    return "15px"; // Default font size
                })
                .on("mouseover", function (d) {
                    if (displayed_rows > 15) {
                        // Lower the opacity of all other text elements
                        svg.selectAll(".tick text")
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 0.2);

                        // Zoom in and bring the hovered element to the front
                        const hoveredText = d3.select(this)
                            .style("font-size", "20px") // Increase font size
                            .style("font-weight", "bold") // Make it bold
                            .style("opacity", 1) // Ensure the hovered element remains fully visible
                            .attr("dx", "10px") // Slightly shift right
                            .attr("dy", "0px"); // Keep it aligned

                        // Re-append the element to bring it to the front
                        hoveredText.node().parentNode.appendChild(hoveredText.node());

                        // Highlight the corresponding heatmap squares
                        square
                            .filter(function (heatmapData) {
                                console.log(heatmapData)
                                console.log(d)

                                return heatmapData.gene === d; // Match the hovered tick text with the heatmap gene
                            })
                            .style("opacity", 1) // Change opacity to highlight
                            .style("stroke", "yellow") // Change stroke color to highlight (optional)
                            .style("stroke-width", 2); // Increase stroke width (optional)

                    } else {
                        d3.select(this)
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 0.7); // Simple opacity change when fewer than 15 rows

                    }
                    // synchronizeAnimations(this, true)

                })
                .on("mouseout", function (d) {
                    if (displayed_rows > 15) {
                        // Reset the opacity of all text elements to 1
                        svg.selectAll(".tick text")
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 1)
                            .style("font-size", function () {
                                // Dynamically set font size based on displayed_rows
                                if (displayed_rows > 20) {
                                    return Math.max(6, 15 - (displayed_rows - 20) * 0.4) + "px"; // Reduce font size as displayed_rows increases
                                }
                                return "15px"; // Default font size
                            })

                        // Reset the style of the hovered element
                        d3.select(this)
                            .style("font-size", function () {
                                // Dynamically set font size based on displayed_rows
                                if (displayed_rows > 20) {
                                    return Math.max(6, 15 - (displayed_rows - 20) * 0.4) + "px"; // Reduce font size as displayed_rows increases
                                }
                                return "15px"; // Default font size
                            }) // Revert font size
                            .style("font-weight", "normal") // Revert to normal weight
                            .style("opacity", 1) // Full opacity for all text elements
                            .attr("dx", "0px"); // Revert to original position

                        square
                            .style("opacity", 1) // Reset opacity
                            .style("stroke", "none"); // Reset stroke (optional)

                        // Highlight the corresponding heatmap squares
                        square
                            .filter(function (heatmapData) {
                                console.log(heatmapData)
                                console.log(selectedGeneData)

                                return selectedGeneData.includes(heatmapData.gene); // Match the hovered tick text with the heatmap gene
                            })
                            .style("opacity", 1) // Change opacity to highlight
                            .style("stroke", "yellow") // Change stroke color to highlight (optional)
                            .style("stroke-width", 2); // Increase stroke width (optional)


                    } else {
                        d3.select(this)
                            .filter(function (d) { return myGroups.includes(d); }) // Ensure we only target Y-axis ticks
                            .style("opacity", 1) // Reset opacity for fewer than 15 rows
                    }
                    // synchronizeAnimations(this, true)

                })
                .on("click", function (d) {
                    // Toggle gene in selectedGeneData
                    const index = selectedGeneData.indexOf(d);
                    // Get the select element
                    var select = document.getElementById("selectButton");

                    if (index > -1) {
                        // Gene is already selected, remove it
                        selectedGeneData.splice(index, 1);
                        d3.select(this).classed("pulse", false)

                        d3.select(this).style("fill", function (d) {
                            if (selectedGeneData.includes(d)) {
                                console.log("selectedGeneData includes " + d)
                                const geneData = parsedLogFC.find(item => item.Gene === d);
                                if (geneData) {
                                    return geneData.logFC > 0 ? "#C14A82" : "#1A74D5"; // Color based on logFC value
                                }
                            } else {
                                return "var(--text-color)"
                            }
                        })
                        square
                            .filter(function (heatmapData) {
                                console.log(heatmapData)

                                return heatmapData.gene === d;
                            })
                            .style("opacity", 1) // Change opacity to highlight
                            .style("stroke", null) // Change stroke color to highlight (optional)
                            .style("stroke-width", null); // Increase stroke width (optional)

                        dehighlightHeatmapRow(d)

                    } else {
                        // Gene is not selected, add it
                        selectedGeneData.push(d);
                        d3.select(this).style("fill", function (d) {
                            if (selectedGeneData.includes(d)) {
                                console.log("selectedGeneData includes " + d)
                                const geneData = parsedLogFC.find(item => item.Gene === d);
                                if (geneData) {
                                    return geneData.logFC > 0 ? "#C14A82" : "#1A74D5"; // Color based on logFC value
                                }
                            } else {
                                return "var(--text-color)"
                            }
                        })
                        // Add new options for the genes in selectedGeneData that are not already in the select element
                        highlightHeatmapRows()
                    }
                    console.log("Updated selectedGeneData:", selectedGeneData);

                    // synchronizeAnimations(this, true)

                    dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy, dataN_copy, first_dims);
                    if (ridge) {
                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    } else {
                        updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                    }
                    if (currentPlot === 'volcano') {
                        updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                    } else if (currentPlot === 'scatter') {
                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                    } else {
                        updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                    }
                    square
                        .filter(function (heatmapData) {
                            console.log(heatmapData)

                            return selectedGeneData.includes(heatmapData.gene);
                        })
                        .style("opacity", 1) // Change opacity to highlight
                        .style("stroke", "yellow") // Change stroke color to highlight (optional)
                        .style("stroke-width", 2); // Increase stroke width (optional)


                    // Optionally, you can trigger an update or refresh of your visualization
                    // updateVisualization();
                });

            function synchronizeAnimations(targetElement, banana) {

                const elements = [
                    ...document.querySelectorAll('.pulse'),
                    ...document.querySelectorAll('.pulse1')
                ];
                let targetAnimation
                if (banana) {
                    targetAnimation = findAnimByName(targetElement, 'pulseAnimation');
                }
                else {
                    targetAnimation = findAnimByName(targetElement, 'pulseAnimation1');
                }
                // Retrieve the Animation object of the target element

                if (!targetAnimation) {
                    return
                }

                console.log("sono passato")

                // Get the current time of the target animation
                const targetTime = targetAnimation.currentTime;

                // Loop through each element with the class 'pulse'
                elements.forEach(element => {
                    // Retrieve the Animation object of the current element
                    let currentAnimation = findAnimByName(element, 'pulseAnimation');

                    if (!currentAnimation) {
                        currentAnimation = findAnimByName(element, 'pulseAnimation1');
                    }

                    // Get the current time of the current animation
                    const currentTime = currentAnimation.currentTime;

                    // Calculate the time difference between the target animation and the current animation
                    const timeDifference = targetTime - currentTime;

                    // Adjust the playback position of the current animation to match the target animation
                    currentAnimation.currentTime += timeDifference;
                });
            }

            // Simple helper to find an Animation by animationName
            function findAnimByName(elem, name) {
                // Get all the active animations on this element
                const anims = elem.getAnimations();

                // console.log(anims)

                // Return the first one with the expected animationName
                return anims.find((anim) => anim.animationName === name);
            }

            // Remove the domain path
            axis.select(".domain").remove();

            // applyThemeToSVG()

        }

        function dendo_heatmap() {
            document.getElementById("loadingOverlay").style.display = "block";
            return new Promise((resolve, reject) => {

                var req = ocpu.call("heatmap_mod?no_cache=1", {
                    data: data_copy_pval,
                    metadata: meta_for_heatmap,
                    field: selectedRowName,
                    case: chosen_meta1,
                    distance: "correlation",
                    method: "average",
                    show_cols: false,
                    show_rows: false,
                    cutreeCols: 2,
                    cutreeRows: 2
                }, function (session) {
                    var filteredDataURL = session.loc + "/R/.val/json";

                    // Fetch the filtered data from the URL
                    fetch(filteredDataURL)
                        .then(response => {
                            // Check if the response is ok (status 200-299)
                            if (!response.ok) {
                                reject(new Error(`Error fetching data: ${response.status} ${response.statusText}`));
                                return
                            }
                            return response.json();
                        })
                        .then(data => {
                            d3.select("#heatmapCon").html("")
                            console.log(session);
                            const parsedData = JSON.parse(data[0]);
                            var data = parsedData

                            var margin = { top: 10, right: 0, bottom: 10, left: 0 },
                                height = 150 - margin.top - margin.bottom;

                            var labelsFromTree = function (nodes, cluster) {
                                var labels = [];

                                for (var n in nodes) {
                                    if (!nodes[n].children || nodes[n].children.length === 0) {
                                        labels.push(nodes[n].name[0]);
                                    }
                                }
                                return labels;
                            };

                            var clusterSpace = 150, // size of the cluster tree
                                cellSize = 12,
                                colNumber = data.col_clusters.length,
                                rowNumber = data.row_clusters.length,
                                width = cellSize * colNumber + clusterSpace + 12, // - margin.left - margin.right,
                                height = cellSize * rowNumber + clusterSpace, // - margin.top - margin.bottom,
                                rowCluster = d3.cluster()
                                    .size([height - clusterSpace, clusterSpace]),
                                colCluster = d3.cluster()
                                    .size([width - clusterSpace, clusterSpace]),
                                numberOfColors = 100,
                                colors = d3.range(numberOfColors).map(i => d3.interpolateYlGnBu(i / (numberOfColors - 1)));

                            var svg = d3.select("#heatmapCon")
                                .append("svg")
                                .attr("viewBox", `0 0 ${width + margin.left + margin.right + clusterSpace} ${height + margin.top + margin.bottom + clusterSpace}`)
                                .attr("width", "100%")
                                .attr("height", "100%")
                                .attr("preserveAspectRatio", "xMinYMin meet");

                            console.log(data.row_dendrogram)
                            console.log(data)
                            var rowNodes = rowCluster(d3.hierarchy(data.row_dendrogram));
                            var colNodes = colCluster(d3.hierarchy(data.col_dendrogram));
                            var labelsFromTree = function (nodes) {
                                return nodes.leaves().map(function (node) {
                                    return node.data.name[0];
                                });
                            };

                            rowLabel = labelsFromTree(rowNodes);
                            var colLabel = labelsFromTree(colNodes);
                            var matrix = [], min = Infinity, max = -Infinity;

                            var cellData = data.cell_data; // Assuming data is passed as a parameter

                            // Iterate through the cell_data to populate the matrix
                            cellData.forEach(function (d) {
                                var rowIndex = d.row[0] - 1; // Adjusting for 0-based index
                                var colIndex = d.col[0] - 1; // Adjusting for 0-based index
                                var value = d.value[0]; // Accessing the value directly

                                // Ensure the matrix has enough rows
                                while (matrix.length <= rowIndex) {
                                    matrix.push(new Array(data.colNumber).fill(0)); // Fill with default values
                                }

                                matrix[rowIndex][colIndex] = value; // Set the value in the correct position
                            });

                            // Now calculate the min and max values and flatten the matrix
                            var flatMatrix = [];
                            min = 0; // Reset min to calculate correctly
                            max = 0; // Reset max to calculate correctly
                            console.log(rowNumber)
                            console.log(colNumber)
                            // for (var r = 0; r < rowNumber; r++) {
                            //     for (var c = 0; c < colNumber; c++) {
                            //         console.log(matrix[r][c])
                            //         var cellValue = matrix[r][c]; // Get the value at the current cell
                            //         flatMatrix.push({ row: r + 1, col: c + 1, value: cellValue }); // Populate flatMatrix
                            //         min = Math.min(min, cellValue); // Update min value
                            //         max = Math.max(max, cellValue); // Update max value
                            //     }
                            // }

                            for (var r = 0; r < rowNumber; r++) {
                                var rowValues = matrix[r].filter(v => v !== 0); // Filter out default values if necessary

                                // Calculate mean and standard deviation from original values, not filtered
                                var mean = d3.mean(matrix[r]); // Calculate mean for the entire row
                                var stdDev = d3.deviation(matrix[r]); // Calculate standard deviation for the entire row

                                for (var c = 0; c < colNumber; c++) {
                                    var cellValue = matrix[r][c]; // Get the value at the current cell

                                    // Standardize the value if stdDev is not zero
                                    if (stdDev !== 0) {
                                        cellValue = (cellValue - mean) / stdDev; // Calculate z-score

                                        // Cap z-score at the threshold of 3
                                        if (cellValue > 3) {
                                            cellValue = 3;
                                        } else if (cellValue < -3) {
                                            cellValue = -3;
                                        }
                                    } else {
                                        cellValue = 0; // If stdDev is zero, assign 0 to avoid NaN
                                    }

                                    flatMatrix.push({ row: r + 1, col: c + 1, value: cellValue }); // Populate flatMatrix
                                    min = Math.min(min, cellValue); // Update min value
                                    max = Math.max(max, cellValue); // Update max value
                                }
                            }

                            // Optionally check the resulting matrix
                            console.log(matrix);
                            console.log(flatMatrix);

                            matrix = flatMatrix
                            // Calculate the median correctly
                            var values = flatMatrix.map(d => d.value); // Extract the values
                            var middle = d3.median(values); // Now compute the median

                            console.log("Median Value: ", middle);

                            var colorScale = d3.scaleDiverging()
                                .domain([min, middle, max])
                                .range(['#00fefc', '#f7f7f7', '#FF6700']);

                            svg.selectAll("*").remove();

                            // svg.attr("width", width + margin.left + margin.right + clusterSpace)
                            //     .attr("height", height + margin.top + margin.bottom + clusterSpace);

                            var colClusters = data.col_clusters;

                            // Assuming colClusters is an array of objects like [{ Column: "Col1", Cluster: 1 }, ...]
                            var colClusterMap = {};
                            colClusters.forEach(item => {
                                colClusterMap[item.Col] = item.Cluster;
                            });

                            console.log("Column to Cluster Map:", colClusterMap);

                            // Determine cluster boundaries based on colLabel order
                            var colclusterBoundaries = [];
                            for (let i = 1; i < colLabel.length; i++) {
                                // Check if the current column's cluster differs from the previous column's cluster
                                const prevCluster = colClusterMap[colLabel[i - 1]];
                                const currentCluster = colClusterMap[colLabel[i]];

                                if (currentCluster !== prevCluster) {
                                    colclusterBoundaries.push(i); // Store the index where a new cluster starts
                                }
                            }

                            console.log("Column Cluster Boundaries:", colclusterBoundaries);

                            console.log(colclusterBoundaries)

                            var rowClusters = data.row_clusters;

                            var rowClusterMap = {};
                            rowClusters.forEach(item => {
                                rowClusterMap[item.Row] = item.Cluster;
                            });

                            var rowclusterBoundaries = [];
                            for (let i = 1; i < rowLabel.length; i++) {
                                // Check if the current column's cluster differs from the previous column's cluster
                                const prevCluster = rowClusterMap[rowLabel[i - 1]];
                                const currentCluster = rowClusterMap[rowLabel[i]];

                                if (currentCluster !== prevCluster) {
                                    rowclusterBoundaries.push(i); // Store the index where a new cluster starts
                                }
                            }

                            console.log(rowclusterBoundaries)

                            function calculateGap(boundaries, index) {
                                let gap = 0;
                                boundaries.forEach(boundary => {
                                    if (index >= boundary) {
                                        gap += 3; // Adjust this based on the gap size used in the heatmap
                                    }
                                });
                                return gap;
                            }

                            var rowLabels = svg.append("g")
                                .selectAll(".rowLabelg")
                                .data(rowLabel)
                                .enter()
                                .append("text")
                                .text(function (d) {
                                    return d;
                                })
                                .attr("x", function (d) {
                                    return rowclusterBoundaries.length * 3 + 12
                                })
                                .attr("y", function (d, i) {
                                    var gap = calculateGap(rowclusterBoundaries, i);

                                    return (i + 1) * cellSize + clusterSpace + gap + (12) + 12;
                                })
                                .style("text-anchor", "start")
                                .attr("transform", "translate(" + (width + cellSize) + "," + cellSize / 1.5 + ")")
                                .attr("class", function (d, i) {
                                    return "rowLabel mono r" + i;
                                });

                            var colLabels = svg.append("g")
                                .selectAll(".colLabelg")
                                .data(colLabel)
                                .enter()
                                .append("text")
                                .text(function (d) {
                                    return d;
                                })
                                .attr("x", - (12 + 12))
                                .attr("y", function (d, i) {
                                    var gap = calculateGap(colclusterBoundaries, i);

                                    return (i + 1) * cellSize + gap + 4 + 12 + 12;
                                })
                                .style("text-anchor", "end")
                                .attr("transform", "translate(" + cellSize / 2 + ",-6) rotate (-90)  translate( -" + (height + cellSize * 2) + "," + clusterSpace + ")")
                                .attr("class", function (d, i) {
                                    return "colLabel mono c" + i;
                                });

                            console.log(meta_for_heatmap)
                            console.log(colLabel)

                            // Extract the metadata row key (the first key) from each entry in meta_for_heatmap
                            var orderedMetadata = meta_for_heatmap.map((metaRow) => {
                                const metaCategory = Object.keys(metaRow)[0]; // The first key as the category name

                                // Sort the metadata values by the order in colLabel
                                const sortedMetaValues = colLabel.map(col => metaRow[col]);

                                // Return an object with the category and ordered values for each column in colLabel
                                return {
                                    category: metaRow[metaCategory], // Store the category name (like 'Type', 'Age', etc.)
                                    values: sortedMetaValues          // The sorted metadata values
                                };
                            });

                            // Meta labels

                            var rowMetaLabels = svg.append("g")
                                .selectAll(".rowMetaLabelg")
                                .data(orderedMetadata)
                                .enter()
                                .append("text")
                                .text(function (d) {
                                    if (d.category == selectedRowName) return d.category; // Access the category property
                                })
                                .attr("x", function (d) {
                                    if (d.category == selectedRowName) return rowclusterBoundaries.length * 3 + 12; // Adjust the x position if necessary
                                })
                                .attr("y", function (d, i) {
                                    if (d.category == selectedRowName) return (i + 1) * cellSize + clusterSpace + 2; // Calculate the y position based on the index
                                })
                                .style("text-anchor", "start")
                                .attr("transform", "translate(" + (width + cellSize) + "," + cellSize / 1.5 + ")")
                                .attr("class", function (d, i) {
                                    if (d.category == selectedRowName) return "rowMetaLabel " + i; // Class naming for styling purposes
                                });

                            // Col meta cells

                            console.log(orderedMetadata)

                            // Set the offset to position metadata rows at the top of the heatmap
                            var metadataOffset = clusterSpace; // Offset above the heatmap
                            console.log(colorScaleValues)

                            var metaColors = colorScaleValues;

                            // Define multiple color ranges for monochromatic scales (avoiding green and blue)
                            const monochromaticRanges = [
                                ["#F4B653", "#e69f00"], // Light to dark #C14A82
                                ["#ffebcd", "#cd5c5c"], // Light bisque to Indian red
                                ["#ffe4b5", "#b8860b"], // Light moccasin to dark goldenrod
                                ["#fffacd", "#ffa500"], // Lemon chiffon to #C14A82
                                // Add more color ranges as needed
                            ];

                            let currentRangeIndex = 0; // To keep track of which color range to use

                            // Define color scales for missing metadata categories
                            orderedMetadata.forEach(metaRow => {
                                const category = metaRow.category;
                                // If the category is already in metaColors, skip it
                                if (!metaColors[category]) {
                                    // Check if there are any numeric values
                                    const numericValues = metaRow.values.filter(value => !isNaN(value) && value !== "");
                                    const hasNumericValues = numericValues.length > 0;
                                    const hasNonNumericValues = metaRow.values.some(value => isNaN(value) || value === "");

                                    // Create a new color scale for this category
                                    if (hasNumericValues && !hasNonNumericValues) {
                                        // Cycle through monochromatic color ranges
                                        const colorRange = monochromaticRanges[currentRangeIndex];
                                        currentRangeIndex = (currentRangeIndex + 1) % monochromaticRanges.length; // Update to the next range

                                        // Create a linear color scale for purely numeric values
                                        const minVal = Math.min(...numericValues);
                                        const maxVal = Math.max(...numericValues);
                                        const linearScale = d3.scaleLinear()
                                            .domain([minVal, maxVal])
                                            .range(colorRange);

                                        // Assign colors to each unique numeric value
                                        metaColors[category] = {};
                                        metaRow.values.forEach(value => {
                                            if (!metaColors[category][value]) {
                                                metaColors[category][value] = !isNaN(value) && value !== "" ? linearScale(value) : "#d3d3d3"; // Gray for NaN or ""
                                            }
                                        });

                                    } else if (hasNumericValues && hasNonNumericValues) {
                                        // For mixed numeric and non-numeric values, numeric values get a monochromatic scale, others get gray
                                        const colorRange = monochromaticRanges[currentRangeIndex];
                                        currentRangeIndex = (currentRangeIndex + 1) % monochromaticRanges.length; // Update to the next range

                                        // Create a linear color scale for mixed values
                                        const minVal = Math.min(...numericValues);
                                        const maxVal = Math.max(...numericValues);
                                        const linearScale = d3.scaleLinear()
                                            .domain([minVal, maxVal])
                                            .range(colorRange);

                                        // Assign colors, gray for NaN or ""
                                        metaColors[category] = {};
                                        metaRow.values.forEach(value => {
                                            metaColors[category][value] = !isNaN(value) && value !== "" ? linearScale(value) : "#d3d3d3";
                                        });
                                    }
                                    else {
                                        // Create a categorical color scale for purely non-numeric values
                                        const uniqueValues = Array.from(new Set(metaRow.values));
                                        const categoricalScale = d3.scaleOrdinal()
                                            .domain(uniqueValues)
                                            .range(d3.schemeCategory10); // Use D3s Category10 color scheme

                                        // Assign colors to each unique value in this category
                                        metaColors[category] = {};
                                        uniqueValues.forEach(value => {
                                            metaColors[category][value] = categoricalScale(value);
                                        });
                                    }
                                }
                            });

                            console.log(metaColors); // Verify the extended metaColors


                            // Add a metadata row for each category in orderedMetadata
                            orderedMetadata.forEach((metaRow, rowIndex) => {
                                if (metaRow.category === selectedRowName) {

                                    svg.append("g")
                                        .attr("class", "metadata-row")
                                        .selectAll(".metaCell")
                                        .data(metaRow.values)
                                        .enter()
                                        .append("rect")
                                        .attr("class", "metaCell")
                                        .attr("x", (d, i) => {
                                            var gap = 0;
                                            colclusterBoundaries.forEach(boundary => {
                                                if (i + 1 > boundary) {
                                                    gap += 3; // Add space for each cluster boundary
                                                }
                                            });
                                            return (i + 1) * cellSize + clusterSpace + gap + 12 + 12;
                                        })
                                        .attr("y", function (d) {
                                            return (rowIndex + 1) * cellSize + clusterSpace;
                                        }
                                        ) // Position each metadata row above the heatmap
                                        .attr("width", cellSize)
                                        .attr("height", cellSize * 2)
                                        .style("fill", (d) => {
                                            // Access color scale for the current metadata category (e.g., 'Type', 'Gender', etc.)
                                            const category = metaRow.category;
                                            if (metaColors[category]) {
                                                return metaColors[category][d]; // Use the color if it exists, otherwise fallback to gray
                                            }
                                            else {
                                                return "#d3d3d3"
                                            }
                                        })
                                        .on("mouseover", function (d, i) {
                                            d3.select(this).classed("cell-hover", true);
                                            d3.select("#d3tooltip")
                                                .style("left", (d3.event.pageX + 10) + "px")
                                                .style("top", (d3.event.pageY - 10) + "px")
                                                .select("#value")
                                                .html("Sample name: " + colLabel[i] + "<br>" + metaRow.category + ": " + d);
                                            d3.select("#d3tooltip").transition()
                                                .duration(200)
                                                .style("opacity", .9);
                                            // Highlight the corresponding row label
                                            var rowClass = 'r' + (d.row - 1); // Class for row label
                                            d3.selectAll(`.${rowClass}`).classed("text-highlight", true); // Apply text highlight class

                                            // Highlight the corresponding column label
                                            var colClass = 'c' + (d.col - 1); // Class for column label
                                            d3.selectAll(`.${colClass}`).classed("text-highlight", true); // Apply text highlight class
                                        })
                                        .on("mouseout", function () {
                                            // Remove the cell hover effect
                                            d3.select(this).classed("cell-hover", false);
                                            d3.selectAll(".text-highlight").classed("text-highlight", false);

                                            // Remove text highlighting from the labels
                                            d3.selectAll(".rowLabel")
                                                .filter(function () {
                                                    return d3.select(this).classed("selected"); // Select only cells that have the 'selected' class
                                                })
                                                .classed("text-highlight", true);


                                            d3.select("#d3tooltip").transition()
                                                .duration(200)
                                                .style("opacity", 0);
                                        });
                                }

                            });

                            // Row meta cells

                            // Assuming `parsedLogFC` is an array of objects like [{ gene: "Gene1", logFC: -2.3 }, ...]
                            // Step 1: Create a lookup for logFC by gene name
                            const logFCMap = {};
                            parsedLogFC.forEach(item => {
                                logFCMap[item.Gene] = item.logFC;
                            });

                            // Find min and max logFC values for the color scale
                            const minLogFC = d3.min(Object.values(logFCMap));
                            const maxLogFC = d3.max(Object.values(logFCMap));

                            var metaGenes = svg.append("g").attr("class", "g3")
                                .selectAll(".cellg")
                                .data(rowLabel)
                                .enter()
                                .append("rect")
                                .attr("x", function (d) {
                                    return (1) * cellSize + clusterSpace;
                                })
                                .attr("y", function (d, i) {
                                    // Check for gap at the start of a new cluster
                                    var gap = 0;
                                    rowclusterBoundaries.forEach(boundary => {
                                        if ((i + 1) > boundary) {
                                            gap += 3; // Add space for each cluster boundary
                                        }
                                    });
                                    return (i + 1) * cellSize + clusterSpace + gap + (12) + 12;
                                })
                                .attr("class", function (d, i) {
                                    return "cell cell-border cr" + (i) + " cc" + (colLabel.length);
                                })
                                .attr("width", cellSize * 2)
                                .attr("height", cellSize)
                                .style("fill", function (d) {
                                    // Use color scale based on the matched logFC value for this gene
                                    const logFCValue = logFCMap[d] || 0;  // Default to 0 if no match found
                                    return logFCValue < 0 ? "#1A74D5" : "#C14A82";
                                })
                                .on("mouseover", function (d, i) {
                                    d3.select(this).classed("cell-hover", true);
                                    d3.select("#d3tooltip")
                                        .style("left", (d3.event.pageX + 10) + "px")
                                        .style("top", (d3.event.pageY - 10) + "px")
                                        .select("#value")
                                        .html("Gene: " + rowLabel[i] + "<br>LogFC: " + logFCMap[d]);
                                    d3.select("#d3tooltip").transition()
                                        .duration(200)
                                        .style("opacity", .9);
                                    // Highlight the corresponding row label
                                    var rowClass = 'r' + (i); // Class for row label
                                    d3.selectAll(`.${rowClass}`).classed("text-highlight", true); // Apply text highlight class
                                })
                                .on("mouseout", function () {
                                    // Remove the cell hover effect
                                    d3.select(this).classed("cell-hover", false);
                                    d3.selectAll(".text-highlight").classed("text-highlight", false);

                                    // Remove text highlighting from the labels
                                    d3.selectAll(".rowLabel")
                                        .filter(function () {
                                            return d3.select(this).classed("selected"); // Select only cells that have the 'selected' class
                                        })
                                        .classed("text-highlight", true);


                                    d3.select("#d3tooltip").transition()
                                        .duration(200)
                                        .style("opacity", 0);
                                });

                            console.log(rowLabel)

                            // Cells values

                            var heatMap = svg.append("g").attr("class", "g3")
                                .selectAll(".cellg")
                                .data(flatMatrix, function (d) {
                                    return d.row + ":" + d.col;
                                })
                                .enter()
                                .append("rect")
                                .attr("x", function (d) {
                                    // Check for gap at the start of a new cluster
                                    var gap = 0;
                                    colclusterBoundaries.forEach(boundary => {
                                        if (d.col > boundary) {
                                            gap += 3; // Add space for each cluster boundary
                                        }
                                    });
                                    return d.col * cellSize + clusterSpace + gap + 12 + 12;
                                })
                                .attr("y", function (d) {
                                    // Check for gap at the start of a new cluster
                                    var gap = 0;
                                    rowclusterBoundaries.forEach(boundary => {
                                        if (d.row > boundary) {
                                            gap += 3; // Add space for each cluster boundary
                                        }
                                    });
                                    return d.row * cellSize + clusterSpace + gap + (12) + 12;
                                })
                                .attr("class", function (d) {
                                    return "cell cell-border cr" + (d.row - 1) + " cc" + (d.col - 1);
                                })
                                .attr("width", cellSize)
                                .attr("height", cellSize)
                                .style("fill", function (d) {
                                    return colorScale(d.value);
                                })
                                .on("mouseover", function (d) {
                                    d3.select(this).classed("cell-hover", true);
                                    d3.select("#d3tooltip")
                                        .style("left", (d3.event.pageX + 10) + "px")
                                        .style("top", (d3.event.pageY - 10) + "px")
                                        .select("#value")
                                        .html("Sample name: " + colLabel[d.col - 1] + "<br>Gene name: " + rowLabel[d.row - 1] + "<br>Value: " + d.value);
                                    d3.select("#d3tooltip").transition()
                                        .duration(200)
                                        .style("opacity", .9);
                                    // Highlight the corresponding row label
                                    var rowClass = 'r' + (d.row - 1); // Class for row label
                                    d3.selectAll(`.${rowClass}`).classed("text-highlight", true); // Apply text highlight class

                                    // Highlight the corresponding column label
                                    var colClass = 'c' + (d.col - 1); // Class for column label
                                    d3.selectAll(`.${colClass}`).classed("text-highlight", true); // Apply text highlight class
                                })
                                .on("mouseout", function () {
                                    // Remove the cell hover effect
                                    d3.select(this).classed("cell-hover", false);
                                    d3.selectAll(".text-highlight").classed("text-highlight", false);

                                    // Remove text highlighting from the labels
                                    d3.selectAll(".rowLabel")
                                        .filter(function () {
                                            return d3.select(this).classed("selected"); // Select only cells that have the 'selected' class
                                        })
                                        .classed("text-highlight", true);


                                    d3.select("#d3tooltip").transition()
                                        .duration(200)
                                        .style("opacity", 0);
                                });

                            // Recursive function to get unique child names
                            function getChildNames(node) {
                                const names = new Set(); // Use a Set to collect unique names

                                if (node.children && node.children.length > 0) {
                                    node.children.forEach(child => {
                                        // Only add the name if it's a leaf node
                                        if (child.data.name && child.data.name.length > 0) {
                                            names.add(child.data.name[0]); // Add the child's name to the Set
                                        }
                                        // Recursively get names from children
                                        const childNames = getChildNames(child);
                                        childNames.forEach(name => names.add(name)); // Add all unique names from children
                                    });
                                } else if (node.data.name && node.data.name.length > 0) {
                                    // If no children, add the current node's name
                                    names.add(node.data.name[0]);
                                }

                                return Array.from(names); // Convert Set back to an array before returning
                            }

                            function getChildren(node) {
                                // Initialize an array to hold the children
                                let childrenArray = [];

                                // If the node has children, process them
                                if (node.children && node.children.length > 0) {
                                    node.children.forEach(child => {
                                        // Add the child to the array
                                        childrenArray.push(child);
                                        // Recursively get the child's children and merge them into the array
                                        childrenArray = childrenArray.concat(getChildren(child));
                                    });
                                }

                                return childrenArray;
                            }


                            // Tree for rows
                            rTree = svg.append("g").attr("class", "rtree").attr("transform", "translate (10, " + (clusterSpace + cellSize + (12) + 12) + ")");

                            var rlink = rTree.selectAll(".rlink")
                                .data(rowNodes.links())
                                .enter().append("path")
                                .attr("class", "rlink")
                                .attr("d", elbow);

                            console.log(rowNodes)

                            var rnode = rTree.selectAll(".rnode")
                                .data(rowNodes.descendants())
                                .enter().append("g")
                                .attr("class", "rnode")
                                .attr("transform", function (d) {
                                    return "translate(" + (d.y) + "," + (d.x) + ")"; // Add gap to the y position
                                })
                                .on("mouseover", function (d) {
                                    // Get all unique child names
                                    const names = getChildNames(d);
                                    console.log(names)
                                    // Initialize an array to hold indices
                                    const indices = [];

                                    // Search for names in rowLabel and collect indices
                                    names.forEach(name => {
                                        const index = rowLabel.indexOf(name); // Assuming rowLabel is an array
                                        if (index !== -1) {
                                            indices.push(index); // Add the index if found
                                        }
                                    });
                                    console.log(indices)

                                    // Highlight the corresponding rows
                                    indices.forEach(index => {
                                        var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                        d3.selectAll(`.${className}`).classed("cell-hover", true);

                                        // Highlight the row labels
                                        var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true); // Apply text-highlight class
                                    });
                                })
                                .on("mouseout", function (d) {
                                    // Check if the current node is selected
                                    d3.selectAll(".cell-hover").classed("cell-hover", false);
                                    if (!d3.select(this).classed("selected")) {
                                        // Get all unique child names
                                        const names = getChildNames(d);

                                        // Initialize an array to hold indices
                                        const indices = [];

                                        // Search for names in rowLabel and collect indices
                                        names.forEach(name => {
                                            const index = rowLabel.indexOf(name); // Assuming rowLabel is an array
                                            if (index !== -1) {
                                                indices.push(index); // Add the index if found
                                            }
                                        });


                                        // Remove the hover effect when the mouse leaves
                                        const isSelected = d3.select(this).classed("selected");

                                        // Get all selected cells
                                        const selectedCells = d3.selectAll(".cell.selected");

                                        // Check if any cells are selected
                                        if (selectedCells.size() > 0) {
                                            // Extract the class names of the selected cells
                                            const selectedCellClasses = [];

                                            selectedCells.each(function () {
                                                // 'this' refers to the current cell in the selection
                                                selectedCellClasses.push(this.getAttribute('class'));
                                            });

                                            // Create a set to store selected classes for faster lookup
                                            const selectedClassSet = new Set(selectedCellClasses);
                                            // console.log(selectedClassSet)
                                            // Check if the indices are a subset of selected cells
                                            // Check if the indices are a subset of selected cells
                                            const isSubset = indices.every(index => {
                                                const className = 'cr' + index; // Create the class name for the current index

                                                // Check if any of the selected class strings contain the className
                                                return [...selectedClassSet].some(selectedClass => selectedClass.includes(className));
                                            });

                                            // Output the result
                                            if (isSubset) {
                                                // Reset the circle styles
                                                d3.select(this).select("circle")
                                                    .style("stroke", "none") // Reset the stroke
                                                    .style("stroke-width", "1px") // Reset stroke width
                                                    .attr("r", function (d) {
                                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                                    });
                                            } else {
                                                d3.selectAll(".rowLabel")
                                                    .filter(function () {
                                                        return !d3.select(this).classed("selected"); // Select only cells that do NOT have the 'selected' class
                                                    })
                                                    .classed("text-highlight", false);
                                            }
                                        } else {
                                            d3.selectAll(".rowLabel")
                                                .filter(function () {
                                                    return !d3.select(this).classed("selected"); // Select only cells that do NOT have the 'selected' class
                                                })
                                                .classed("text-highlight", false);
                                        }
                                    }
                                    else {
                                        d3.selectAll(".rowLabel")
                                            .filter(function () {
                                                return !d3.select(this).classed("selected"); // Select only cells that do NOT have the 'selected' class
                                            })
                                            .classed("text-highlight", false);
                                    }
                                })
                                .on("click", function (d) {
                                    let allChildren = getChildren(d);

                                    // If the node has children, process them
                                    if (allChildren && allChildren.length > 0) {
                                        allChildren.forEach(child => {
                                            const svgElement = d3.selectAll(`.rnode`)
                                                .filter(d => d == child) // Match the child to the data

                                            // Check if the svgElement is selected
                                            if (svgElement.classed('selected')) {
                                                // If it's selected, remove the 'selected' class
                                                svgElement.classed('selected', false);
                                                console.log(`Deselected:`, svgElement);

                                                // Access the circle child and set its radius
                                                const circle = svgElement.select('circle'); // Select the circle element
                                                circle
                                                    .attr('r', function (d) {
                                                        return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Radius based on children
                                                    })
                                                    .style("stroke", "none")
                                            }
                                        })
                                    }

                                    if (!d3.select(this).classed("selected")) {
                                        console.log("Non sono selected")
                                        // Get all unique child names of the clicked node
                                        const names = getChildNames(d);

                                        // Initialize an array to hold indices
                                        const indices = [];

                                        // Search for names in rowLabel and collect indices
                                        names.forEach(name => {
                                            const index = rowLabel.indexOf(name); // Assuming rowLabel is an array
                                            if (index !== -1) {
                                                indices.push(index); // Add the index if found
                                            }
                                        });

                                        d3.selectAll(".cell.cell-border")
                                            .filter(function () {
                                                return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell"); // Select only cells that do NOT have the 'selected' class
                                            })
                                            .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                                        // Get all selected cells
                                        const selectedCells = d3.selectAll(".cell.selected");

                                        // Check if any cells are selected
                                        if (selectedCells.size() > 0) {
                                            // Extract the class names of the selected cells
                                            const selectedCellClasses = [];

                                            selectedCells.each(function () {
                                                // 'this' refers to the current cell in the selection
                                                selectedCellClasses.push(this.getAttribute('class'));
                                            });

                                            // Create a set to store selected classes for faster lookup
                                            const selectedClassSet = new Set(selectedCellClasses);
                                            // console.log(selectedClassSet)
                                            // Check if the indices are a subset of selected cells
                                            // Check if the indices are a subset of selected cells
                                            const isSubset = indices.every(index => {
                                                const className = 'cr' + index; // Create the class name for the current index

                                                // Check if any of the selected class strings contain the className
                                                return [...selectedClassSet].some(selectedClass => selectedClass.includes(className));
                                            });

                                            // Output the result
                                            if (isSubset) {
                                                console.log("All indices are a subset of selected cells.");

                                                // Remove the selected cluster cells
                                                indices.forEach(index => {
                                                    var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                                    d3.selectAll(`.${className}`)
                                                        .style("opacity", function (d) {
                                                            return indices.length == rowLabel.length ? 1 : 0.2
                                                        }) // Reset opacity to fully visible
                                                        .classed("selected", false); // Add selected class to highlight the selected cells


                                                    // Highlight the row labels if needed
                                                    var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                                    d3.selectAll(`.${labelClass}`).classed("text-highlight", false); // Apply text-highlight class
                                                    d3.selectAll(`.${labelClass}`).classed("selected", false)
                                                    d3.selectAll(`.${labelClass}`).each(function () {
                                                        // Get the text content of each label
                                                        const text = d3.select(this).text();

                                                        // Find and remove the text content from selectedGeneData if it exists
                                                        const textIndex = selectedGeneData.indexOf(text);
                                                        if (textIndex !== -1) {
                                                            selectedGeneData.splice(textIndex, 1);
                                                        }
                                                    });

                                                });

                                                // Check if any cells have the 'selected' class
                                                const hasSelected = d3.selectAll(".cell.selected").size() > 0;

                                                if (hasSelected) {
                                                    d3.selectAll(".cell")
                                                        .filter(function () {
                                                            return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell"); // Select only cells that do NOT have the 'selected' class
                                                        })
                                                        .style("opacity", 0.2); // Set these cells to be semi-transparent or gray
                                                } else {
                                                    d3.selectAll(".cell")
                                                        .style("opacity", 1); // Set these cells to be semi-transparent or gray

                                                }
                                                // Update selectedFeneData to include new genes and run volcano, ridge and network
                                                // At the end of your click event handler
                                                var selectedRowLabels = []; // Array to hold selected row labels

                                                // Iterate through each row index (from 0 to rowNumber)
                                                for (let i = 0; i < rowNumber; i++) {
                                                    var labelClass = 'r' + i; // Assuming row labels have classes like 'r0', 'r1', etc.

                                                    // Check if the row label has the 'selected' class
                                                    if (d3.selectAll(`.${labelClass}`).classed("selected")) {
                                                        // If it is selected, push the index (or you can push other info) to the array
                                                        selectedRowLabels.push(d3.selectAll(`.${labelClass}`).text()); // or push the label itself if needed, e.g., `d3.selectAll(`.${labelClass}`).text()`
                                                    }
                                                }

                                                // Now, `selectedRowLabels` contains the indices of all selected row labels
                                                console.log(selectedRowLabels); // You can log or process the selected row labels here
                                                selectedGeneData = selectedRowLabels
                                                if (ridge) {
                                                    updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                                } else {
                                                    updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                                }
                                                if (currentPlot === 'volcano') {
                                                    updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                } else if (currentPlot === 'scatter') {
                                                    updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                } else {
                                                    updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                                }
                                                highlightUpRows()
                                                highlightDownRows()

                                                return
                                            } else {
                                                console.log("Not all indices are a subset of selected cells.");
                                            }
                                        } else {
                                            console.log("No selected cells found.");
                                        }


                                        // Highlight the selected cluster cells
                                        indices.forEach(index => {
                                            var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                            d3.selectAll(`.${className}`)
                                                .style("opacity", 1) // Reset opacity to fully visible
                                                .classed("selected", true); // Add selected class to highlight the selected cells


                                            // Highlight the row labels if needed
                                            var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                            d3.selectAll(`.${labelClass}`).classed("text-highlight", true); // Apply text-highlight class
                                            d3.selectAll(`.${labelClass}`).classed("selected", true); // Apply text-highlight class

                                        });

                                        // Toggle the selected state
                                        const circle = d3.select(this).select("circle");
                                        const isSelected = d3.select(this).classed("selected");

                                        d3.select(this).classed("selected", true); // Add selected class
                                        circle.style("stroke", "red") // Change stroke to indicate selection
                                            .attr("r", function (d) {
                                                return (d.children && d.children.length > 0) ? 6 : 3.5; // Radius based on children
                                            });
                                    } else {
                                        console.log("sono selected")
                                        d3.select(this).classed("selected", false); // Remove selected class
                                        // Get all unique child names of the clicked node
                                        const names = getChildNames(d);

                                        // Initialize an array to hold indices
                                        const indices = [];

                                        // Search for names in rowLabel and collect indices
                                        names.forEach(name => {
                                            const index = rowLabel.indexOf(name); // Assuming rowLabel is an array
                                            if (index !== -1) {
                                                indices.push(index); // Add the index if found
                                            }
                                        });


                                        // Highlight the selected cluster cells
                                        indices.forEach(index => {
                                            var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                            d3.selectAll(`.${className}`)
                                                .style("opacity", function (d) {
                                                    return indices.length == rowLabel.length ? 1 : 0.2
                                                }) // Reset opacity to fully visible
                                                .classed("selected", false); // Add selected class to highlight the selected cells


                                            // Highlight the row labels if needed
                                            var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                            d3.selectAll(`.${labelClass}`).classed("text-highlight", false); // Apply text-highlight class
                                            d3.selectAll(`.${labelClass}`).classed("selected", false); // Apply text-highlight class
                                        });

                                        // Check if any cells have the 'selected' class
                                        const hasSelected = d3.selectAll(".cell.selected").size() > 0;

                                        if (hasSelected) {
                                            d3.selectAll(".cell")
                                                .filter(function () {
                                                    return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell"); // Select only cells that do NOT have the 'selected' class
                                                })
                                                .style("opacity", 0.2); // Set these cells to be semi-transparent or gray
                                        } else {
                                            d3.selectAll(".cell")
                                                .style("opacity", 1); // Set these cells to be semi-transparent or gray

                                        }

                                    }

                                    // Update selectedFeneData to include new genes and run volcano, ridge and network
                                    // At the end of your click event handler
                                    var selectedRowLabels = []; // Array to hold selected row labels

                                    // Iterate through each row index (from 0 to rowNumber)
                                    for (let i = 0; i < rowNumber; i++) {
                                        var labelClass = 'r' + i; // Assuming row labels have classes like 'r0', 'r1', etc.

                                        // Check if the row label has the 'selected' class
                                        if (d3.selectAll(`.${labelClass}`).classed("selected")) {
                                            // If it is selected, push the index (or you can push other info) to the array
                                            selectedRowLabels.push(d3.selectAll(`.${labelClass}`).text()); // or push the label itself if needed, e.g., `d3.selectAll(`.${labelClass}`).text()`
                                        }
                                    }

                                    // Now, `selectedRowLabels` contains the indices of all selected row labels
                                    console.log(selectedRowLabels); // You can log or process the selected row labels here
                                    selectedGeneData = selectedRowLabels
                                    if (ridge) {
                                        updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                    } else {
                                        updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                                    }
                                    if (currentPlot === 'volcano') {
                                        updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                    } else if (currentPlot === 'scatter') {
                                        updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                    } else {
                                        updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                                    }
                                    highlightUpRows()
                                    highlightDownRows()
                                    dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims);
                                    heatmap(heatmap_data)
                                });

                            // Update the rowNodes to ensure the hover functionality applies correctly
                            rnode.append("circle")
                                .attr("r", function (d) {
                                    return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Radius based on children
                                })
                                .style("fill", "grey")
                                .style("stroke", "none")
                                .on("mouseover", function (d) {
                                    // Highlight the rays and circles
                                    if (!d3.select(this.parentNode).classed("selected")) {

                                        d3.select(this) // Select the current rnode
                                            .style("stroke", "red") // Change the stroke color of the circle
                                            .attr("r", function (d) {
                                                return (d.children && d.children.length > 0) ? 6 : 3.5; // Radius based on children
                                            });
                                    }
                                })
                                .on("mouseout", function (d) {
                                    // Check if the node is selected
                                    if (!d3.select(this.parentNode).classed("selected")) {
                                        d3.select(this) // Select the current rnode
                                            .style("stroke", "none") // Reset stroke
                                            .attr("r", function (d) {
                                                return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                            });
                                    }
                                });


                            // Tree for cols
                            var cTree = svg.append("g").attr("class", "ctree").attr("transform", "rotate (90), translate (10, -" + ((clusterSpace + cellSize / 2) + 12 + 12) + ") scale(1,-1)");

                            var clink = cTree.selectAll(".clink")
                                .data(colNodes.links())
                                .enter().append("path")
                                .attr("class", "clink")
                                .attr("d", elbow);

                            var cnode = cTree.selectAll(".cnode")
                                .data(colNodes.descendants()) // Use colNodes here
                                .enter().append("g")
                                .attr("class", "cnode")
                                .attr("transform", function (d) {
                                    // Calculate the gap based on cluster boundaries
                                    var gap = 0;
                                    colclusterBoundaries.forEach(boundary => {
                                        if (d.data.clusterIndex > boundary) { // Ensure cluster index is available
                                            gap += 3; // Adjust gap size as needed
                                        }
                                    });
                                    return "translate(" + (d.y + gap) + "," + d.x + ")"; // Add gap to the y position
                                })
                                .on("mouseover", function (d) {
                                    // Get all unique child names
                                    const names = getChildNames(d);
                                    // Initialize an array to hold indices
                                    const indices = [];
                                    // Search for names in colLabel and collect indices
                                    names.forEach(name => {
                                        const index = colLabel.indexOf(name); // Assuming colLabel is an array
                                        if (index !== -1) {
                                            indices.push(index); // Add the index if found
                                        }
                                    });

                                    // Highlight the corresponding columns
                                    indices.forEach(index => {
                                        // Construct the class name based on your naming convention
                                        var className = 'cc' + index; // Assuming 'cc' is the prefix for column classes
                                        // Apply the hover effect on the columns
                                        d3.selectAll(`.${className}`).classed("cell-hover", true);

                                        // Highlight the row labels
                                        var labelClass = 'c' + index;
                                        d3.selectAll(`.${labelClass}`).classed("text-highlight", true); // Apply text-highlight class

                                    });

                                })
                                .on("mouseout", function (d) {
                                    // Get all unique child names
                                    const names = getChildNames(d);
                                    // Initialize an array to hold indices
                                    const indices = [];
                                    // Search for names in colLabel and collect indices
                                    names.forEach(name => {
                                        const index = colLabel.indexOf(name); // Assuming colLabel is an array
                                        if (index !== -1) {
                                            indices.push(index); // Add the index if found
                                        }
                                    });

                                    // Highlight the corresponding columns
                                    indices.forEach(index => {
                                        // Construct the class name based on your naming convention
                                        var className = 'cc' + index; // Assuming 'cc' is the prefix for column classes
                                        // Apply the hover effect on the columns
                                        d3.selectAll(`.${className}`).classed("cell-hover", false);

                                        // Highlight the row labels
                                        var labelClass = 'c' + index;
                                        d3.selectAll(`.${labelClass}`).classed("text-highlight", false); // Apply text-highlight class

                                    });

                                    // Reset the circle styles
                                    d3.select(this) // Select the current cnode
                                        .select("circle") // Select the circle within this cnode
                                        .style("stroke", "none") // Reset the stroke
                                        .style("stroke-width", "1px") // Reset stroke width
                                        .attr("r", function (d) {
                                            return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                        });
                                });

                            // Append circles for column dendrogram nodes
                            cnode.append("circle")
                                .attr("r", function (d) {
                                    return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Set radius based on children
                                })
                                .style("fill", "grey")
                                .style("stroke", "none")
                                .on("mouseover", function (d) {
                                    // Highlight the rays and circles
                                    d3.select(this) // Select the current cnode
                                        .style("stroke", "red") // Change the stroke color of the circle
                                        .attr("r", function (d) {
                                            return (d.children && d.children.length > 0) ? 6 : 3.5; // Radius based on children
                                        })
                                })
                                .on("mouseout", function (d) {
                                    d3.select(this) // Select the current cnode
                                        .style("stroke", "none") // Reset stroke color
                                        .attr("r", function (d) {
                                            return (d.children && d.children.length > 0) ? 3.5 : 1.5; // Reset radius
                                        });
                                });


                            function elbow(d, i) {
                                return "M" + d.source.y + "," + d.source.x
                                    + "V" + d.target.x + "H" + d.target.y;
                            }

                            // Set up legend dimensions
                            const legendWidth = 10;
                            const legendHeight = 80; // Adjusted to match the heatmap height
                            const legendMargin = { top: 30, right: 0, bottom: 20, left: 80 };

                            // Position for the legend SVG group
                            const legendX = cellSize * colNumber + clusterSpace + legendMargin.left;
                            const legendY = legendMargin.top;

                            // Append a group element for the vertical legend
                            const legendSvg = svg.append("g")
                                .attr("class", "legend")
                                .attr("transform", `translate(${legendX - 48}, ${legendY})`);

                            // Add a title for the legend
                            legendSvg.append("text")
                                .attr("x", legendWidth / 2)
                                .attr("y", -10) // Positioning above the gradient
                                .attr("text-anchor", "middle")
                                .style("font-weight", "bold")
                                .text("z-score");


                            // Define vertical color gradient for the legend
                            const legendGradient = legendSvg.append("defs")
                                .append("linearGradient")
                                .attr("id", "legendGradient")
                                .attr("x1", "0%")
                                .attr("x2", "0%")
                                .attr("y1", "100%")
                                .attr("y2", "0%");

                            // Add color stops at min, middle, and max
                            legendGradient.append("stop")
                                .attr("offset", "0%")
                                .attr("stop-color", '#00fefc'); // Color at min

                            legendGradient.append("stop")
                                .attr("offset", "50%")
                                .attr("stop-color", '#f7f7f7'); // Color at middle

                            legendGradient.append("stop")
                                .attr("offset", "100%")
                                .attr("stop-color", '#FF6700'); // Color at max

                            // Draw the vertical legend rectangle with the gradient
                            legendSvg.append("rect")
                                .attr("width", legendWidth)
                                .attr("height", legendHeight)
                                .style("fill", "url(#legendGradient)");

                            // Define scale for legend
                            const legendScale = d3.scaleLinear()
                                .domain([min, middle, max])
                                .range([legendHeight, legendHeight / 2, 0]);

                            // Add axis for the legend with min, middle, max labels
                            const legendAxis = d3.axisRight(legendScale)
                                .tickValues([min, middle, max]) // Only show min, middle, max
                                .tickFormat(d3.format(".0f")); // Format ticks as needed

                            // Append axis to the legend group
                            legendSvg.append("g")
                                .attr("class", "legend-axis")
                                .attr("transform", `translate(${legendWidth + 5}, 0)`)
                                .call(legendAxis);

                            // Set up legend dimensions for LogFC
                            const logFCLegendWidth = 10;
                            const logFCLegendHeight = 80; // Adjusted to match the heatmap height
                            const logFCLegendMargin = { top: 30, right: 0, bottom: 20, left: 80 };

                            // Position for the LogFC legend SVG group
                            const logFCLegendX = cellSize * colNumber + clusterSpace + logFCLegendMargin.left; // 120 to separate it from z-score legend
                            const logFCLegendY = logFCLegendMargin.top;

                            // Create the discrete legend for LogFC
                            const logFCLegendSvg = svg.append("g")
                                .attr("class", "logFC-legend")
                                .attr("transform", `translate(${logFCLegendX + 12}, ${logFCLegendY})`);

                            // Add a title for the LogFC legend
                            logFCLegendSvg.append("text")
                                .attr("x", logFCLegendWidth / 2)
                                .attr("y", -10) // Positioning above the rectangles
                                .attr("text-anchor", "middle")
                                .style("font-weight", "bold")
                                .text("LogFC");

                            // Divide the legend height equally for two colors
                            const legendFCHeight = logFCLegendHeight / 2;

                            // Rectangle for positive LogFC (pink) - placed on top
                            logFCLegendSvg.append("rect")
                                .attr("x", 0)
                                .attr("y", 0)  // Top position
                                .attr("width", logFCLegendWidth)
                                .attr("height", legendFCHeight)
                                .style("fill", "#C14A82");

                            // Label for positive LogFC ("Up")
                            logFCLegendSvg.append("text")
                                .attr("x", logFCLegendWidth + 5)  // Position text to the right of the rectangle
                                .attr("y", legendFCHeight / 2)
                                .attr("alignment-baseline", "middle")
                                .text("Up");

                            // Rectangle for negative LogFC (blue) - placed on bottom
                            logFCLegendSvg.append("rect")
                                .attr("x", 0)
                                .attr("y", legendFCHeight)  // Bottom position
                                .attr("width", logFCLegendWidth)
                                .attr("height", legendFCHeight)
                                .style("fill", "#1A74D5");

                            // Label for negative LogFC ("Down")
                            logFCLegendSvg.append("text")
                                .attr("x", logFCLegendWidth + 5)  // Position text to the right of the rectangle
                                .attr("y", legendFCHeight + legendFCHeight / 2)
                                .attr("alignment-baseline", "middle")
                                .text("Down");


                            if (selectedGeneData.length > 0) {
                                const indices = []
                                console.log("HEATMAP: selectedGeneData is greater than 0, updating cells")
                                console.log(selectedGeneData)
                                d3.selectAll(".cell")
                                    .filter(function () {
                                        return !d3.select(this).classed("selected") && !d3.select(this).classed("legend-cell"); // Select only cells that do NOT have the 'selected' class
                                    })
                                    .style("opacity", 0.2); // Set these cells to be semi-transparent or gray

                                selectedGeneData.forEach(name => {
                                    const index = rowLabel.indexOf(name); // Assuming rowLabel is an array of names
                                    if (index !== -1) {
                                        indices.push(index); // Add the index if found
                                    }
                                });
                                console.log(indices); // Log the collected indices

                                // Highlight the corresponding rows
                                indices.forEach(index => {
                                    var className = 'cr' + index; // Assuming 'cr' is the prefix for row classes
                                    d3.selectAll(`.${className}`).style("opacity", 1).classed("selected", true); // Make the cell visible

                                    // Highlight the row labels
                                    var labelClass = 'r' + index; // Assuming row labels have classes like 'r0', 'r1', etc.
                                    d3.selectAll(`.${labelClass}`).classed("text-highlight", true).classed("selected", true);
                                });

                                rTree.selectAll(".rnode").each(function (d) {
                                    // console.log(d); // Log the current data object for debugging

                                    // Check if the node has a valid name
                                    if (d.data.name && d.data.name.length > 0 && selectedGeneData.includes(d.data.name[0])) {

                                        d3.select(this).classed("selected", true)
                                        // Select the circle of the current node (using 'this' to refer to the current DOM element)
                                        // d3.select(this).select("circle")
                                        //     .style("stroke", function () {
                                        //         console.log(d.data.name[0])
                                        //         return (selectedGeneData.includes(d.data.name[0])) ? "red" : "none"; // Set stroke color based on condition
                                        //     })
                                        //     .attr("r", function () {
                                        //         return (selectedGeneData.includes(d.data.name[0])) ? 3.5 : 1.5; // Set radius based on condition
                                        //     });
                                    }
                                });
                            }
                            document.getElementById("loadingOverlay").style.display = "none";

                            resolve();

                        })
                        .catch(error => {
                            document.getElementById("loadingOverlay").style.display = "none";
                            alert("Error: " + error.message);
                            console.error("Error in fetch operation:", error);
                            reject(new Error("Error: " + error.message));  // Reject the promise if something fails
                        });
                }).fail(function (jqXHR, textStatus, errorThrown) {
                    document.getElementById("loadingOverlay").style.display = "none";
                    alert("Error calling heatmap: " + textStatus + " " + errorThrown);
                    console.error("Error in ocpu.call:", textStatus, errorThrown);
                    reject(new Error("Error: " + error.message));  // Reject the promise if something fails
                });
            });

        }

        function ppi_interactome() {
            console.log("Generating interactome")
            // Assuming data_copy_pval is an array of objects
            const genes = data_copy_pval
                .map(function (row) {
                    return row.gene;  // Map to an array of gene names
                });


            var req = ocpu.call("ppi_interactome?no_cache=1", {
                sig_degs: selectedGeneData
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";

                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => {
                        if (!response.ok) {
                            document.getElementById("loadingOverlay").style.display = "none";
                            throw new Error(`Error fetching data: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(session)
                        console.log(data);
                        generateNetworkGraph(data); // Call the function to generate the graph
                    })
                    .catch(error => {
                        document.getElementById("loadingOverlay").style.display = "none";
                        alert("Error: " + error.message);
                        console.error("Error in fetch operation:", error);
                    });
            }).fail(function (jqXHR, textStatus, errorThrown) {
                document.getElementById("loadingOverlay").style.display = "none";
                alert("Error calling heatmap: " + textStatus + " " + errorThrown);
                console.error("Error in ocpu.call:", textStatus, errorThrown);
            });


        }
        var network_data;

        function miRNA_target() {
            getInteractions.disabled = true

            document.getElementById("loadingOverlay").style.display = "block"
            console.log(selectedmiRNAs)
            console.log("Generating network")
            // Assuming data_copy_pval is an array of objects
            if (selectedGeneData.length > 0) {
                selectedmiRNAs = [...selectedGeneData];
                // Send data to server using fetch
                fetch('/queryTargets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ miRNA: selectedmiRNAs })
                })
                    .then(response => response.json())
                    .then(response => {
                        console.log(response)
                        network_data = response
                        generateNetworkGraph(response); // Call the function to generate the graph

                    })
                    .catch(error => {
                        console.error('Error:', error);
                        document.getElementById("loadingOverlay").style.display = "none"

                        alert('Failed to store enrichment data');
                    });

            }
        }

        document.querySelectorAll('input[name="strength"]').forEach(radio => {
            radio.addEventListener('change', (event) => {
                if ($.fn.DataTable.isDataTable('#metricsTable')) {
                    $('#metricsTable').DataTable().clear().destroy();
                    $('#metricsTable' + " tbody").empty();
                    $('#metricsTable' + " thead").empty();
                }
                if ($.fn.DataTable.isDataTable('#edgeListTable')) {
                    $('#edgeListTable').DataTable().clear().destroy();
                    $('#edgeListTable' + " tbody").empty();
                    $('#edgeListTable' + " thead").empty();
                }

                document.getElementById("loadingOverlay").style.display = "block"
                const selectedStrength = event.target.value;
                console.log(`Selected option: ${selectedStrength}`);
                generateNetworkGraph(network_data)
            });
        });

        // Event listener for dropdown menu
        document.getElementById("minInteractions").addEventListener('change', (event) => {
            if ($.fn.DataTable.isDataTable('#metricsTable')) {
                $('#metricsTable').DataTable().clear().destroy();
                $('#metricsTable' + " tbody").empty();
                $('#metricsTable' + " thead").empty();
            }
            if ($.fn.DataTable.isDataTable('#edgeListTable')) {
                $('#edgeListTable').DataTable().clear().destroy();
                $('#edgeListTable' + " tbody").empty();
                $('#edgeListTable' + " thead").empty();
            }

            document.getElementById("loadingOverlay").style.display = "block";
            console.log(`Minimum interactions set to: ${event.target.value}`);
            generateNetworkGraph(network_data);
        });

        let edgeListTable
        let metricsTable
        // Node selection functionality
        let selectedNodes
        let cy
        let selectedRowIds = new Set();  // Store selected row ID
        let edgeData
        function generateNetworkGraph(data_network) {
            d3.select("#networkSvgContainer").html("")
            selectedNodes = new Set()
            // Get the selected strength option
            const selectedStrength = document.querySelector('input[name="strength"]:checked');
            let data;
            if (selectedStrength) {
                if (selectedStrength.value === "strong_weak") {
                    data = data_network;
                } else if (selectedStrength.value === "strong") {
                    data = {
                        targets: data_network.targets.filter(target => !target.experiments.includes("CLIP"))
                    };
                } else if (selectedStrength.value === "weak") {
                    data = {
                        targets: data_network.targets.filter(target => target.experiments.includes("CLIP"))
                    };
                }
            }

            // Clear loading overlay
            document.getElementById("loadingOverlay").style.display = "none";

            // Prepare nodes and edges for Cytoscape
            const nodes = {};
            const edges = [];

            // Set to track unique edges
            const edgeSet = new Set();

            // Process nodes and links from data
            data.targets.forEach(target => {
                const { source_miRNA, target_gene } = target;

                // Add nodes if they don't already exist and initialize their edges array
                if (!nodes[source_miRNA]) nodes[source_miRNA] = { id: source_miRNA, edges: [] };
                if (!nodes[target_gene]) nodes[target_gene] = { id: target_gene, edges: [] };

                // Create a unique identifier for this edge using the source and target
                const edgeKey = `${source_miRNA}-${target_gene}`;

                // Only add the edge if it hasnt been added before
                if (!edgeSet.has(edgeKey)) {
                    edgeSet.add(edgeKey);

                    // Create the edge object
                    const edge = {
                        data: { source: source_miRNA, target: target_gene }
                    };

                    // Add edge to the main edges array
                    edges.push(edge);

                    // Add this edge to the edges array of both source and target nodes
                    nodes[source_miRNA].edges.push(edge);
                    nodes[target_gene].edges.push(edge);
                }
            });

            // Calculate the degree for each node based on the number of edges
            Object.values(nodes).forEach(node => {
                node.degree = node.edges.length;
            });

            // Filter nodes based on degree (example with minInteractions)
            const minInteractions = parseInt(document.getElementById("minInteractions").value);
            // Map filtered nodes and add a class based on logFC value
            const filteredNodes = Object.values(nodes)
                .filter(node => node.degree >= minInteractions)
                .map(node => {
                    const logFC = parsedLogFC.find(row => row.Gene === node.id)?.logFC || 0; // Default to 0 if not found
                    const className = logFC > 0 ? 'upregulated' : (logFC < 0 ? 'downregulated' : 'neutral');
                    return { data: { id: node.id, logFC: logFC }, classes: className };
                });

            console.log(filteredNodes);

            // Filter edges to include only those whose source and target are in filteredNodes
            const filteredNodeIds = new Set(filteredNodes.map(node => node.data.id));
            const filteredEdges = edges.filter(edge =>
                filteredNodeIds.has(edge.data.source) && filteredNodeIds.has(edge.data.target)
            );

            // Initialize Cytoscape with filtered nodes and edges
            cy = cytoscape({
                container: document.getElementById("networkSvgContainer"),
                elements: {
                    nodes: filteredNodes,
                    edges: filteredEdges
                },
                style: [
                    {
                        selector: 'node.upregulated',
                        style: {
                            'background-color': '#C14A82', // Color for upregulated nodes
                            'width': '20px',
                            'height': '20px',
                            'border-width': 3,
                            'border-color': '#703b54'
                        }
                    },
                    {
                        selector: 'node.downregulated',
                        style: {
                            'background-color': '#1A74D5', // Color for downregulated nodes
                            'width': '20px',
                            'height': '20px',
                            'border-width': 3,
                            'border-color': '#264b72'
                        }
                    },
                    {
                        selector: 'node.neutral',
                        style: {
                            'background-color': 'lightgray', // Default color for neutral nodes (logFC = 0)
                            'width': '10px',
                            'height': '10px',
                            'border-width': 1,
                            'border-color': 'black'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'line-color': 'var(--text-color)',
                            'width': 0.3,
                            'opacity': 1
                        }
                    },
                ],
                layout: {
                    name: 'cose',
                    padding: 5
                }
            });


            // Apply the 'selected' class to nodes in selectedGeneData
            selectedGeneData.forEach(geneId => {
                const node = cy.getElementById(geneId);
                if (node) {
                    node.addClass('selected');
                }
            });


            // Tooltip functionality
            cy.on('mouseover', 'node', function (evt) {
                const node = evt.target;
                const tooltip = document.createElement('div');

                tooltip.id = 'cyTooltip';
                tooltip.innerHTML = `Node: ${node.id()}<br>Degree: ${node.degree()}`;
                tooltip.style.position = 'absolute';
                tooltip.style.padding = '6px';
                tooltip.style.backgroundColor = 'white';
                tooltip.style.borderRadius = '4px';
                tooltip.style.pointerEvents = 'none'; // Ensures the tooltip doesn't interfere with mouse events

                // Get Cytoscape container position
                const cyContainer = document.getElementById("networkSvgContainer");
                const rect = cyContainer.getBoundingClientRect();

                tooltip.style.left = (rect.left + evt.renderedPosition.x + 15) > 2240 ? `${rect.left + evt.renderedPosition.x - 30}px` : `${rect.left + evt.renderedPosition.x + 15}px`;
                tooltip.style.top = `${rect.top + evt.renderedPosition.y + 15}px`;

                // Update tooltip position on mousemove
                cy.on('mousemove', function (evt) {
                    tooltip.style.left = (rect.left + evt.renderedPosition.x + 15) > 2240 ? `${rect.left + evt.renderedPosition.x - 30}px` : `${rect.left + evt.renderedPosition.x + 15}px`;
                    tooltip.style.top = `${rect.top + evt.renderedPosition.y + 15}px`;
                });
                // Append the tooltip to the body
                document.body.appendChild(tooltip);

                // Remove tooltip when mouse leaves node
                cy.on('mouseout', 'node', function () {
                    tooltip.remove();
                    cy.removeListener('mousemove');
                });
            });

            cy.on('mouseout', 'node', function () {
                const tooltip = document.getElementById('cyTooltip');
                if (tooltip) tooltip.remove();
            });

            cy.on('mouseout', function () {
                const tooltip = document.getElementById('cyTooltip');
                if (tooltip) tooltip.remove();
            });

            cy.on('tap', 'node', function (evt) {
                const node = evt.target;

                // Function to check if a node should remain selected based on its connections
                function shouldKeepNodeInSelection(n) {
                    // Check if the node is connected to any selected node
                    return Array.from(selectedNodes).some(selectedNode => {
                        try {
                            return n.connectedTo(selectedNode); // If the node is connected to any selected node, keep it in the selection
                        } catch (error) {
                            return true
                        }
                    });
                }

                // If no node is selected, dim all nodes and edges
                if (selectedNodes.size === 0) {
                    cy.nodes().style('opacity', 0.2); // Dim all nodes
                    cy.edges().style('opacity', 0.2); // Dim all edges
                }

                // If node is not selected and no Ctrl key is pressed, select the node
                if (!selectedNodes.has(node) && !evt.originalEvent.ctrlKey) {
                    cy.nodes().style('opacity', 0.2); // Dim all nodes
                    cy.edges().style('opacity', 0.2); // Dim all edges

                    node.style('opacity', 1); // Highlight selected node
                    selectedNodes.clear(); // Clear previous selections
                    selectedNodes.add(node); // Add the selected node

                    const connectedEdges = node.connectedEdges();
                    connectedEdges.style('opacity', 1);
                    connectedEdges.connectedNodes().style('opacity', 1);

                    // Add connected nodes to the selection
                    connectedEdges.connectedNodes().forEach(n => selectedNodes.add(n));
                }
                // If the node is not selected and the Ctrl key is pressed, add the node to selection
                else if (!selectedNodes.has(node) && evt.originalEvent.ctrlKey) {
                    node.style('opacity', 1); // Highlight selected node
                    selectedNodes.add(node); // Add the node to selection

                    const connectedEdges = node.connectedEdges();
                    connectedEdges.style('opacity', 1);
                    connectedEdges.connectedNodes().style('opacity', 1);

                    // Add connected nodes to the selection
                    connectedEdges.connectedNodes().forEach(n => selectedNodes.add(n));
                }
                // If node is selected and the Ctrl key is pressed, toggle the node selection
                else if (selectedNodes.has(node) && evt.originalEvent.ctrlKey) {
                    node.style('opacity', 0.2); // Dim the node
                    selectedNodes.delete(node); // Remove the node from selection

                    const connectedEdges = node.connectedEdges();
                    connectedEdges.style('opacity', 0.2);

                    // Dim connected nodes only if they are not connected to another selected node
                    connectedEdges.connectedNodes().forEach(n => {
                        if (!shouldKeepNodeInSelection(n)) {
                            n.style('opacity', 0.2); // Dim the connected node if it should be removed
                            selectedNodes.delete(n); // Remove it from selection
                        }
                    });
                }
                // If no node is selected or Ctrl key is not pressed, reset selection
                else {
                    cy.nodes().style('opacity', 1); // Reset all nodes
                    cy.edges().style('opacity', 1); // Reset all edges
                    selectedNodes.clear(); // Clear the selected nodes
                }


                // Now highlight the checkboxes in the edgeListTable based on selectedNodes
                $('#edgeListTable tbody tr').each(function () {
                    const rowData = edgeListTable.row(this).data();
                    // const sourceNodeId = rowData[1];  // Assuming the first column is the miRNA (source)
                    // const targetNodeId = rowData[2];  // Assuming the second column is the target
                    console.log(rowData)
                    // Find the checkbox in the current row
                    const checkbox = $(this).find('input[type="checkbox"]');
                    console.log(checkbox)

                    const sourceNodeId = $(this).find('input[type="checkbox"]').data('mirna');  // miRNA (source) node ID
                    const targetNodeId = $(this).find('input[type="checkbox"]').data('target');  // Target (target) node ID
                    console.log(sourceNodeId)
                    console.log(targetNodeId)

                    // Highlight or unhighlight checkboxes based on selectedNodes set
                    if (selectedNodes.has(cy.getElementById(sourceNodeId))) {
                        checkbox.prop('checked', false).closest('.pretty').addClass('netHighlighted'); // Highlight the checkbox
                    } else {
                        checkbox.prop('checked', false).closest('.pretty').removeClass('netHighlighted'); // Remove highlight from checkbox
                    }
                });

                edgeData.forEach(item => {
                    item.isHighlighted = selectedNodes.has(cy.getElementById(item.miRNA)) && selectedNodes.has(cy.getElementById(item.target));
                    console.log(item)
                });

                // Invalidate rows to refresh only the updated data
                edgeListTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                    const rowData = this.data();
                    rowData.isHighlighted = selectedNodes.has(cy.getElementById(rowData.miRNA)) && selectedNodes.has(cy.getElementById(rowData.target));
                    this.invalidate(); // Mark the row as needing a redraw
                });

                edgeListTable.draw(false);


            });

            // Listen for a tap event on the entire graph (not just nodes)
            cy.on('tap', function (evt) {
                // Check if the tap happened outside of a node
                if (evt.target === cy) {
                    cy.nodes().style('opacity', 1); // Reset all nodes' opacity
                    cy.edges().style('opacity', 1); // Reset all edges' opacity
                    selectedNodes.clear(); // Clear the selected nodes
                }

                // Now highlight the corresponding rows in the DataTable for each node in selectedNodes
                $('#metricsTable tbody tr').each(function () {
                    const rowData = metricsTable.row(this).data();
                    const nodeId = rowData[0];  // Assuming the first column is the node ID

                    // Highlight or unhighlight rows based on selectedNodes set
                    if (selectedNodes.has(cy.getElementById(nodeId))) {
                        $(this).addClass('selected');  // Add a class for the highlighted row
                    } else {
                        $(this).removeClass('selected');  // Remove the highlight class if the row is no longer selected
                    }
                });

                edgeData.forEach(item => {
                    item.isHighlighted = selectedNodes.has(cy.getElementById(item.miRNA)) && selectedNodes.has(cy.getElementById(item.target));
                    console.log(item)
                });

                // Invalidate rows to refresh only the updated data
                edgeListTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                    const rowData = this.data();
                    rowData.isHighlighted = selectedNodes.has(cy.getElementById(rowData.miRNA)) && selectedNodes.has(cy.getElementById(rowData.target));
                    this.invalidate(); // Mark the row as needing a redraw
                });

                edgeListTable.draw(false);


                // $('#edgeListTable tbody tr').each(function () {
                //     const rowData = edgeListTable.row(this).data();

                //     // Ensure that rowData is not undefined
                //     if (!rowData) return;  // Skip this row if there's no data


                //     const sourceNodeId = rowData[0];  // Assuming the first column is the miRNA (source)
                //     const targetNodeId = rowData[1];  // Assuming the second column is the target

                //     // Highlight or unhighlight rows based on selectedNodes set
                //     if (selectedNodes.has(cy.getElementById(sourceNodeId)) && selectedNodes.has(cy.getElementById(targetNodeId))) {
                //         $(this).addClass('selected');  // Add a class for the highlighted row
                //         selectedRowIds.add(this);  // Add row to selected set
                //     } else {
                //         $(this).removeClass('selected');  // Remove the highlight class if the row is no longer selected
                //         selectedRowIds.delete(this);  // Remove row from selected set
                //     }

                //     // Loop through each column in the row (including hidden ones)
                //     $(this).find('td').each(function (index) {
                //         const cellData = rowData[index];  // Get the data for the specific column

                //         // If needed, you can highlight each cell as well
                //         if (selectedNodes.has(cy.getElementById(sourceNodeId)) && selectedNodes.has(cy.getElementById(targetNodeId))) {
                //             $(this).addClass('selected');  // Highlight the entire cell
                //         } else {
                //             $(this).removeClass('selected');  // Remove highlight from the cell
                //         }
                //     });
                // });


            });


            // Ensure the graph is initialized
            cy.ready(() => {
                const closenessResult = cy.elements().closenessCentralityNormalized();  // Compute for all elements in the graph
                const betwennessResult = cy.elements().betweennessCentrality();  // Compute for all elements in the graph
                // Calculate metrics for each node
                Object.values(nodes).forEach(node => {
                    const cyNode = cy.getElementById(node.id);  // Use `cy.getElementById` to get the Cytoscape node

                    if (cyNode) {
                        // Degree
                        node.degree = cyNode.degree();

                        // Closeness Centrality
                        try {
                            node.closeness = closenessResult.closeness(cyNode);  // Get the closeness of the specific node
                        } catch (error) {
                            node.closeness = 0;  // Set a default value if an error occurs
                        }

                        // Betweenness Centrality
                        try {
                            node.betweenness = betwennessResult.betweennessNormalized(cyNode);
                        } catch (error) {
                            node.betweenness = 0;  // Set a default value if an error occurs
                        }

                        // Eccentricity Calculation
                        try {
                            // Run Dijkstras algorithm from the current node
                            const dijkstra = cy.elements().dijkstra({ root: cyNode });

                            // Get the maximum distance to all other nodes
                            const maxDistance = cy.nodes().map(otherNode => {
                                const distance = dijkstra.distanceTo(otherNode);
                                return distance;
                            }).reduce((max, current) => {
                                return (current === Infinity || current === undefined) ? max : Math.max(max, current);
                            }, 0);  // Find the maximum distance, excluding Infinity

                            node.eccentricity = maxDistance || 0;  // If no distance, default to 0
                        } catch (error) {
                            node.eccentricity = 0;  // Set a default value if an error occurs
                        }


                        // Average Shortest Path Length
                        try {
                            const dijkstra = cy.elements().dijkstra({ root: cyNode });  // Run Dijkstra from the current node
                            let totalDistance = 0;
                            let reachableNodes = 0;

                            // Sum the distances to all other nodes
                            cy.nodes().forEach(otherNode => {
                                const distance = dijkstra.distanceTo(otherNode);
                                if (distance !== Infinity && distance !== undefined) {
                                    totalDistance += distance;
                                    reachableNodes++;
                                }
                            });

                            // Calculate the average shortest path length
                            if (reachableNodes > 0) {
                                node.averageShortestPathLength = totalDistance / reachableNodes;
                            } else {
                                node.averageShortestPathLength = 0;  // If no reachable nodes, set to 0
                            }
                        } catch (error) {
                            node.averageShortestPathLength = 0;  // Set a default value if an error occurs
                        }
                    }
                });

                // Initialize DataTable
                if ($.fn.DataTable.isDataTable('#metricsTable')) {
                    $('#metricsTable').DataTable().clear().destroy();
                    $('#metricsTable' + " tbody").empty();
                    $('#metricsTable' + " thead").empty();
                }


                metricsTable = $('#metricsTable').DataTable({
                    destroy: true,
                    columns: [
                        { title: "Name" },
                        { title: "Degree" },
                        { title: "Closeness" },
                        { title: "Betweenness Centrality" },
                        { title: "Eccentricity" },
                        { title: "Average Shortest Path Length" }
                    ]
                });

                console.log(nodes)

                // Populate DataTable
                Object.values(nodes).forEach(node => {
                    if (filteredNodeIds.has(node.id)) {
                        metricsTable.row.add([
                            node.id,
                            node.degree || 0,
                            node.closeness.toExponential(2) || 0,
                            node.betweenness.toExponential(2) || 0,
                            node.eccentricity.toExponential(2) || 0,
                            node.averageShortestPathLength.toExponential(2) || 0
                        ]);
                    }
                });

                metricsTable.draw(); // Refresh DataTable

            });
            document.getElementById("layoutSelector").addEventListener("change", function () {
                const selectedLayout = this.value;

                // Define layout options
                const layoutOptions = {
                    name: selectedLayout,
                    // Adjust spacing for circle layout
                    ...(selectedLayout === 'circle' && {
                        radius: 20, // Radius of the circle (smaller value brings nodes closer together)
                        spacingFactor: 0.8 // Factor to reduce default spacing between nodes (0.8 = 80% of default)
                    }),
                    // Adjust spacing for other layouts if needed
                    // e.g., for grid layout
                    ...(selectedLayout === 'grid' && {
                        avoidOverlap: true, // Avoid overlap of nodes
                        spacingFactor: 0.8 // Reduce spacing between nodes
                    }),
                };

                // Apply new layout with adjusted options
                cy.layout(layoutOptions).run();
            });
            // Add event listener to DataTable for row selection
            $('#metricsTable tbody').on('click', 'tr', function () {
                const rowData = metricsTable.row(this).data();
                const nodeId = rowData[0];  // Assuming the first column is the node ID

                // Clear previous selections
                // cy.nodes().removeClass('selected');

                // Highlight selected node in Cytoscape
                const node = cy.getElementById(nodeId);
                if (node) {
                    console.log(node)
                    // node.addClass('selected');  // Add the 'selected' class to apply highlight styling
                    // cy.fit(node, 50);  // Optional: Center the view on the selected node with a 50px margin
                }
            });

            // Initialize DataTable for edge list (miRNA-target interactions)
            if ($.fn.DataTable.isDataTable('#edgeListTable')) {
                $('#edgeListTable').DataTable().clear().destroy();
                $('#edgeListTable' + " tbody").empty();
                $('#edgeListTable' + " thead").empty();
            }

            // Store selected rows for later reapplication
            selectedRowIds.clear()

            // Function to highlight rows based on selected nodes in edgeListTable
            function highlightRows() {
                if ($.fn.DataTable.isDataTable('#edgeListTable') && document.getElementById("edgeListTableTab").style.display != "none") {

                    // Iterate over each row in the table
                    $('#edgeListTable tbody tr').each(function () {
                        const rowData = edgeListTable.row(this).data();
                        console.log(rowData);
                        // Ensure rowData is valid
                        if (!rowData) return;  // Skip this row if no data

                        const sourceNodeId = rowData[0];  // Assuming first column is the miRNA (source)
                        const targetNodeId = rowData[1];  // Assuming second column is the target

                        // Find the checkbox in the current row
                        const checkbox = $(this).find('input[type="checkbox"]');

                        // Check if both source and target nodes are selected
                        if (selectedNodes.has(cy.getElementById(sourceNodeId)) && selectedNodes.has(cy.getElementById(targetNodeId))) {
                            console.log(`Highlighting row with source: ${sourceNodeId} and target: ${targetNodeId}`);

                            // Highlight the checkbox
                            checkbox.prop('checked', false).closest('.pretty').addClass('netHighlighted'); // Add custom class to the checkbox for styling
                        } else {
                            // Remove highlight from checkbox if not selected
                            checkbox.prop('checked', false).closest('.pretty').removeClass('netHighlighted'); // Remove custom class
                        }
                    });
                }
            }

            $.fn.dataTable.ext.order['dom-highlighted'] = function (settings, col) {
                return settings.aoData.map(function (row) {
                    // Access the raw data for the row
                    const rowData = row._aData;
                    return rowData.isHighlighted ? 1 : 0; // Use isHighlighted to determine order
                });
            };

            // Populate edgeData with miRNA-target interactions
            edgeData = filteredEdges.map(edge => {
                const sourceNode = cy.getElementById(edge.data.source);  // Get source node (miRNA)
                const targetNode = cy.getElementById(edge.data.target);  // Get target node (miRNA target)

                return {
                    miRNA: sourceNode.id(),  // miRNA (source)
                    target: targetNode.id(), // Target (target)
                    isHighlighted: selectedNodes.has(sourceNode) && selectedNodes.has(targetNode) // Check if both nodes are highlighted
                };
            });


            // Initialize DataTable with checkbox functionality
            edgeListTable = $('#edgeListTable').DataTable({
                destroy: true,
                data: edgeData,
                columns: [
                    {
                        title: "Select", // Checkbox column title
                        data: null, // No specific data field for checkbox
                        render: function (data, type, row) {
                            // Create the Pretty Checkbox HTML
                            return `
                    <div class="pretty p-default p-curve p-fill ${row.isHighlighted ? 'netHighlighted' : ''}">
                        <input type="checkbox" data-miRNA="${row.miRNA}" data-target="${row.target}" />
                        <div class="state">
                            <label></label>
                        </div>
                    </div>
                `;
                        },
                        orderable: true, // Disable ordering for this column
                        searchable: false, // Exclude from search functionality
                        createdCell: function (td, cellData, rowData, row, col) {
                            // No need for additional sorting logic here since we use isHighlighted directly
                        },
                        orderDataType: 'dom-highlighted' // Assign custom sorting type
                    },
                    { title: "miRNA", data: "miRNA" },  // Column for miRNA data
                    { title: "Target", data: "target" }  // Column for Target data
                ],
                order: [[0, 'desc']] // Initial ordering based on the "Selected" column
            });

            // Refresh DataTable
            edgeListTable.draw();

            // // Reapply selection on DataTable events (page change, sorting, filtering, etc.)
            // $('#edgeListTable').on('page.dt', function () {
            //     highlightRows();
            // });

            // // Reapply selection after page change, sorting, filtering, or search with a delay
            // $('#edgeListTable').on('search.dt', function () {
            //     // Use a small timeout to allow the search/sort/page to complete
            //     setTimeout(function () {
            //         highlightRows();  // Reapply highlighting after the table is done processing
            //     }, 100);  // Adjust delay time if necessary
            // });

            // Function to highlight rows based on selected nodes
            function highlightEdgeRows() {
                if ($.fn.DataTable.isDataTable('#metricsTable') && document.getElementById("metricsTable").style.display != "none") {

                    $('#metricsTable tbody tr').each(function () {
                        const rowData = metricsTable.row(this).data();
                        const nodeId = rowData[0];  // Assuming the first column is the node ID

                        // Highlight or unhighlight rows based on selectedNodes set
                        if (selectedNodes.has(cy.getElementById(nodeId))) {
                            $(this).addClass('selected');  // Add a class for the highlighted row
                        } else {
                            $(this).removeClass('selected');  // Remove the highlight class if the row is no longer selected
                        }
                    });
                }
            }


            // Reapply selection on DataTable events (page change, sorting, filtering, etc.)
            $('#metricsTable').on('page.dt', function () {
                highlightEdgeRows();
            });

            // Reapply selection after page change, sorting, filtering, or search with a delay
            $('#metricsTable').on('search.dt', function () {
                // Use a small timeout to allow the search/sort/page to complete
                setTimeout(function () {
                    highlightEdgeRows();  // Reapply highlighting after the table is done processing
                }, 100);  // Adjust delay time if necessary
            });

            // Remove any existing click handlers
            $('#edgeListTable tbody').off('change', 'input[type="checkbox"]');

            // Function to trigger selection of node in Cytoscape based on selected edge row
            $('#edgeListTable tbody').on('change', 'input[type="checkbox"]', function () {

                // Function to check if a node should remain selected based on its connections
                function shouldKeepNodeInSelection(n) {
                    console.log("Checking node:", n.id());
                    // Check if the node is connected to any selected node
                    return Array.from(selectedNodes).some(selectedNode => {
                        const connectedEdges = n.edgesWith(selectedNode);
                        return connectedEdges.length > 0; // If there's an edge, keep it in selection
                    });
                }

                console.log($(this))

                const sourceNodeId = $(this).data('mirna');  // miRNA (source) node ID
                const targetNodeId = $(this).data('target');  // Target (target) node ID

                // Find the corresponding target node in Cytoscape
                const targetNode = cy.getElementById(targetNodeId);
                const sourceNode = cy.getElementById(sourceNodeId);

                console.log(sourceNodeId)
                console.log(targetNodeId)
                // If no node is selected, dim all nodes and edges
                if (selectedNodes.size === 0) {
                    console.log("selectedNodes size is 0")
                    cy.nodes().style('opacity', 0.2); // Dim all nodes
                    cy.edges().style('opacity', 0.2); // Dim all edges
                }

                // Simulate Ctrl+Click behavior: if the node is already selected, deselect it, otherwise select it
                if (selectedNodes.has(targetNode)) {
                    targetNode.style('opacity', 0.2);  // Dim the node
                    selectedNodes.delete(targetNode);  // Remove from selectedNodes set

                    // Dim connected edges and nodes if necessary
                    targetNode.connectedEdges().style('opacity', 0.2);

                    // Dim connected nodes only if they are not connected to another selected node
                    targetNode.connectedEdges().connectedNodes().forEach(n => {
                        if (!shouldKeepNodeInSelection(n)) {
                            console.log(n.id() + " is inside selected nodes")
                            n.style('opacity', 0.2); // Dim the connected node if it should be removed
                            selectedNodes.delete(n); // Remove it from selection
                        } else {
                            console.log(n + " is inside selected nodes")
                        }
                    });

                } else {
                    targetNode.style('opacity', 1);  // Highlight the selected node
                    selectedNodes.add(targetNode);  // Add to selectedNodes set

                    // Highlight connected edges and nodes
                    const connectedEdges = targetNode.connectedEdges();
                    connectedEdges.style('opacity', 1);
                    connectedEdges.connectedNodes().style('opacity', 1);

                    // Add connected nodes to the selection
                    connectedEdges.connectedNodes().forEach(n => selectedNodes.add(n));
                }

                // Update DataTable row selection based on Cytoscape node selection
                $('#edgeListTable tbody tr').each(function () {
                    const rowData = edgeListTable.row(this).data();
                    const sourceNodeId = rowData.miRNA;
                    const targetNodeId = rowData.target;
                    const checkbox = $(this).find('input[type="checkbox"]');
                    console.log(sourceNodeId)
                    console.log(targetNodeId)
                    console.log(checkbox)
                    console.log(selectedNodes.has(cy.getElementById(sourceNodeId)))
                    console.log(selectedNodes.has(cy.getElementById(targetNodeId)))
                    rowData.isHighlighted = selectedNodes.has(cy.getElementById(sourceNodeId)) && selectedNodes.has(cy.getElementById(targetNodeId));

                    // Highlight or unhighlight rows based on selectedNodes set
                    if (selectedNodes.has(cy.getElementById(sourceNodeId)) && selectedNodes.has(cy.getElementById(targetNodeId))) {
                        checkbox.prop('checked', false).closest('.pretty').addClass('netHighlighted'); // Add custom class for styling
                    } else {
                        checkbox.prop('checked', false).closest('.pretty').removeClass('netHighlighted'); // Add custom class for styling
                    }
                });

                // If no node is selected, dim all nodes and edges
                if (selectedNodes.size === 0) {
                    cy.nodes().style('opacity', 1); // Dim all nodes
                    cy.edges().style('opacity', 1); // Dim all edges
                }

                edgeData.forEach(item => {
                    item.isHighlighted = selectedNodes.has(cy.getElementById(item.miRNA)) && selectedNodes.has(cy.getElementById(item.target));
                    console.log(item)
                });

                // Invalidate rows to refresh only the updated data
                edgeListTable.rows().every(function (rowIdx, tableLoop, rowLoop) {
                    const rowData = this.data();
                    rowData.isHighlighted = selectedNodes.has(cy.getElementById(rowData.miRNA)) && selectedNodes.has(cy.getElementById(rowData.target));
                    this.invalidate(); // Mark the row as needing a redraw
                });

                edgeListTable.draw(false);

                //     // Iterate over all rows in the up-regulated table
                //     $('#edgeListTable tbody tr').each(function () {
                //         const rowData = edgeListTable.row(this).data();
                //         if (rowData !== undefined) {
                //             const gene = rowData.Gene;

                //             // Update the isHighlighted property in rowData
                //             rowData.isHighlighted = selectedGeneData.includes(gene);


                //             // Check if the gene is in the selectedGeneData array
                //             const checkbox = $(this).find('input[type="checkbox"]');
                //             if (selectedGeneData.includes(gene)) {
                //                 checkbox.prop('checked', false).closest('.pretty').addClass('netHighlighted'); // Add custom class for styling
                //             } else {
                //                 checkbox.prop('checked', false).closest('.pretty').removeClass('netHighlighted'); // Add custom class for styling
                //             }
                //         }
                //     });
            });


        }

        function runFunctionalAnalysis() {
            console.log(selectedNodes)
            // Get the selected data based on the strength (this will be your data network)
            const selectedStrength = document.querySelector('input[name="strength"]:checked');
            let data;
            if (selectedStrength) {
                if (selectedStrength.value === "strong_weak") {
                    data = network_data;
                } else if (selectedStrength.value === "strong") {
                    data = {
                        targets: network_data.targets.filter(target => !target.experiments.includes("CLIP"))
                    };
                } else if (selectedStrength.value === "weak") {
                    data = {
                        targets: network_data.targets.filter(target => target.experiments.includes("CLIP"))
                    };
                }
            }

            console.log(data)

            const miRNA_targets = {};

            // Process each target and map miRNAs to their target genes
            data.targets.forEach(target => {
                const miRNA = target.source_miRNA;
                const gene = target.target_gene;

                // Initialize the list for the miRNA if it doesn't exist
                if (!miRNA_targets[miRNA]) {
                    miRNA_targets[miRNA] = [];
                }

                // Add the target gene if it's not already in the list for that miRNA
                if (!miRNA_targets[miRNA].includes(gene)) {
                    miRNA_targets[miRNA].push(gene);
                }
            });

            console.log(miRNA_targets);

            // Filtered miRNA_targets based on selectedNodes
            let filteredMiRNA_targets = {};

            if (selectedNodes.size === 0) {
                filteredMiRNA_targets = miRNA_targets
            } else {
                selectedNodes.forEach(node => {
                    const nodeId = node.id();

                    // Check if the node ID corresponds to a miRNA in miRNA_targets
                    if (miRNA_targets[nodeId]) {
                        // Filter the gene list to include only those in selectedNodes
                        filteredMiRNA_targets[nodeId] = miRNA_targets[nodeId].filter(gene =>
                            Array.from(selectedNodes).some(selectedNode => selectedNode.id() === gene)
                        );
                    }
                });

            }

            console.log(filteredMiRNA_targets);

            // Clear loading overlay
            document.getElementById("loadingOverlay").style.display = "none";

            // Send data to OpenCPU for functional analysis
            var req = ocpu.call("functional_analysis", {
                miRNA_targets: filteredMiRNA_targets // Ensure you're sending the targets or relevant data
            }, function (session) {
                // Session ID received from OpenCPU
                var filteredDataURL = session.loc + "/R/.val/json"; // URL to get results
                console.log(session)
                // Fetch the results from R
                fetch(filteredDataURL)
                    .then(response => response.json())
                    .then(data => {
                        console.log(data); // Data returned from R, ready for plotting with D3.js
                        document.getElementById("functionalAnalysisOverlay").style.display = "block";

                        // Proceed with plotting the data using D3.js here
                        plotFunctionalAnalysisData(data);
                    })
                    .catch(error => {
                        console.error('Error fetching functional analysis data:', error);
                    });
            });
        }

        function plotFunctionalAnalysisData(pathwaysData) {
            console.log(pathwaysData);

            // Parse FDR as a float
            pathwaysData.forEach(d => {
                d.FDR = parseFloat(d.FDR);
            });

            // Set up margins and dimensions for the SVG container
            const margin = { top: 80, right: 110, bottom: 120, left: 150 };
            const width = 1000 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            // Create the SVG container with viewBox and preserveAspectRatio
            const svg = d3.select("#functionalAnalysisSvgContainer")
                .html("")
                .append("svg")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr("preserveAspectRatio", "xMidYMid meet")
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            // Set up scales for the axes
            const xScale = d3.scaleBand()
                .domain(pathwaysData.map(d => d.microRNA))
                .range([0, width])
                .padding(0.1);

            const yScale = d3.scaleBand()
                .domain(pathwaysData.map(d => d.Description))
                .range([0, height])
                .padding(0.1);

            // Diverging color scale
            const colorScale = d3.scaleLinear()
                .domain([d3.min(pathwaysData, d => (d.FDR)), d3.max(pathwaysData, d => (d.FDR))])
                .range([d3.interpolateRgb('#193833', '#82F0F5')(1), d3.interpolateRgb('#193833', '#82F0F5')(0)]);

            // Calculate Counts based on the length of Genes field and set size scale
            pathwaysData.forEach(d => {
                d.Count = d.Genes.split("/").length;  // Calculate Count dynamically
            });

            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(pathwaysData, d => d.Count)])
                .range([3, 15]);

            // Add x-axis
            svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll("text")
                .style("font-size", "12px")
                .attr("text-anchor", "end")
                .attr("transform", "rotate(-45)")
                .attr("dx", "-0.5em")
                .attr("dy", "0.5em");

            // Add y-axis
            svg.append("g")
                .call(d3.axisLeft(yScale))
                .selectAll("text")
                .style("font-size", "12px");

            // Tooltip element
            const tooltip = d3.select("body").append("div")
                .attr("class", "fatooltip")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("background-color", "white")
                .style("border", "1px solid #ddd")
                .style("padding", "10px")
                .style("border-radius", "4px")
                .style("box-shadow", "2px 2px 5px rgba(0, 0, 0, 0.2)")
                .style("z-index", "1000");  // Ensure it's on top

            // Add dots to the plot
            svg.selectAll(".dot")
                .data(pathwaysData)
                .enter()
                .append("circle")
                .attr("cx", d => xScale(d.microRNA) + xScale.bandwidth() / 2)
                .attr("cy", d => yScale(d.Description) + yScale.bandwidth() / 2)
                .attr("r", d => sizeScale(d.Count))
                .style("fill", d => colorScale(d.FDR))
                .style("stroke", "black")
                .style("stroke-width", 1)
                .on("mouseover", function (d) {
                    tooltip.transition().duration(200).style("visibility", "visible");
                    tooltip.html(`
                                    <strong>miRNA Family:</strong> ${d.microRNA}<br>
                                    <strong>Pathway:</strong> ${d.Description}<br>
                                    <strong>FDR:</strong> ${d.FDR.toExponential(2)}<br>
                                    <strong>Genes:</strong> ${d.Gene_symbol}<br>
                                    <strong>Count:</strong> ${d.Count}
                                `)
                        .style("top", (d3.event.pageY + 5) + "px")
                        .style("left", (d3.event.pageX + 5) + "px");
                })
                .on("mouseout", function () {
                    tooltip.transition().duration(200).style("visibility", "hidden");
                });

            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -10)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .text("Top miRNA Target Pathways");

            // Add x-axis label
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text("miRNA Family (Number of Targets)");

            // Add color scale legend (linear gradient)
            const legend = svg.append("g")
                .attr("transform", `translate(${width + 20}, 10)`);

            const legendHeight = 100;
            const legendWidth = 20;

            // Create a gradient for the legend
            const gradient = legend.append("defs")
                .append("linearGradient")
                .attr("id", "gradient")
                .attr("x1", "0%")
                .attr("y1", "0%")
                .attr("x2", "0%")
                .attr("y2", "100%")
                .selectAll("stop")
                .data([d3.min(pathwaysData, d => d.FDR), d3.max(pathwaysData, d => d.FDR)])  // Only use the min and max values for the gradient
                .enter().append("stop")
                .attr("offset", function (d, i) { return `${(i) * 100}%`; })  // Two stops, at 0% and 100%
                .attr("stop-color", d => colorScale(d));

            // Add the gradient to the legend
            legend.append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#gradient)");

            // Add legend labels
            legend.selectAll(".legend-text")
                .data([d3.min(pathwaysData, d => d.FDR), d3.max(pathwaysData, d => d.FDR)])  // Only add labels for min and max
                .enter()
                .append("text")
                .attr("x", legendWidth + 5)
                .attr("y", (d, i) => i * (legendHeight / 1))  // Positioning them at the two ends
                .attr("dy", ".35em")
                .text(d => d.toExponential(2))
                .style("font-size", "12px");

            // Add size legend below the color legend
            const sizeLegend = svg.append("g")
                .attr("transform", `translate(${width - 45}, ${10 + legendHeight + 40})`);

            const sizeLegendWidth = 150;
            const sizeLegendHeight = 100;

            // Define the size legend scale
            const sizeLegendScale = d3.scaleSqrt()
                .domain([d3.min(pathwaysData, d => d.Count), d3.max(pathwaysData, d => d.Count)])
                .range([3, 15]);

            // Create the size legend circles
            sizeLegend.selectAll(".size-legend-circle")
                .data([d3.min(pathwaysData, d => d.Count), d3.max(pathwaysData, d => d.Count) / 2, d3.max(pathwaysData, d => d.Count)])
                .enter()
                .append("circle")
                .attr("cx", sizeLegendWidth / 2)
                .attr("cy", (d, i) => i * (sizeLegendHeight / 3) + sizeLegendHeight / 6)
                .attr("r", d => sizeLegendScale(d))
                .style("fill", "none")
                .style("stroke", "black");

            // Add size legend labels
            sizeLegend.selectAll(".size-legend-text")
                .data([d3.min(pathwaysData, d => d.Count), d3.max(pathwaysData, d => d.Count) / 2, d3.max(pathwaysData, d => d.Count)])
                .enter()
                .append("text")
                .attr("x", sizeLegendWidth / 2 + 20)
                .attr("y", (d, i) => i * (sizeLegendHeight / 3) + sizeLegendHeight / 6)
                .attr("dy", ".35em")
                .text(d => d)
                .style("font-size", "12px");
        }


        document.getElementById("closeFunctionalAnalysisOverlayBtn").addEventListener("click", function () {
            document.getElementById("functionalAnalysisOverlay").style.display = "none";
        })


        // function generateNetworkGraph(data_network) {

        //     // Select all radio buttons with name 'strength'
        //     const selectedStrength = document.querySelector('input[name="strength"]:checked');
        //     var data
        //     // Log or use the selected value
        //     if (selectedStrength) {
        //         console.log("Selected strength:", selectedStrength.value);
        //         console.log(selectedStrength.value);  // This will return 'strong', 'weak', or 'strong_weak'
        //         if (selectedStrength.value === "strong_weak") {
        //             // No filtering, use the entire data_network
        //             data = data_network;
        //         } else if (selectedStrength.value === "strong") {
        //             // Filter out targets with "CLIP" in their experiments field
        //             data = {
        //                 targets: data_network.targets.filter(target => !target.experiments.includes("CLIP"))
        //             };
        //         } else if (selectedStrength.value === "weak") {
        //             // Keep only targets with "CLIP" in their experiments field
        //             data = {
        //                 targets: data_network.targets.filter(target => target.experiments.includes("CLIP"))
        //             };
        //         }

        //     } else {
        //         console.log("No option selected.");
        //     }
        //     document.getElementById("loadingOverlay").style.display = "none"

        //     console.log(data);
        //     d3.select("#networkSvgContainer").html("");

        //     // Create SVG with specified dimensions
        //     var svg = d3.select("#networkSvgContainer").append("svg")
        //         .attr("width", 680)  // Set the width to 1780
        //         .attr("height", 500)  // Set the height to 500
        //         .attr("viewBox", "0 0 680 500") // Update viewBox to match dimensions
        //         .attr("preserveAspectRatio", "xMidYMid meet");

        //     var zoom = d3.zoom()
        //         .scaleExtent([0.1, 5])
        //         .on("zoom", zoomed);

        //     svg.call(zoom);

        //     var container = svg.append("g");

        //     var links = data.targets.map(d => ({
        //         source: d.source_miRNA,
        //         target: d.target_gene
        //     }));

        //     var nodeMap = {};
        //     links.forEach(link => {
        //         nodeMap[link.source] = { name: link.source, edges: [], degree: 0 };
        //         nodeMap[link.target] = { name: link.target, edges: [], degree: 0 };
        //     });

        //     links.forEach(link => {
        //         // Add the target to the source node's edges if it doesn't already exist
        //         if (!nodeMap[link.source].edges.includes(link.target)) {
        //             nodeMap[link.source].edges.push(link.target);
        //             nodeMap[link.source].degree++;
        //         }

        //         // Add the source to the target node's edges if it doesn't already exist
        //         if (!nodeMap[link.target].edges.includes(link.source)) {
        //             nodeMap[link.target].edges.push(link.source);
        //             nodeMap[link.target].degree++;
        //         }
        //     });

        //     var nodes = Object.values(nodeMap);

        //     // Get the selected minimum interaction value from the dropdown
        //     const minInteractions = parseInt(document.getElementById("minInteractions").value);

        //     // Filter nodes based on the minimum interactions (degree)
        //     nodes = nodes.filter(node => node.degree >= minInteractions);

        //     // Rebuild links based on filtered nodes and ensure uniqueness
        //     const linkSet = new Set();
        //     links = links.filter(link =>
        //         nodes.some(node => node.name === link.source) &&
        //         nodes.some(node => node.name === link.target)
        //     ).map(link => {
        //         // Create a unique key for each link based on source and target
        //         const sourceName = link.source;
        //         const targetName = link.target;
        //         const linkKey = `${sourceName}-${targetName}`;

        //         // Check if this link already exists in the Set
        //         if (!linkSet.has(linkKey)) {
        //             linkSet.add(linkKey);  // Add to Set to ensure uniqueness

        //             // Map the link to nodes
        //             return {
        //                 source: nodes.find(node => node.name === link.source),
        //                 target: nodes.find(node => node.name === link.target)
        //             };
        //         }
        //         return null;  // Return null for duplicates
        //     }).filter(link => link !== null); // Remove null values (duplicates) from the array

        //     console.log(links);
        //     console.log(nodes);

        //     // Add metrics to nodes
        //     calculateMetrics(nodes, links);

        //     // Set up the force simulation
        //     var simulation = d3.forceSimulation(nodes)
        //         .force("link", d3.forceLink().links(links))
        //         .force("charge", d3.forceManyBody())
        //         .force("center", d3.forceCenter(340, 250)); // Center the force simulation

        //     var link = container.append("g")
        //         .attr("class", "links")
        //         .selectAll("line")
        //         .data(links)
        //         .enter().append("line")
        //         .style("stroke", "#fa744d")
        //         .style("opacity", 1)
        //         .style("stroke-width", "1px");

        //     var node = container.append("g")
        //         .attr("class", "nodes")
        //         .selectAll("g")
        //         .data(nodes)
        //         .enter().append("g")
        //         .call(d3.drag()
        //             .on("start", dragStarted)
        //             .on("drag", dragged)
        //             .on("end", dragEnded)
        //         );

        //     // Define the tooltip
        //     var tooltip = d3.select("body").append("div")
        //         .attr("class", "tooltip")  // Style this class in your CSS
        //         .style("position", "absolute")
        //         .style("padding", "6px")
        //         .style("background", "lightgray")
        //         .style("border-radius", "4px")
        //         .style("pointer-events", "none")
        //         .style("opacity", 0);  // Initially hidden



        //     let selectedNode = [] // Track the currently selected node

        //     node.append("circle")
        //         .attr("r", d => selectedGeneData.includes(d.name) ? 10 : 5)
        //         .attr("fill", d => selectedGeneData.includes(d.name) ? "yellow" : "#C14A82")
        //         .attr("stroke", d => selectedGeneData.includes(d.name) ? "goldenrod" : "#C14A82")
        //         .attr("stroke-width", 2)
        //         .on("mouseover", (d) => {
        //             console.log(d)
        //             tooltip.transition()
        //                 .duration(200)
        //                 .style("opacity", 0.9);  // Fade in the tooltip

        //             tooltip.html(`Node: ${d.name}<br>Degree: ${d.degree}`)
        //                 .style("left", (d3.event.pageX + 10) + "px")  // Position tooltip to the right of the mouse
        //                 .style("top", (d3.event.pageY - 10) + "px");
        //         })
        //         .on("mousemove", event => {
        //             tooltip.style("left", (d3.event.pageX + 10) + "px")
        //                 .style("top", (d3.event.pageY - 10) + "px");
        //         })
        //         .on("mouseout", () => {
        //             tooltip.transition()
        //                 .duration(200)
        //                 .style("opacity", 0);  // Fade out the tooltip
        //         })
        //         .on("click", (d) => {
        //             // Check if the clicked node is already selected
        //             if (selectedNode.includes(d)) {
        //                 // Deselect all nodes and links, returning them to their original color
        //                 node.selectAll("circle")
        //                     .style("fill", nd => selectedGeneData.includes(nd.name) ? "yellow" : "#C14A82")
        //                     .style("stroke", nd => selectedGeneData.includes(nd.name) ? "goldenrod" : "#C14A82")
        //                     .style("opacity", 1);

        //                 link
        //                     .style("stroke", "#fa744d")
        //                     .style("opacity", 1);

        //                 // Reset selectedNode
        //                 selectedNode = [];
        //             } else if (!selectedNode.includes(d) && !d3.event.ctrlKey) {
        //                 // Set all nodes and links to a faded style
        //                 node.selectAll("circle")
        //                     .style("fill", "grey")
        //                     .style("opacity", 0.8)
        //                     .style("stroke", "grey");

        //                 link
        //                     .style("stroke", "grey")
        //                     .style("opacity", 0.3);

        //                 // Reset selectedNode
        //                 selectedNode = [];

        //                 // Highlight the selected node
        //                 d3.select(d3.event.currentTarget)
        //                     .style("fill", selectedGeneData.includes(d.name) ? "yellow" : "#C14A82")
        //                     .style("stroke", selectedGeneData.includes(d.name) ? "goldenrod" : "#C14A82")
        //                     .style("opacity", 1);

        //                 // Highlight connected nodes and links
        //                 const connectedNodes = new Set();
        //                 links.forEach(link => {
        //                     if (link.source.name === d.name || link.target.name === d.name) {
        //                         // Highlight link
        //                         d3.select(`line[data-source="${link.source.name}"][data-target="${link.target.name}"]`)
        //                             .style("stroke", "#fa744d")
        //                             .style("opacity", 1);

        //                         // Add connected nodes to the set
        //                         connectedNodes.add(link.source.name);
        //                         connectedNodes.add(link.target.name);
        //                     }
        //                 });

        //                 // Highlight connected nodes
        //                 node.selectAll("circle")
        //                     .filter(nd => connectedNodes.has(nd.name))
        //                     .each(nd => selectedNode.push(nd))
        //                     .style("fill", nd => selectedGeneData.includes(nd.name) ? "yellow" : "#C14A82")
        //                     .style("stroke", nd => selectedGeneData.includes(nd.name) ? "goldenrod" : "#C14A82")
        //                     .style("opacity", 1)

        //                 // Update the selected node
        //                 selectedNode.push(d);
        //             } else if (!selectedNode.includes(d) && d3.event.ctrlKey) {
        //                 // Highlight the selected node
        //                 d3.select(d3.event.currentTarget)
        //                     .style("fill", selectedGeneData.includes(d.name) ? "yellow" : "#C14A82")
        //                     .style("stroke", selectedGeneData.includes(d.name) ? "goldenrod" : "#C14A82")
        //                     .style("opacity", 1);

        //                 // Highlight connected nodes and links
        //                 const connectedNodes = new Set();
        //                 links.forEach(link => {
        //                     if (link.source.name === d.name || link.target.name === d.name) {
        //                         // Highlight link
        //                         d3.select(`line[data-source="${link.source.name}"][data-target="${link.target.name}"]`)
        //                             .style("stroke", "#fa744d")
        //                             .style("opacity", 1);

        //                         // Add connected nodes to the set
        //                         connectedNodes.add(link.source.name);
        //                         connectedNodes.add(link.target.name);
        //                     }
        //                 });

        //                 // Highlight connected nodes
        //                 node.selectAll("circle")
        //                     .filter(nd => connectedNodes.has(nd.name))
        //                     .each(nd => selectedNode.push(nd))
        //                     .style("fill", nd => selectedGeneData.includes(nd.name) ? "yellow" : "#C14A82")
        //                     .style("stroke", nd => selectedGeneData.includes(nd.name) ? "goldenrod" : "#C14A82")
        //                     .style("opacity", 1)

        //                 // Update the selected node
        //                 selectedNode.push(d);

        //             }
        //         });

        //     // Set data attributes for each link to facilitate selection by source and target names
        //     link.attr("data-source", d => d.source.name)
        //         .attr("data-target", d => d.target.name);


        //     // node.append("text")
        //     //     .attr("dy", -3)
        //     //     .attr("x", 6)
        //     //     .text(d => d.name);

        //     simulation.on("tick", ticked);

        //     function ticked() {
        //         link
        //             .attr("x1", d => d.source.x)
        //             .attr("y1", d => d.source.y)
        //             .attr("x2", d => d.target.x)
        //             .attr("y2", d => d.target.y);

        //         node.attr("transform", d => `translate(${d.x}, ${d.y})`);

        //         // Optional: Adjust viewBox dynamically based on node positions
        //         const xExtent = d3.extent(nodes, d => d.x);
        //         const yExtent = d3.extent(nodes, d => d.y);
        //         svg.attr("viewBox", `${xExtent[0] - 50} ${yExtent[0] - 50} ${xExtent[1] - xExtent[0] + 100} ${yExtent[1] - yExtent[0] + 100}`);
        //     }

        //     function zoomed(event) {
        //         container.attr("transform", d3.event.transform);
        //     }

        //     function dragStarted(d) {
        //         if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        //         d.fx = d.x;
        //         d.fy = d.y;
        //     }

        //     function dragged(d) {
        //         d.fx = d3.event.x;
        //         d.fy = d3.event.y;
        //     }

        //     function dragEnded(d) {
        //         if (!d3.event.active) simulation.alphaTarget(0);
        //         d.fx = d3.event.x;
        //         d.fy = d3.event.y;
        //     }
        // }


        function calculateAverageExpressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Add the expression value to the sum and increment the count
                        geneSumCount[gene].sum += parseFloat(geneData[sample]);
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average for each gene
            var averageExpressions = {};
            for (var gene in geneSumCount) {
                averageExpressions[gene] = geneSumCount[gene].sum / geneSumCount[gene].count;
            }

            return averageExpressions;
        }

        function calculateAverageLog10Expressions(dataArray) {
            // Create an object to store the sum and count for each gene
            var geneSumCount = {};

            // Iterate through each gene object in the array
            dataArray.forEach(function (geneData) {
                var gene = geneData.gene;

                // Iterate through each property (sample) in the gene object
                for (var sample in geneData) {
                    if (sample !== 'gene') {
                        // If the gene is not in the sumCount object, initialize it
                        if (!geneSumCount[gene]) {
                            geneSumCount[gene] = { sum: 0, count: 0 };
                        }

                        // Add the expression value to the sum and increment the count
                        geneSumCount[gene].sum += parseFloat(geneData[sample]);
                        geneSumCount[gene].count++;
                    }
                }
            });

            // Calculate the average expression for each gene and apply log10 transformation
            var averageLog10Expressions = {};
            for (var gene in geneSumCount) {
                // Calculate mean
                var meanExpression = geneSumCount[gene].sum / geneSumCount[gene].count;
                // Apply log10 transformation, adding 1 to avoid log(0)
                averageLog10Expressions[gene] = Math.log10(meanExpression + 1);
            }

            return averageLog10Expressions;
        }

        function updateStatisticalMethod(method) {
            document.getElementById('currentMethod').innerHTML = `Method<br>${method}`;
        }

        function updateChosenAnalysis() {
            document.getElementById('currentAnalysis').innerHTML = `${chosen_meta1}<br>vs.<br>${chosen_meta2}`;
            document.getElementById('currentAnalysis').style.lineHeight = '1'; // Reduce line height to decrease vertical spacing
        }

        function updateUpandDown() {
            const regulationElement = document.getElementById("geneRegulationInfo");
            // Initialize counters
            let upregulatedCount = 0;
            let downregulatedCount = 0;

            // Create a map for quick lookup of logFC based on gene names
            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                map[gene.Gene] = gene.logFC;
                return map;
            }, {});

            // Sort old_p_adj by pval_adj (lowest first)
            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

            // Prepare data for DataTables
            const geneData = sortedOldPAdj.map(gene => {
                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : ""; // Handle cases where logFC is missing
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.pval_adj,
                    LogFC: logFC
                };
            });

            // Count upregulated and downregulated genes
            geneData.forEach(gene => {
                if (gene.AdjPVal < threshold) {
                    if (gene.LogFC >= 0) {
                        upregulatedCount++;
                    } else if (gene.LogFC <= 0) {
                        downregulatedCount++;
                    }
                }
            });

            // Update the element with line breaks for separate rows
            regulationElement.innerHTML = `Upregulated: ${upregulatedCount}<br>Downregulated: ${downregulatedCount}`;
        }


        function updateCounter() {
            var stringmiRNAgene = "miRNAs"
            if (!only_miRNAs) stringmiRNAgene = "Genes"
            // Select the counter div
            var counterDiv = d3.select("#counter");
            var counterDiv1 = d3.select("#counter1");
            console.log(data_copy.length)
            console.log(data_copy_pval.length)
            if (data_copy_pval.length > data_copy.length) {
                // Update the content of the counter and apply margin-left to text
                counterDiv.html(
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>Total number of " + stringmiRNAgene + ":</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing IQR Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy1.length + " (" + ((data_copy1.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FC Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FDR Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
                );
            }
            else {

                counterDiv.html(
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>Total number of " + stringmiRNAgene + ":</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing IQR Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy1.length + " (" + ((data_copy1.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FC Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FDR Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy_pval.length + " (" + ((data_copy_pval.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
                );

            }

            // Update the content of the counter and apply margin-left to text
            counterDiv.html(
                "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>Total number of " + stringmiRNAgene + ":</span>" +
                "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing IQR Filter:</span>" +
                "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy1.length + " (" + ((data_copy1.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FC Filter:</span>" +
                "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FDR Filter:</span>" +
                "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy_pval.length + " (" + ((data_copy_pval.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
            );

            if (chosen_statistic != "deseq2") {
                counterDiv1.html(
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>Parameters:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'> </span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>IQR threshold:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'>" + thr_prc.toFixed(3) + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>Log FC threshold:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'>" + log_thr_fc.toFixed(3) + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>Significance level:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'>" + threshold + "</span>"
                );
            } else {
                counterDiv.html(
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>Total number of " + stringmiRNAgene + ":</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_original.length + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FC Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy.length + " (" + ((data_copy.length / data_original.length) * 100).toFixed(1) + "%)" + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold; font-size : 11px;'>" + stringmiRNAgene + " Passing FDR Filter:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold; margin-left: 15px;'>" + data_copy_pval.length + " (" + ((data_copy_pval.length / data_original.length) * 100).toFixed(1) + "%)" + "</span>"
                );
                counterDiv1.html(
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>Parameters:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'> </span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>Log FC threshold:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'>" + log_thr_fc.toFixed(3) + "</span><br>" +
                    "<span style='display: inline-block; width: 50%; margin-left: 10px; font-weight: bold;'>Significance level:</span>" +
                    "<span style='display: inline-block; width: 50%; text-align: center; font-weight: bold;'>" + threshold + "</span>"
                );

            }

        }

        const distanceDescriptions = {
            binary: "Binary distance is a measure that calculates the similarity between two data points based on the presence or absence of certain features.",
            canberra: "Canberra distance is a weighted version of the Manhattan distance that is sensitive to small values.",
            correlation: "Correlation distance measures how well two data points correlate with each other, often used for finding similarities in patterns.",
            euclidean: "Euclidean distance is the straight-line distance between two points in Euclidean space.",
            maximum: "Maximum distance measures the greatest difference along any coordinate dimension between two data points.",
            manhattan: "Manhattan distance is the sum of the absolute differences of their Cartesian coordinates.",
            minkowski: "Minkowski distance is a generalized form of both Euclidean and Manhattan distances."
        };

        const methodDescriptions = {
            average: "Average linkage clustering uses the average distance between all pairs of items to determine cluster distance.",
            centroid: "Centroid linkage clustering uses the distance between the centroids of clusters to determine cluster distance.",
            complete: "Complete linkage clustering uses the maximum distance between pairs of items to determine cluster distance.",
            mcquitty: "McQuitty (WPGMA) linkage clustering uses the average distance between all items in clusters.",
            median: "Median linkage clustering uses the median distance between items in clusters.",
            single: "Single linkage clustering uses the minimum distance between pairs of items to determine cluster distance.",
            "ward.D": "Ward's method minimizes the total within-cluster variance.",
            "ward.D2": "Ward's method (D2) is a modified version of Ward's method that may produce different clustering results."
        };

        // Function to update the distance description based on the selected value
        function updateDistanceDescription() {
            const selectedDistance = document.getElementById("clusteringDistance").value;
            document.getElementById("distanceDescription").textContent = distanceDescriptions[selectedDistance];
        }

        // Function to update the method description based on the selected value
        function updateMethodDescription() {
            const selectedMethod = document.getElementById("clusteringMethod").value;
            document.getElementById("methodDescription").textContent = methodDescriptions[selectedMethod];
        }

        // Add event listeners to update descriptions on selection change
        document.getElementById("clusteringDistance").addEventListener("change", updateDistanceDescription);
        document.getElementById("clusteringMethod").addEventListener("change", updateMethodDescription);

        document.getElementById("heatmapButton").addEventListener("click", function () {
            // Initial call to set descriptions on page load
            updateDistanceDescription();
            updateMethodDescription();
            document.getElementById("heatmapOptionsOverlay").style.display = "block";
        });

        document.getElementById("closeHeat").addEventListener("click", function () {
            document.getElementById("heatmapOptionsOverlay").style.display = "none";
        });

        document.getElementById("heatmapSubmission").addEventListener("click", function () {
            document.getElementById("loadingOverlay").style.display = "block";

            // Retrieve the selected values from the dropdowns
            var clusteringDistance = document.getElementById("clusteringDistance").value;
            var clusteringMethod = document.getElementById("clusteringMethod").value;

            // Retrieve the checkbox values for row and column names
            var includeRowNames = document.getElementById("includeRowNames").checked;
            var includeColNames = document.getElementById("includeColNames").checked;

            // Retrieve the gene selection choice (all DEGs or selected genes)
            var geneSelection = document.querySelector('input[name="geneSelection"]:checked').value;

            // Handle gene selection: filter data if selected genes only
            var dataForHeatmap = data_copy_pval;

            if (geneSelection === "selected") {
                // Filter data_copy_pval to include only rows with genes in selectedGeneData
                dataForHeatmap = data_copy_pval.filter(function (row) {
                    return selectedGeneData.includes(row.gene);  // Assuming 'gene' is the field for gene names
                });
            }

            // Retrieve the number of cluster columns and rows
            var cutreeCols = document.getElementById("clusterCols").value;
            var cutreeRows = document.getElementById("clusterRows").value;


            // Pass the filtered or complete data to the printHeatmap function
            printHeatmap(clusteringDistance, clusteringMethod, includeRowNames, includeColNames, dataForHeatmap, cutreeCols, cutreeRows);
        });


        document.getElementById("closeHeatmapOverlayBtn").addEventListener("click", function () {
            document.getElementById("heatmapOverlay").style.display = "none";
        });


        function printHeatmap(clusteringDistance, clusteringMethod, includeRowNames, includeColNames, dataForHeatmap, cutreeCols, cutreeRows) {
            console.log(meta_for_heatmap);
            console.log(data_copy_pval);

            document.getElementById("heatmapOptionsOverlay").style.display = "none";

            var req = ocpu.call("heatmap?no_cache=1", {
                data: dataForHeatmap,
                metadata: meta_for_heatmap,
                field: selectedRowName,
                case: chosen_meta1,
                distance: clusteringDistance,
                method: clusteringMethod,
                show_cols: includeColNames,
                show_rows: includeRowNames,
                cutreeCols: cutreeCols,
                cutreeRows: cutreeRows
            }, function (session) {
                var filteredDataURL = session.loc + "/R/.val/json";

                // Fetch the filtered data from the URL
                fetch(filteredDataURL)
                    .then(response => {
                        // Check if the response is ok (status 200-299)
                        if (!response.ok) {
                            document.getElementById("loadingOverlay").style.display = "none";
                            throw new Error(`Error fetching data: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(session);

                        // URL to the generated SVG file
                        var svgURL = session.loc + "files/heatmap_output.svg";

                        // Clear any existing heatmap SVG in the container
                        d3.select("#heatmapSvgContainer").selectAll("*").remove();

                        d3.xml(svgURL, function (error, xml) {
                            if (error) {
                                alert("Error loading SVG: " + error);
                                console.error("Error loading SVG:", error);
                                return; // Stop execution if there's an error
                            }

                            // Append the SVG to the container
                            document.getElementById('heatmapSvgContainer').appendChild(xml.documentElement);

                            // Optionally style or modify the SVG using d3.js
                            d3.selectAll("text")
                                .style("font-family", "Arial");

                            // Set the viewBox and preserveAspectRatio for scaling
                            d3.select("#heatmapSvgContainer svg")
                                .attr("height", "100%")
                                .attr("width", "100%");

                            document.getElementById("downloadPngBtn").onclick = function () {
                                downloadSvgAsPng(svgURL);
                            };

                            document.getElementById("loadingOverlay").style.display = "none";

                            // Show the heatmap overlay
                            document.getElementById("heatmapOverlay").style.display = "block";
                        });
                    })
                    .catch(error => {
                        document.getElementById("loadingOverlay").style.display = "none";
                        alert("Error: " + error.message);
                        console.error("Error in fetch operation:", error);
                    });
            }).fail(function (jqXHR, textStatus, errorThrown) {
                document.getElementById("loadingOverlay").style.display = "none";
                alert("Error calling heatmap: " + textStatus + " " + errorThrown);
                console.error("Error in ocpu.call:", textStatus, errorThrown);
            });

            // var req = ocpu.call("heatmap_mod?no_cache=1", {
            //     data: dataForHeatmap,
            //     metadata: meta_for_heatmap,
            //     field: selectedRowName,
            //     case: chosen_meta1,
            //     distance: clusteringDistance,
            //     method: clusteringMethod,
            //     show_cols: includeColNames,
            //     show_rows: includeRowNames,
            //     cutreeCols: cutreeCols,
            //     cutreeRows: cutreeRows
            // }, function (session) {
            //     var filteredDataURL = session.loc + "/R/.val/json";

            //     // Fetch the filtered data from the URL
            //     fetch(filteredDataURL)
            //         .then(response => {
            //             // Check if the response is ok (status 200-299)
            //             if (!response.ok) {
            //                 document.getElementById("loadingOverlay").style.display = "none";
            //                 throw new Error(`Error fetching data: ${response.status} ${response.statusText}`);
            //             }
            //             return response.json();
            //         })
            //         .then(data => {
            //             console.log(session);
            //             document.getElementById("loadingOverlay").style.display = "none";

            //         })
            //         .catch(error => {
            //             document.getElementById("loadingOverlay").style.display = "none";
            //             alert("Error: " + error.message);
            //             console.error("Error in fetch operation:", error);
            //         });
            // }).fail(function (jqXHR, textStatus, errorThrown) {
            //     document.getElementById("loadingOverlay").style.display = "none";
            //     alert("Error calling heatmap: " + textStatus + " " + errorThrown);
            //     console.error("Error in ocpu.call:", textStatus, errorThrown);
            // });

        }

        function downloadSvgAsPng(svgURL) {
            // Create a new Image object
            const img = new Image();
            img.crossOrigin = 'anonymous'; // Ensure cross-origin issues don't prevent image loading
            img.src = svgURL;

            img.onload = function () {
                // Create a canvas element
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');

                // Increase the scale factor to improve quality (e.g., 2x or 3x)
                const scaleFactor = 4; // You can adjust this scale for higher quality

                // Set canvas dimensions based on the SVG size, scaled up
                const svgWidth = img.width * scaleFactor;
                const svgHeight = img.height * scaleFactor;

                // Set the canvas size to the scaled dimensions
                canvas.width = svgWidth;
                canvas.height = svgHeight;

                // Draw the image on the canvas with the scale factor applied
                context.drawImage(img, 0, 0, svgWidth, svgHeight);

                // Convert canvas to PNG data URL
                const pngURL = canvas.toDataURL('image/png');

                // Create an anchor element and trigger the download
                const a = document.createElement('a');
                a.href = pngURL;
                a.download = 'heatmap_output.png'; // Name for the downloaded file
                document.body.appendChild(a);
                a.click(); // Simulate a click to trigger the download
                document.body.removeChild(a); // Clean up the DOM
            };

            img.onerror = function (error) {
                alert('Error loading SVG for download: ' + error);
                console.error('Error loading SVG:', error);
            };
        }

        document.addEventListener("DOMContentLoaded", () => {
            const exportButton = document.getElementById("exportGenesButton");
            if (exportButton) {
                exportButton.addEventListener("click", exportGenes);
            } else {
                console.error("exportGenesButton not found in DOM.");
            }
        });

        let diffExpressedTable; // Declare the DataTable reference globally
        let selectedGenesTable; // Declare the DataTable reference globally
        let selectedGSMTable;
        function exportGenes() {
            console.log("Ciao")
            const logFCMap = parsedLogFC_origin1.reduce((map, gene) => {
                map[gene.Gene] = gene.logFC;
                return map;
            }, {});

            const sortedOldPAdj = old_p_adj.sort((a, b) => a.pval_adj - b.pval_adj);

            // Prepare data for Differential Expressed Genes
            const geneData = sortedOldPAdj.map(gene => {
                const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.pval_adj,
                    LogFC: logFC
                };
            });

            // Initialize the DataTable for Differential Expressed Genes
            initializeDiffExpressedTable(geneData);

            // // Add checkbox event listener
            // document.getElementById("includePCA").addEventListener("change", function () {
            //     diffExpressedTable.clear().destroy();
            //     $('#diffExpressedTable' + " tbody").empty();
            //     $('#diffExpressedTable' + " thead").empty();

            //     const includePCA = this.checked;
            //     updateDiffExpressedTable(includePCA, geneData);
            // });

            // Function to initialize the DataTable
            function initializeDiffExpressedTable(data) {
                diffExpressedTable = $('#diffExpressedTable').DataTable({
                    data: data,
                    columns: [
                        { title: "Gene", data: "Gene" },
                        { title: "AdjPVal", data: "AdjPVal" },
                        { title: "LogFC", data: "LogFC" }
                    ],
                    destroy: true,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }

            // Function to update the Differential Expressed Genes table
            function updateDiffExpressedTable(includePCA, data) {
                // Prepare data for Differential Expressed Genes
                var updatedData = data.map(gene => {
                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                    const pc1Contribution = includePCA ? getPC1Contribution(gene.Gene) : ""; // Get PC1 Contribution if checkbox is checked

                    const entry = {
                        Gene: gene.Gene,
                        AdjPVal: gene.AdjPVal,
                        LogFC: logFC
                    };

                    // Add PC1 Contribution only if PCA is included
                    if (includePCA) {
                        entry.PC1_Contribution = pc1Contribution;
                    }

                    return entry;
                });

                // Destroy the existing DataTable if it exists
                if ($.fn.DataTable.isDataTable('#diffExpressedTable')) {
                    $('#diffExpressedTable').DataTable().clear().destroy();
                    $('#diffExpressedTable' + " tbody").empty();
                    $('#diffExpressedTable' + " thead").empty();
                }

                // Define columns based on whether PCA is included
                const columns = [
                    { title: "Gene", data: "Gene" },
                    { title: "AdjPVal", data: "AdjPVal" },
                    { title: "LogFC", data: "LogFC" }
                ];

                if (includePCA) {
                    columns.push({ title: "PC1 Contribution", data: "PC1_Contribution" }); // Add column for PC1 Contribution
                }

                console.log(updatedData)
                // $('#tblRemittanceList tbody').empty();
                // Initialize the DataTable with the updated data and columns
                diffExpressedTable = $('#diffExpressedTable').DataTable({
                    data: updatedData,
                    columns: columns,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }

            // Function to get PC1 Contribution for a given gene
            function getPC1Contribution(gene) {
                const geneDataEntry = heatmap_data.find(entry => entry.gene === gene);
                return geneDataEntry ? geneDataEntry.pc1 : ""; // Return PC1 value or empty string if not found
            }

            // Prepare data for Selected Genes
            const selectedGenesData = geneData.filter(gene => selectedGeneData.includes(gene.Gene)).map(gene => {
                return {
                    Gene: gene.Gene,
                    AdjPVal: gene.AdjPVal,
                    LogFC: gene.LogFC
                };
            });

            // Add checkbox event listener for Selected Genes
            // document.getElementById("includePCA2").addEventListener("change", function () {
            //     selectedGenesTable.clear().destroy();
            //     $('#selectedGenesTable' + " tbody").empty();
            //     $('#selectedGenesTable' + " thead").empty();

            //     const includePCA = this.checked;
            //     updateSelectedGenesTable(includePCA, geneData); // Call update for selected genes
            // });


            // Initialize DataTable for Selected Genes
            initializeSelectedGenesTable(selectedGenesData);


            // Function to initialize the DataTable for Selected Genes
            function initializeSelectedGenesTable(data) {
                selectedGenesTable = $('#selectedGenesTable').DataTable({
                    data: data,
                    columns: [
                        { title: "Gene", data: "Gene" },
                        { title: "AdjPVal", data: "AdjPVal" },
                        { title: "LogFC", data: "LogFC" }
                    ],
                    destroy: true,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }

            // Function to update the Selected Genes table
            function updateSelectedGenesTable(includePCA, data) {
                // Prepare data for Selected Genes
                const updatedData = data.filter(gene => selectedGeneData.includes(gene.Gene)).map(gene => {
                    const logFC = logFCMap[gene.Gene] !== undefined ? logFCMap[gene.Gene] : "";
                    const pc1Contribution = includePCA ? getPC1Contribution(gene.Gene) : ""; // Get PC1 Contribution if checkbox is checked

                    return {
                        Gene: gene.Gene,
                        AdjPVal: gene.AdjPVal,
                        LogFC: logFC,
                        PC1_Contribution: pc1Contribution // Include PC1 Contribution if checkbox is checked
                    };
                });

                // Destroy the existing DataTable if it exists
                if ($.fn.DataTable.isDataTable('#selectedGenesTable')) {
                    $('#selectedGenesTable').DataTable().clear().destroy();
                    $('#selectedGenesTable' + " tbody").empty();
                    $('#selectedGenesTable' + " thead").empty();
                }

                // Define columns for Selected Genes based on whether PCA is included
                const columns = [
                    { title: "Gene", data: "Gene" },
                    { title: "AdjPVal", data: "AdjPVal" },
                    { title: "LogFC", data: "LogFC" }
                ];

                if (includePCA) {
                    columns.push({ title: "PC1 Contribution", data: "PC1_Contribution" }); // Add column for PC1 Contribution
                }

                // Initialize the DataTable with the updated data and columns
                selectedGenesTable = $('#selectedGenesTable').DataTable({
                    data: updatedData,
                    columns: columns,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }
            console.log(data_original)
            console.log(gsmList)

            // Prepare data for Selected GSM Genes from original data
            const selectedGSMData = {};

            // Initialize an object to hold the inverted structure
            const invertedData = {};

            // Collect GSM values for each gene in gsmList
            data_original.forEach(entry => {
                // Check if the gene is in the selectedGeneData
                if (selectedGeneData.includes(entry.gene)) {
                    // Iterate over the keys of entry to collect GSM values
                    for (const gsm in entry) {
                        if (gsmList.includes(gsm)) {
                            // If the GSM is not already in invertedData, initialize it
                            if (!invertedData[gsm]) {
                                invertedData[gsm] = { Sample: gsm }; // Start with GSM key
                            }
                            // Assign the gene value to the corresponding GSM entry
                            invertedData[gsm][entry.gene] = entry[gsm];
                        }
                    }
                }
            });

            // Format data for the selectedGSMTable
            const selectedGSMTableData = Object.values(invertedData);

            console.log("Inverted Selected GSM Table Data:", JSON.stringify(selectedGSMTableData, null, 2));
            console.log("GSM List:", gsmList);

            // Clear the existing table
            $('#selectedGSMTable').html('');

            // Destroy the existing DataTable if it exists
            if ($.fn.DataTable.isDataTable('#selectedGSMTable')) {
                $('#selectedGSMTable').DataTable().clear().destroy();
                $('#selectedGSMTable' + " tbody").empty();
                $('#selectedGSMTable' + " thead").empty();
            }

            let ok_gsm = false;
            if (gsmList.length === 0) {
                $('#selectedGSMTable').html('<tr><td colspan="100%" style="text-align: center;">No sample selected</td></tr>');
            } else {
                ok_gsm = true;

                // Extract the column names from the inverted data
                const keys = Object.keys(selectedGSMTableData[0] || {});
                const columns = keys.map(key => ({
                    title: key,
                    data: key,
                    defaultContent: ""  // Set default content here for missing values
                }));

                console.log("Columns Definition:", columns); // Log column definitions

                // Initialize DataTable with inverted data
                selectedGSMTable = $('#selectedGSMTable').DataTable({
                    data: selectedGSMTableData,
                    columns: columns,
                    paging: true,
                    pageLength: 5,
                    ordering: true,
                    searching: false,
                    lengthChange: false
                });
            }
            // Show the overlay
            document.getElementById("geneOverlay").style.display = "block";

            // Show the download button
            document.getElementById("confirmDownloadButton").style.display = "block";

            // Set up the download button action
            document.getElementById("confirmDownloadButton").onclick = function () {
                const activeTab = document.querySelector('.tabcontent[style*="display: block"]');
                const activeTable = activeTab.id === "diffExpressedGenes" ? diffExpressedTable :
                    (activeTab.id === "selectedGenes" ? selectedGenesTable : selectedGSMTable);

                downloadCSV(activeTable);
            };




            // Close button functionality
            document.getElementById("closeOverlayButton").onclick = function () {
                // $('#selectedGSMTable').DataTable().destroy(); // Destroy any existing instance
                // $('#selectedGSMTable' + " tbody").empty();
                // $('#selectedGSMTable' + " thead").empty();

                // $('#selectedGenesTable').DataTable().destroy(); // Destroy any existing instance
                // $('#selectedGenesTable' + " tbody").empty();
                // $('#selectedGenesTable' + " thead").empty();

                // $('#diffExpressedTable').DataTable().destroy(); // Destroy any existing instance
                // $('#diffExpressedTable' + " tbody").empty();
                // $('#diffExpressedTable' + " thead").empty();

                // document.getElementById("includePCA").checked = false;
                // document.getElementById("includePCA2").checked = false;

                document.getElementById("geneOverlay").style.display = "none";
            };

            // Handle tab switching
            document.getElementById("diffExpressedTab").addEventListener("click", function () {
                switchTab("diffExpressedGenes", "selectedGenes", "selectedGSM");
            });

            document.getElementById("selectedGenesTab").addEventListener("click", function () {
                switchTab("selectedGenes", "diffExpressedGenes", "selectedGSM");
            });

            document.getElementById("selectedGSMTab").addEventListener("click", function () {
                switchTab("selectedGSM", "diffExpressedGenes", "selectedGenes");
            });

            function switchTab(showId, hideId1, hideId2) {
                document.getElementById(showId).style.display = "block";
                document.getElementById(hideId1).style.display = "none";
                document.getElementById(hideId2).style.display = "none";
                document.querySelectorAll('.tablinks').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`${showId === 'diffExpressedGenes' ? 'diffExpressedTab' : (showId === 'selectedGenes' ? 'selectedGenesTab' : 'selectedGSMTab')}`).classList.add('active');
                const activeTab = document.querySelector('.tabcontent[style*="display: block"]');
                const activeTable = activeTab.id === "diffExpressedGenes" ? diffExpressedTable :
                    (activeTab.id === "selectedGenes" ? selectedGenesTable : selectedGSMTable);

                console.log(activeTab.id)
                if (!ok_gsm && activeTable === selectedGSMTable) {
                    document.getElementById("confirmDownloadButton").style.cursor = "not-allowed"
                    document.getElementById("confirmDownloadButton").style.opacity = 0.6
                    document.getElementById("confirmDownloadButton").disabled = true
                }
                else {
                    document.getElementById("confirmDownloadButton").style.cursor = "pointer"
                    document.getElementById("confirmDownloadButton").style.opacity = 1
                    document.getElementById("confirmDownloadButton").disabled = false
                }

            }
        }

        function downloadCSV(geneTable) {
            // Get data from the DataTable in the current order
            const data = geneTable.rows({ order: 'current' }).data().toArray();

            // Initialize the headers for CSV
            let headers = ["Gene", "AdjPVal", "LogFC"]; // Base headers

            // Check if the checkbox for PCA is checked
            // if (document.getElementById("includePCA").checked || document.getElementById("includePCA2").checked) {
            //     headers.push("PC1_Contribution"); // Add header for PC1_Contribution
            // }

            // Collect GSM columns dynamically
            const gsmColumns = Object.keys(data[0]).filter(key => key !== "Gene" && key !== "AdjPVal" && key !== "LogFC" && key !== "PC1_Contribution");
            if (gsmColumns.length >= 1) headers = ["Gene"].concat(gsmColumns); // Add GSM columns to the headers

            // Create CSV content with the specified headers
            const csvContent = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" +
                data.map(gene => {
                    // Start building the row with the basic fields
                    let row = [
                        gene.Gene,
                        gene.AdjPVal,
                        gene.LogFC
                    ];

                    if (gsmColumns.length >= 1) {
                        row = [gene.Gene]
                    }

                    // Include PC1_Contribution if applicable
                    // if (document.getElementById("includePCA").checked || document.getElementById("includePCA2").checked) {
                    //     row.push(gene.PC1_Contribution !== undefined ? gene.PC1_Contribution : ""); // Add PC1_Contribution
                    // }

                    // Append GSM values dynamically
                    gsmColumns.forEach(gsm => {
                        row.push(gene[gsm] !== undefined ? gene[gsm] : ""); // Add GSM values or empty string if undefined
                    });

                    return row.join(","); // Join the row values with commas
                }).join("\n");

            // Create a link element for downloading the CSV
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "genes.csv");

            // Append the link to the document body and click it programmatically to initiate download
            document.body.appendChild(link);
            link.click();

            // Clean up by removing the link from the document
            document.body.removeChild(link);

            // Close the overlay after download
            document.getElementById("geneOverlay").style.display = "none";
            $('#selectedGSMTable').DataTable().destroy(); // Destroy any existing instance
            $('#selectedGSMTable' + " tbody").empty();
            $('#selectedGSMTable' + " thead").empty();

            $('#selectedGenesTable').DataTable().destroy(); // Destroy any existing instance
            $('#selectedGenesTable' + " tbody").empty();
            $('#selectedGenesTable' + " thead").empty();

            $('#diffExpressedTable').DataTable().destroy(); // Destroy any existing instance
            $('#diffExpressedTable' + " tbody").empty();
            $('#diffExpressedTable' + " thead").empty();

        }


        document.getElementById("importDatasetButton").addEventListener("click", showLoadCsvOverlayMod);

        // Function to show the CSV file loading overlay
        function showLoadCsvOverlayMod() {
            event.stopPropagation();
            second_time = true
            document.getElementById("loadDatasetOverlay").style.display = "block";

            document.getElementById("backBtn").addEventListener("click", function (event) {
                hideLoadCsvOverlay();
                event.stopPropagation();

            })

            // Add event listener to detect clicks outside of the overlay
            document.body.addEventListener("click", hideLoadCsvOverlayOnClickOutside);
        }

        // Function to hide the CSV file loading overlay
        function hideLoadCsvOverlay() {
            document.getElementById("loadDatasetOverlay").style.display = "none";
            document.getElementById("overlay").style.display = "none";

            // Remove the click event listener from the body
            document.body.removeEventListener("click", hideLoadCsvOverlayOnClickOutside);
        }

        // Function to hide the overlay when clicking outside of it
        function hideLoadCsvOverlayOnClickOutside(event) {
            var loadDatasetOverlay = document.getElementById("containeDatasetOverlay");
            // Check if the click target is outside of the overlay
            if (!loadDatasetOverlay.contains(event.target)) {
                hideLoadCsvOverlay();
            }
        }

        // Function to filter and display search results
        function filterAndDisplayResults() {
            const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
            const searchResults = document.getElementById('searchResults');

            // Clear existing results before updating
            searchResults.innerHTML = '';

            if (searchTerm.length === 0) {
                searchResults.style.display = 'none';
                return;
            }

            console.log(data_copy_pval)
            console.log(old_p_adj)
            const matches = old_p_adj.filter(item => {
                // Filter logic based on your data structure
                // Assuming data_copy_pval is an array of objects with 'gene' property
                return item.Gene.toLowerCase().includes(searchTerm) && item.pval_adj < threshold;
            });

            // Display the matches in the results container
            for (let i = 0; i < matches.length && i < 5; i++) {
                const resultElement = document.createElement('a');
                resultElement.id = `result${i + 1}`;
                resultElement.classList.add('result-item');
                resultElement.textContent = matches[i].Gene;

                // Handle click on result to select it
                resultElement.addEventListener('click', (function (gene) {
                    return function (event) {
                        event.stopPropagation(); // Stop propagation to prevent other results from triggering

                        document.getElementById('searchInput').value = gene;

                        // Check if the gene is already in selectedGeneData
                        if (!selectedGeneData.includes(gene)) {
                            selectedGeneData.push(gene);

                            // Add selected Gene to boxplot dropdown menu 
                            // Get the select element
                            // var select = document.getElementById("selectButton");

                            // // Add new options for the genes in selectedGeneData that are not already in the select element
                            // selectedGeneData.forEach(function (gene) {
                            //     if (!Array.from(select.options).some(option => option.value === gene)) {
                            //         var option = document.createElement("option");
                            //         option.value = gene;
                            //         option.text = gene;
                            //         select.appendChild(option);
                            //     }
                            // });

                            dynamicParallel(selectedGeneData, data_copy_pval, dataC_copy_pval, dataN_copy, first_dims);

                            if (ridge) {
                                updateRidgePlot(selectedGeneData, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            } else {
                                updateBoxPlot(last_box, parsedLogFC, dataN_copy_pval, dataC_copy_pval)
                            }
                            if (currentPlot === 'volcano') {
                                updateVolcanoPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else if (currentPlot === 'scatter') {
                                updateScatterPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } else {
                                updateMAPlot(averageExpressions10N, averageExpressions10C, log_thr_fc, parsedLogFC_origin1, old_p_adj)
                            } heatmap(heatmap_data)
                        }
                        searchResults.style.display = 'none'; // Hide results after selection
                    };
                })(matches[i].Gene)); // Immediately invoked function to capture current gene value

                searchResults.appendChild(resultElement); // Append each result to the results container
            }

            // Show the results container if there are matches
            if (matches.length > 0) {
                searchResults.style.display = 'block';
            } else {
                searchResults.style.display = 'none';
            }
        }

        // Handle input in search input
        document.getElementById('searchInput').addEventListener('input', function () {
            filterAndDisplayResults();
        });

        // Handle focus on search input to show results
        document.getElementById('searchInput').addEventListener('focus', function () {
            filterAndDisplayResults();
        });

        // Handle blur on search input to hide results
        document.getElementById('searchInput').addEventListener('blur', function () {
            const searchResults = document.getElementById('searchResults');
            const relatedTarget = document.activeElement;

            if (!searchResults.contains(relatedTarget)) {
                searchResults.style.display = 'none';
            }
        });

        // Handle click inside search results container to prevent hiding
        document.getElementById('searchResults').addEventListener('mousedown', function (event) {
            event.preventDefault(); // Prevents focus change which would trigger blur
        });


    </script>

    <div id="tooltip"
        style="position: absolute; opacity: 0; background-color: white; border: 1px solid #ddd; padding: 5px; z-index: 10000;">
    </div>
    <div id="tTestResults"></div>

</body>

</html>